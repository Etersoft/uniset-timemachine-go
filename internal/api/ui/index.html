<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>TimeMachine Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root { font-family: "Space Grotesk", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif; color: #e5e7eb; background: #0b1220; }
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at 10% 10%, rgba(20,184,166,0.08), transparent 22%), radial-gradient(circle at 80% 0%, rgba(14,165,233,0.12), transparent 30%), #0b1220; }
    .page { max-width: 1200px; margin: 0 auto; padding: 26px 18px 60px; }
    .header { display: flex; justify-content: space-between; gap: 14px; align-items: center; }
    .title h1 { margin: 4px 0 6px; font-size: 26px; color: #f8fafc; letter-spacing: -0.01em; }
    .eyebrow { text-transform: uppercase; font-size: 12px; letter-spacing: 0.24em; color: #93c5fd; margin: 0; }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { padding: 8px 12px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: #e2e8f0; font-weight: 600; font-size: 13px; }
    .chip.ok { color: #10b981; border-color: rgba(16,185,129,0.4); background: rgba(16,185,129,0.12); }
    .chip.warn { color: #f59e0b; border-color: rgba(245,158,11,0.35); background: rgba(245,158,11,0.12); }
    .chip.err { color: #f87171; border-color: rgba(248,113,113,0.4); background: rgba(248,113,113,0.12); }
    .card { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 14px 16px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); margin-top: 14px; }
    .row { display: flex; gap: 10px; }
    .row.wrap { flex-wrap: wrap; }
    .row.center { align-items: center; }
    label { display: block; font-size: 12px; color: #9ca3af; margin-bottom: 4px; }
    input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #233143; background: #0b1324; color: #e2e8f0; font-size: 14px; outline: none; }
    input:focus { border-color: #22d3ee; box-shadow: 0 0 0 3px rgba(34,211,238,0.12); }
    input::placeholder { color: #94a3b8; }
    button { border: none; border-radius: 12px; padding: 12px; background: linear-gradient(135deg, #0ea5e9, #14b8a6); color: #0b1220; font-weight: 700; cursor: pointer; transition: transform 0.08s ease, box-shadow 0.14s ease, opacity 0.12s, background 0.12s, color 0.12s, border-color 0.12s; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(14,165,233,0.35); }
    button:active:not(:disabled) { background: linear-gradient(135deg, #0284c7, #0ea5e9); box-shadow: 0 6px 18px rgba(14,165,233,0.28); }
    button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background: #1b2535; color: #94a3b8; }
    .ghost { background: rgba(255,255,255,0.06); color: #e2e8f0; border: 1px solid #1f2937; }
    .play-btn { background: #111a2b; color: #e2e8f0; border: 1px solid #233143; }
    .play-btn.primary { background: linear-gradient(135deg, #0ea5e9, #14b8a6); color: #0b1220; box-shadow: 0 10px 28px rgba(14,165,233,0.35); }
    .input-with-btn { display: grid; grid-template-columns: 1fr auto; gap: 6px; }
    .picker-btn { width: 42px; padding: 10px 0; border-radius: 10px; border: 1px solid #233143; background: #111a2b; color: #e2e8f0; font-weight: 700; }
    .picker-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .preset-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .preset-btn { padding: 8px 10px; border-radius: 10px; background: #111a2b; border: 1px solid #233143; color: #e2e8f0; font-weight: 600; cursor: pointer; }
    .preset-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .status-line { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .status-item { background: #0b1324; border: 1px solid #1f2937; border-radius: 10px; padding: 8px 10px; color: #e5e7eb; font-weight: 600; min-width: 120px; }
    .status-item span { color: #94a3b8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; display: block; }
    .status-value { font-weight: 700; color: #e5e7eb; padding: 0; line-height: 20px; }
    .status-ok { color: #34d399; }
    .status-warn { color: #fbbf24; }
    .status-err { color: #f87171; }
    .badge-done { background: rgba(16,185,129,0.12); border: 1px solid rgba(16,185,129,0.35); color: #34d399; border-radius: 8px; padding: 4px 8px; display: inline-block; font-weight: 700; }
    .error-text { color: #f87171; min-height: 18px; font-size: 13px; }
    .muted { color: #94a3b8; font-size: 12px; }
    .timeline { display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; }
    .timeline input[type="range"] { width: 100%; accent-color: #22d3ee; }
    .timeline-label { font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #cbd5e1; }
    .player { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
    .toggle { display: flex; align-items: center; gap: 6px; color: #cbd5e1; font-size: 13px; }
    .log { background: #0b1324; border: 1px solid #1f2937; border-radius: 12px; padding: 12px; max-height: 280px; overflow: auto; font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #e2e8f0; }
    .log-entry { padding: 7px 8px; border-radius: 8px; margin-bottom: 6px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.03); }
    .log-entry.ok { border-color: rgba(16,185,129,0.4); }
    .log-entry.err { border-color: rgba(248,113,113,0.45); }
    .log-entry .ts { color: #9ca3af; font-size: 11px; margin-bottom: 2px; }
    dialog { border: 1px solid #1f2937; background: #0f172a; color: #e2e8f0; border-radius: 12px; padding: 16px; min-width: 320px; box-shadow: 0 20px 60px rgba(0,0,0,0.55); }
    dialog::backdrop { background: rgba(0,0,0,0.55); }
    .dlg-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
    .tabs { display: flex; gap: 10px; margin: 16px 0 4px; }
    .tab { padding: 10px 14px; border-radius: 12px; border: 1px solid #1f2937; background: #0f172a; color: #e2e8f0; font-weight: 700; cursor: pointer; }
    .tab.active { border-color: #22d3ee; box-shadow: 0 8px 24px rgba(34,211,238,0.16); }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .table-wrap { overflow: auto; max-height: 520px; border: 1px solid #1f2937; border-radius: 12px; }
    table { width: 100%; border-collapse: collapse; background: #0f141a; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #1f2937; color: #e5e7eb; }
    th { position: sticky; top: 0; background: #111a24; z-index: 1; }
    tbody tr:nth-child(odd) { background-color: #0e1a2c; }
    tbody tr:nth-child(even) { background-color: #101f35; }
    tbody tr.changed { position: relative; }
    tbody tr.changed td:first-child { position: relative; }
    tbody tr.changed td:first-child::before { content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; background: #1c93d3; opacity: 0.9; }
    td.value { font-family: "JetBrains Mono", ui-monospace, monospace; width: 140px; white-space: nowrap; }
    th.value { width: 140px; }
    .table-meta { color: #94a3b8; font-size: 13px; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: rgba(255,255,255,0.06); border: 1px solid #1f2937; }
    .chart-wrap { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 12px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); min-height: 420px; }
    .chart-box { width: 100%; max-width: 1100px; min-width: 720px; height: 420px; min-height: 420px; margin: 0 auto; position: relative; overflow: hidden; }
    .chart-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .chart-controls input { max-width: 320px; }
    .chart-meta { color: #94a3b8; font-size: 13px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .chart-legend-wrap { max-height: 180px; overflow-y: auto; border: 1px solid #1f2937; border-radius: 10px; margin-top: 8px; }
    .chart-legend-table { width: 100%; border-collapse: collapse; font-size: 13px; color: #e5e7eb; }
    .chart-legend-table th, .chart-legend-table td { padding: 6px 8px; border-bottom: 1px solid #1f2937; }
    .chart-legend-table th:nth-child(2), .chart-legend-table td:nth-child(2) { width: 1%; white-space: nowrap; }
    .chart-legend-table td:nth-child(2) { width: 100%; max-width: 100%; }
    .chart-legend-color { width: 12px; height: 12px; border-radius: 3px; display: inline-block; margin-right: 8px; }
    .chart-color-input { width: 32px; height: 24px; padding: 0; border: none; background: transparent; cursor: pointer; }
    .chart-suggest-wrap { position: relative; }
    .chart-suggest-box { position: absolute; top: 100%; left: 0; right: 0; background: #0f172a; border: 1px solid #1f2937; border-radius: 10px; margin-top: 4px; box-shadow: 0 12px 30px rgba(0,0,0,0.4); max-height: 220px; overflow-y: auto; z-index: 5; display: none; }
    .chart-suggest-item { padding: 8px 10px; cursor: pointer; color: #e5e7eb; }
    .chart-suggest-item:hover { background: rgba(34,211,238,0.08); }
    .chart-suggest-item.active { background: rgba(34,211,238,0.12); }
    .chart-suggestion-highlight { color: #22d3ee; font-weight: 700; }
    datalist { display: none; }
    .input-disabled { opacity: 0.5; pointer-events: none; }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="title">
        <p class="eyebrow">TimeMachine · Player · v2</p>
        <h1>История изменения датчиков</h1>
      </div>
      <div style="display:flex; flex-direction:column; gap:6px; align-items:flex-end; min-width:320px;">
        <div class="status-line" style="justify-content:flex-end;">
          <div class="status-item"><span>Status</span><div id="chipStatus">idle</div></div>
          <div class="status-item"><span>Step</span><div id="statStep">-</div></div>
          <div class="status-item"><span>TS</span><div id="statTs">-</div></div>
          <div class="status-item"><span>Updates</span><div id="statUpdates">-</div></div>
        </div>
        <div class="chips" style="justify-content:flex-end; display:flex; gap:8px; flex-wrap:wrap;">
          <span class="chip warn">polling 1.5s</span>
          <span class="chip">REST /api/v2/*</span>
        </div>
      </div>
    </div>

      <div class="tabs">
        <button class="tab active" data-tab="control">Управление</button>
        <button class="tab" data-tab="table">Датчики</button>
        <button class="tab" data-tab="charts">Графики</button>
      </div>

    <div id="panel-control" class="tab-panel active">
    <div class="card">
      <div class="row wrap">
        <div style="flex:2; min-width: 260px;">
          <label for="from">From</label>
          <div class="input-with-btn">
            <input id="from" type="text" placeholder="2024-06-01T00:00:00Z">
            <button class="picker-btn" data-picker="from" type="button">…</button>
          </div>
        </div>
        <div style="flex:2; min-width: 260px;">
          <label for="to">To</label>
          <div class="input-with-btn">
            <input id="to" type="text" placeholder="2024-06-01T01:00:00Z">
            <button class="picker-btn" data-picker="to" type="button">…</button>
          </div>
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="step">Шаг</label>
          <input id="step" type="text" value="1s">
        </div>
        <div style="flex:1; min-width: 120px;">
          <label for="speed">Скорость</label>
          <input id="speed" type="number" step="0.1" value="1">
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="window">Кэш</label>
          <input id="window" type="text" value="15s">
        </div>
      </div>
      <div class="preset-row" style="margin-top:8px;">
        <span class="muted">Быстрый диапазон:</span>
        <button class="preset-btn" data-preset-min="5" type="button">5м</button>
        <button class="preset-btn" data-preset-min="10" type="button">10м</button>
        <button class="preset-btn" data-preset-min="30" type="button">30м</button>
        <button class="preset-btn" data-preset-min="60" type="button">1ч</button>
        <button class="preset-btn" data-preset-min="180" type="button">3ч</button>
        <button class="preset-btn" id="rangeBtn" type="button">Установить доступный диапазон</button>
      </div>
      <div class="muted" id="startErrors"></div>
    </div>

    <div class="card">
      <div class="timeline">
        <div class="timeline-label" id="fromLabel">from: -</div>
        <input id="timeline" type="range" min="0" max="1000" value="0" disabled>
        <div class="timeline-label" id="toLabel">to: -</div>
      </div>
      <div class="row center" style="justify-content:space-between; margin-top:8px; gap:10px; flex-wrap:wrap; width:100%;">
        <div style="flex:1; display:flex; justify-content:flex-start;">
          <button class="ghost" id="jumpStartBtn" type="button" style="padding:8px 10px;">В начало</button>
        </div>
        <div style="flex:1; display:flex; justify-content:center;">
          <div class="status-item" style="min-width:200px; text-align:center;">
            <div id="currentLabel">-</div>
          </div>
        </div>
        <div style="flex:1; display:flex; justify-content:flex-end;">
          <button class="ghost" id="jumpEndBtn" type="button" style="padding:8px 10px;">В конец</button>
        </div>
      </div>
      <div class="muted" id="errorNote" style="text-align:center; margin-top:6px;"></div>
    </div>

    <div class="card">
      <div class="player">
        <button id="stepBackBtn" class="ghost" aria-label="Шаг назад">⏮</button>
        <button id="playPauseBtn" class="play-btn">▶️ Play</button>
        <button id="stopBtn" class="ghost">■ Stop</button>
        <button id="stepFwdBtn" class="ghost" aria-label="Шаг вперёд">⏭</button>
      </div>
      <div class="row wrap" style="margin-top:10px; gap:12px; align-items:flex-end;">
        <div class="status-item" style="min-width:140px;"><span>Status</span><div id="statusBadge">idle</div></div>
        <div style="flex:1; min-width: 240px;">
          <label for="seekManualTs">Перейти к</label>
          <div class="input-with-btn">
            <input id="seekManualTs" type="text" placeholder="2024-06-01T00:00:10Z">
            <button class="picker-btn" data-picker="seekManualTs" type="button">…</button>
          </div>
        </div>
        <div style="flex:0 0 140px; display:flex; align-items:flex-end;">
          <button id="seekManualBtn" class="ghost" style="width:100%;">Seek</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="row center" style="justify-content:space-between; margin-bottom:8px;">
        <h3 style="margin:0; color:#f8fafc; font-size:16px;">Лог</h3>
        <button class="ghost" id="clearLogBtn" style="padding:6px 10px; font-size:12px;">Очистить</button>
      </div>
      <div class="log" id="log"></div>
    </div>
    </div>

    <div id="panel-table" class="tab-panel">
      <div class="card">
        <div class="row center" style="justify-content:flex-start; gap:12px; flex-wrap:wrap;">
          <input id="tableFilter" type="text" placeholder="Введите имя или текст..." style="max-width:340px; flex:0 0 auto;">
          <span class="table-meta" id="tableMeta" style="min-width:160px;">—</span>
        </div>
        <div class="table-wrap" style="margin-top:12px;">
          <table>
            <thead>
              <tr>
                <th style="width:180px;">Name</th>
                <th class="value">Value</th>
                <th>Text</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div id="panel-charts" class="tab-panel">
      <div class="card">
        <div class="chart-controls">
          <div style="flex:1; min-width:260px;" class="chart-suggest-wrap">
            <label for="chartSensors">Добавить датчик</label>
            <input id="chartSensors" type="text" placeholder="Введите имя или текст..." autocomplete="off">
            <div id="chartSuggestionsBox" class="chart-suggest-box"></div>
          </div>
          <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap;">
            <button id="chartClearBtn" class="ghost" type="button">Очистить</button>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartAutoUpdate" type="checkbox" checked style="width:auto; margin:0;">
              Автообновление
            </label>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartFill" type="checkbox" checked style="width:auto; margin:0;">
              Фон
            </label>
          </div>
          <div class="chart-meta" id="chartMeta">Нет данных</div>
        </div>
        <div class="chart-wrap">
          <div class="chart-box">
            <canvas id="chartCanvas" style="width:100%; height:100%;"></canvas>
          </div>
          <div id="chartEmpty" class="muted" style="text-align:center; margin-top:8px;">Нет данных для отображения</div>
          <div class="chart-legend-wrap">
            <table class="chart-legend-table" id="chartLegendTable">
              <thead><tr><th>Датчик</th><th>Текущее значение</th><th>Время</th><th></th></tr></thead>
              <tbody id="chartLegendBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <dialog id="datetimeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 6px;">Выбор даты/времени</h3>
      <p class="muted" style="margin:0 0 10px;">Локальное время → сохраняем как RFC3339 с Z.</p>
      <input id="dtInput" type="datetime-local" step="1" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0;">
      <div class="dlg-actions">
        <button type="submit" value="cancel" class="ghost">Отмена</button>
        <button type="submit" value="ok">Применить</button>
      </div>
    </form>
  </dialog>

  <script src="/ui/chart.umd.min.js"></script>
  <script src="/ui/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="/ui/chartjs-plugin-zoom.min.js"></script>
  <script>
  const logUIEnabled = false;
    const logUI = (msg) => {
      if (logUIEnabled) console.info(`[UI LOG] ${msg}`);
    };
    const chartLogEnabled = true;
    const chartLog = (msg, payload) => {
      if (!chartLogEnabled) return;
      if (payload !== undefined) {
        console.info(`[chart] ${msg}`, payload);
      } else {
        console.info(`[chart] ${msg}`);
      }
    };
    const els = {
      inputs: {
        from: document.getElementById('from'),
        to: document.getElementById('to'),
        step: document.getElementById('step'),
        speed: document.getElementById('speed'),
        window: document.getElementById('window'),
      },
      tabs: document.querySelectorAll('[data-tab]'),
      panels: {
        control: document.getElementById('panel-control'),
        table: document.getElementById('panel-table'),
        charts: document.getElementById('panel-charts'),
      },
      startErrors: document.getElementById('startErrors'),
      chipStatus: document.getElementById('chipStatus'),
      status: {
        badge: document.getElementById('statusBadge'),
        error: document.getElementById('errorNote'),
        step: document.getElementById('statStep'),
        ts: document.getElementById('statTs'),
        updates: document.getElementById('statUpdates'),
      },
      timeline: document.getElementById('timeline'),
      fromLabel: document.getElementById('fromLabel'),
      toLabel: document.getElementById('toLabel'),
      currentLabel: document.getElementById('currentLabel'),
      controls: {
        stepBack: document.getElementById('stepBackBtn'),
        playPause: document.getElementById('playPauseBtn'),
        stop: document.getElementById('stopBtn'),
        stepFwd: document.getElementById('stepFwdBtn'),
        seekManual: document.getElementById('seekManualBtn'),
        jumpStart: document.getElementById('jumpStartBtn'),
        jumpEnd: document.getElementById('jumpEndBtn'),
      },
      log: document.getElementById('log'),
      clearLog: document.getElementById('clearLogBtn'),
      snapTs: document.getElementById('snapTs'),
      seekManualTs: document.getElementById('seekManualTs'),
      dialog: document.getElementById('datetimeDialog'),
      dialogInput: document.getElementById('dtInput'),
      table: {
        body: document.getElementById('tableBody'),
        filter: document.getElementById('tableFilter'),
        meta: document.getElementById('tableMeta'),
      },
      charts: {
        sensors: document.getElementById('chartSensors'),
        clear: document.getElementById('chartClearBtn'),
        meta: document.getElementById('chartMeta'),
        empty: document.getElementById('chartEmpty'),
        suggestions: document.getElementById('chartSensorsSuggestions'),
        suggestBox: document.getElementById('chartSuggestionsBox'),
        canvas: document.getElementById('chartCanvas'),
        legendBody: document.getElementById('chartLegendBody'),
        fill: document.getElementById('chartFill'),
        autoUpdate: document.getElementById('chartAutoUpdate'),
      },
      rangeBtn: document.getElementById('rangeBtn'),
    };
    const inputs = els.inputs;

    const state = {
      model: { status: 'idle' },
      pollingMs: 1500,
      pollErrorNotified: false,
      ws: null,
      reconnectIn: null,
      previewTs: null,
      lastParamsSig: '',
      pausedAtTs: null,
    };

    const tableState = {
      rows: new Map(),
      meta: new Map(),
      filter: '',
      lastStep: '-',
      lastTs: '-',
    };
    const chartState = {
      selected: [],
      datasets: new Map(), // id -> {label,color,data: [{x,y}], lastValue}
      chart: null,
      maxPoints: 800,
      autoUpdate: true,
      windowSec: 300,
      lastParamsSig: '',
      lastSkip: '',
      range: { from: null, to: null },
      suggest: { items: [], active: -1 },
    };
    const sensorIndex = {
      byId: new Map(),    // id -> {id,name,textname}
      byName: new Map(),  // lower(name) -> id
      hydrated: false,
    };

    function log(message, ok = true) {
      const row = document.createElement('div');
      row.className = `log-entry ${ok ? 'ok' : 'err'}`;
      row.innerHTML = `<div class="ts">${new Date().toLocaleTimeString()}</div><div>${message}</div>`;
      els.log.prepend(row);
      while (els.log.children.length > 200) {
        els.log.removeChild(els.log.lastChild);
      }
    }

    function setTab(tab) {
      els.tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
      Object.entries(els.panels).forEach(([name, node]) => {
        if (!node) return;
        node.classList.toggle('active', name === tab);
      });
      if (tab === 'charts') {
        preloadSensors();
        setTimeout(() => rebuildChart(true), 0);
      }
    }

    function connectWS() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const host = location.host || 'localhost:8080';
      const url = `${proto}://${host}/api/v1/ws/state`;
      try {
        const ws = new WebSocket(url);
        state.ws = ws;
        ws.onopen = () => log('WS: connected');
        ws.onclose = () => {
          state.ws = null;
          if (state.reconnectIn) clearTimeout(state.reconnectIn);
          state.reconnectIn = setTimeout(connectWS, 2000);
        };
        ws.onerror = () => ws.close();
        ws.onmessage = (ev) => {
          try {
            const msg = JSON.parse(ev.data);
            handleWSMessage(msg);
          } catch (err) {
            log(`WS parse: ${err.message}`, false);
            fetchSnapshotFallback();
            ws.close();
          }
        };
      } catch (err) {
        log(`WS connect: ${err.message}`, false);
      }
    }

    function unixToISO(v) {
      if (!Number.isFinite(v) || v <= 0) return '';
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function handleWSMessage(msg) {
      if (!msg || typeof msg !== 'object') return;
      const tsStr = msg.step_ts || unixToISO(msg.step_unix);
      if (msg.step_id !== undefined) {
        tableState.lastStep = msg.step_id || 0;
      }
      if (tsStr) {
        tableState.lastTs = tsStr;
        state.pausedAtTs = tsStr;
      }
      switch (msg.type) {
        case 'reset':
          tableState.rows.clear();
          tableState.meta.clear();
          renderTable(true);
          break;
        case 'snapshot':
          applySnapshot(msg.updates || [], tsStr);
          appendChartPoint(tsStr, msg.updates || []);
          break;
        case 'updates':
          applyTableUpdates(msg.updates || [], tsStr);
          appendChartPoint(tsStr, msg.updates || []);
          break;
        default:
          break;
      }
      renderTable();
    }

    function applySnapshot(list, tsStr) {
      if (!Array.isArray(list)) return;
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        registerSensorMeta(key, item.name, item.textname);
        const hasValue = !!item.has_value || !!item.hasValue;
        if (hasValue) {
          tableState.rows.set(key, {
            id: key,
            name: item.name || `id${key}`,
            textname: item.textname || '',
            value: item.value,
            hasValue: true,
            stepID: tableState.lastStep || 0,
            ts: tsStr || '',
          });
        }
      });
      refreshChartSuggestions();
    }

    function applyTableUpdates(list, tsStr) {
      if (!Array.isArray(list)) return;
      const now = Date.now();
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        const prev = tableState.rows.get(key) || {};
        const hadValue = prev.hasValue;
        const changed = !hadValue || prev.value !== item.value;
        const meta = tableState.meta.get(key) || {};
        const name = item.name || meta.name || prev.name || `id${key}`;
        registerSensorMeta(key, name, item.textname || meta.textname || prev.textname);
        tableState.rows.set(key, {
          id: key,
          name,
          textname: item.textname || meta.textname || prev.textname || '',
          value: item.value,
          hasValue: !!item.has_value || item.hasValue || hadValue,
          stepID: item.step_id || tableState.lastStep || prev.stepID || 0,
          ts: tsStr || tableState.lastTs || prev.ts || '',
          changedAt: changed ? now : prev.changedAt,
        });
      });
      refreshChartSuggestions();
    }

    function renderTable(force) {
      if (!els.table.body) return;
      const filter = (tableState.filter || '').trim();
      const useMeta = !!filter;
      const baseRows = useMeta
        ? Array.from(tableState.meta.entries()).map(([id, meta]) => {
            const row = tableState.rows.get(id) || {};
            const hasValue = !!row.hasValue;
            return {
              id,
              name: meta.name || `id${id}`,
              textname: meta.textname || '',
              value: hasValue ? row.value : '—',
              hasValue,
              stepID: row.stepID,
              ts: row.ts,
              changedAt: row.changedAt,
            };
          })
        : Array.from(tableState.rows.values());
      const filtered = filter
        ? baseRows.filter(r => {
            const name = (r.name || '').toLowerCase();
            const textname = (r.textname || '').toLowerCase();
            return name.includes(filter) || textname.includes(filter);
          })
        : baseRows;
      filtered.sort((a, b) => {
        if (a.name === b.name) return a.id - b.id;
        return a.name.localeCompare(b.name);
      });
      const now = Date.now();
      const html = filtered.map(r => {
        const isChanged = r.changedAt && now - r.changedAt < 4000;
        const value = r.hasValue ? r.value : '—';
        return `<tr class="${isChanged ? 'changed' : ''}"><td>${r.name || ''}</td><td class="value">${value}</td><td>${r.textname || ''}</td></tr>`;
      }).join('');
      els.table.body.innerHTML = html || `<tr><td colspan="3" style="text-align:center; color:#94a3b8; padding:16px;">Нет данных</td></tr>`;
      if (els.table.meta) {
        const ts = tableState.lastTs || '—';
        els.table.meta.textContent = `Step: ${tableState.lastStep || '—'} · ${ts}`;
      }
      if (els.table.filter) {
        setDisabled(els.table.filter, tableState.meta.size === 0);
      }
    }

    const chartColors = ['#22d3ee', '#34d399', '#f59e0b', '#f472b6', '#a78bfa', '#f87171', '#4ade80', '#60a5fa'];

    function pickChartColor(id, usedColors, idxHint) {
      const used = usedColors || new Set();
      for (let i = 0; i < chartColors.length; i++) {
        const color = chartColors[(idxHint + i) % chartColors.length];
        if (!used.has(color.toLowerCase())) return color;
      }
      const hue = (Number(id) * 37 + (idxHint || 0) * 53) % 360;
      const color = `hsl(${hue}, 68%, 58%)`;
      if (!used.has(color.toLowerCase())) return color;
      const alt = `hsl(${(hue + 27) % 360}, 68%, 58%)`;
      return alt;
    }

    function chartLabelByID(id) {
      const meta = tableState.meta.get(id) || sensorIndex.byId.get(id) || {};
      if (meta.name) return `${meta.name} (${id})`;
      return `id${id}`;
    }

    function registerSensorMeta(id, name, textname) {
      if (!Number.isFinite(id)) return;
      const prev = tableState.meta.get(id) || {};
      const resolvedName = name || prev.name || `id${id}`;
      const resolvedText = textname !== undefined ? textname : prev.textname;
      tableState.meta.set(id, { name: resolvedName, textname: resolvedText || '' });
      sensorIndex.byId.set(id, { id, name: resolvedName, textname: resolvedText || '' });
      sensorIndex.byName.set(String(resolvedName).toLowerCase(), id);
    }

    function knownSensorIdByToken(token) {
      if (!token) return null;
      const num = Number(token);
      if (Number.isFinite(num) && sensorIndex.byId.has(num)) {
        return num;
      }
      const byName = sensorIndex.byName.get(token.toLowerCase());
      return Number.isFinite(byName) ? byName : null;
    }

    function parseChartSensors(input) {
      if (!input) return [];
      const tokens = input.split(',').map(t => t.trim()).filter(Boolean);
      if (!tokens.length) return [];
      const out = [];
      tokens.forEach(tok => {
        const id = knownSensorIdByToken(tok);
        if (Number.isFinite(id)) out.push(id);
      });
      return Array.from(new Set(out));
    }

    function normalizeSensorList(list) {
      if (!Array.isArray(list)) return [];
      const res = [];
      list.forEach((id) => {
        const num = Number(id);
        if (!Number.isFinite(num)) return;
        if (!sensorIndex.byId.has(num)) {
          registerSensorMeta(num, `id${num}`, '');
        }
        if (sensorIndex.byId.has(num)) res.push(num);
      });
      return Array.from(new Set(res));
    }

    function rebuildChartSeries() {
      const prev = chartState.datasets;
      const next = new Map();
      const used = new Set();
      chartState.selected.forEach((id, idx) => {
        const existing = prev.get(id);
        const preserved = existing?.color;
        const color = preserved || pickChartColor(id, used, idx);
        used.add(color.toLowerCase());
        const data = existing?.data ? existing.data.slice() : [];
        const lastValue = existing?.lastValue ?? null;
        const lastTs = existing?.lastTs ?? null;
        next.set(id, {
          label: chartLabelByID(id),
          color,
          data,
          lastValue,
          lastTs,
        });
      });
      chartState.datasets = next;
      if (chartState.chart) {
        syncChartData();
      } else {
        rebuildChart();
      }
    }

    function updateChartMeta(msg) {
      if (!els.charts.meta) return;
      const sensors = chartState.selected.length ? chartState.selected.map(chartLabelByID).join(', ') : '—';
      const points = chartState.chart
        ? (chartState.chart.data.labels?.length || 0)
        : Array.from(chartState.datasets.values()).reduce((acc, ds) => Math.max(acc, ds.data?.length || 0), 0);
      let metaText = chartState.selected.length ? `Точек: ${points}` : 'Нет данных';
      if (chartState.range.from && chartState.range.to) {
        const from = new Date(chartState.range.from).toISOString().replace(/\.\d{3}Z$/, 'Z');
        const to = new Date(chartState.range.to).toISOString().replace(/\.\d{3}Z$/, 'Z');
        metaText += ` · X: ${from} → ${to}`;
      }
      els.charts.meta.textContent = metaText;
      if (msg) {
        els.charts.meta.textContent += ` · ${msg}`;
      }
      if (els.charts.empty) {
        const showEmpty = !chartState.selected.length || points === 0;
        els.charts.empty.style.display = showEmpty ? 'flex' : 'none';
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.checked = chartState.autoUpdate;
      }
      if (els.charts.window) {
        els.charts.window.value = chartState.windowSec;
      }
    }

    function renderLegendTable() {
      if (!els.charts.legendBody) return;
      try {
        const rows = chartState.selected.map((id) => {
          const ds = chartState.datasets.get(id) || {};
          const val = ds.lastValue;
          const color = ds.color || '#22d3ee';
          const ts = ds.lastTs ? toRFC3339(new Date(ds.lastTs)) : '—';
          return `<tr><td><input class="chart-color-input" type="color" value="${color}" data-sensor="${id}">${chartLabelByID(id)}</td><td>${val ?? '—'}</td><td>${ts}</td><td><button class="ghost chart-remove-btn" data-sensor="${id}" type="button" style="padding:6px 10px;">✕</button></td></tr>`;
        }).join('');
        els.charts.legendBody.innerHTML = rows || '<tr><td colspan="4" style="color:#94a3b8;">Нет выбранных датчиков</td></tr>';
      } catch (err) {
        els.charts.legendBody.innerHTML = `<tr><td colspan="4" style="color:#f87171;">${err?.message || err}</td></tr>`;
      }
    }

    function refreshChartSuggestions() {
      const opts = [];
      const usedValues = new Set();
      sensorIndex.byId.forEach((meta, id) => {
        if (chartState.selected.includes(id)) return; // уже на графике
        const label = meta?.name ? `${meta.name}` : `id${id}`;
        const val = meta?.name || `id${id}`;
        if (!val || usedValues.has(val)) return;
        usedValues.add(val);
        opts.push({ value: val, label: `${label} (${id})` });
      });
      renderChartSuggestions(els.charts.sensors?.value || '');
      updateChartInputState();
    }

    function renderChartSuggestions(query) {
      if (!els.charts.suggestBox) return;
      const q = (query || '').trim().toLowerCase();
      const items = [];
      let availableCount = 0;
      sensorIndex.byId.forEach((meta, id) => {
        if (chartState.selected.includes(id)) return;
        const name = meta?.name || `id${id}`;
        const text = name.toLowerCase();
        if (q && !text.includes(q) && !String(id).includes(q)) return;
        items.push({ id, name });
        availableCount++;
      });
      items.sort((a, b) => a.name.localeCompare(b.name));
      const limited = items.slice(0, 50);
      if (!limited.length || q.length === 0) {
        els.charts.suggestBox.style.display = 'none';
        els.charts.suggestBox.innerHTML = '';
        updateChartInputState(availableCount);
        return;
      }
      chartState.suggest.items = limited;
      chartState.suggest.active = limited.length ? 0 : -1;
      const highlight = (str) => {
        if (!q) return str;
        const idx = str.toLowerCase().indexOf(q);
        if (idx === -1) return str;
        const before = str.slice(0, idx);
        const match = str.slice(idx, idx + q.length);
        const after = str.slice(idx + q.length);
        return `${before}<span class="chart-suggestion-highlight">${match}</span>${after}`;
      };
      els.charts.suggestBox.innerHTML = limited.map((item, idx) => {
        const activeClass = idx === chartState.suggest.active ? 'active' : '';
        return `<div class="chart-suggest-item ${activeClass}" data-sensor="${item.id}">${highlight(item.name)} <span style="color:#94a3b8;">(${item.id})</span></div>`;
      }).join('');
      els.charts.suggestBox.style.display = 'block';
      updateChartInputState(availableCount);
    }

    function hideChartSuggestions() {
      if (!els.charts.suggestBox) return;
      els.charts.suggestBox.style.display = 'none';
      els.charts.suggestBox.innerHTML = '';
      chartState.suggest = { items: [], active: -1 };
    }

    function moveSuggestActive(delta) {
      const items = chartState.suggest.items || [];
      if (!items.length || !els.charts.suggestBox) return;
      const next = (chartState.suggest.active + delta + items.length) % items.length;
      chartState.suggest.active = next;
      Array.from(els.charts.suggestBox.children).forEach((el, idx) => {
        el.classList.toggle('active', idx === next);
      });
    }

    function buildChartDatasets() {
      return Array.from(chartState.datasets.values()).map(ds => ({
        label: ds.label,
        data: ds.data,
        borderColor: ds.color || '#22d3ee',
        backgroundColor: els.charts.fill?.checked ? hexToRGBA(ds.color || '#22d3ee', 0.15) : ds.color || '#22d3ee',
        tension: 0.08,
        spanGaps: true,
        pointRadius: 0,
        borderWidth: 1,
        fill: !!(els.charts.fill && els.charts.fill.checked),
      }));
    }

    function hexToRGBA(hex, alpha) {
      if (!hex) return hex;
      const h = hex.replace('#', '');
      const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateChartInputState(availableCount) {
      if (!els.charts.sensors) return;
      const totalAvailable = availableCount !== undefined ? availableCount : sensorIndex.byId.size - chartState.selected.length;
      const disable = totalAvailable <= 0;
      els.charts.sensors.disabled = disable;
      if (els.charts.sensors.parentElement) {
        els.charts.sensors.parentElement.classList.toggle('input-disabled', disable);
      }
      if (disable) hideChartSuggestions();
    }

    function syncChartData() {
      if (!chartState.chart) return;
      chartState.chart.data.labels = extractChartLabels();
      chartState.chart.data.datasets = buildChartDatasets();
      const hasRange = chartState.range.from && chartState.range.to;
      chartState.chart.options.scales.x.min = hasRange ? chartState.range.from : undefined;
      chartState.chart.options.scales.x.max = hasRange ? chartState.range.to : undefined;
      chartState.chart.update('none');
      updateChartMeta();
      renderLegendTable();
    }

    function rebuildChart(force = false) {
      if (!els.charts.canvas) return;
      if (!chartState.selected.length) {
        destroyChart();
        updateChartMeta();
        renderLegendTable();
        return;
      }
      const hasRange = chartState.range.from && chartState.range.to;
      const panelVisible = els.panels?.charts?.classList.contains('active');
      const container = els.charts.canvas.parentElement || els.charts.canvas;
      const rawW = container.clientWidth || container.offsetWidth || 0;
      const rawH = container.clientHeight || container.offsetHeight || 0;
      const width = Math.max(320, Math.floor(rawW || 800));
      const height = Math.max(300, Math.floor(rawH || 420));
      if (!panelVisible && !force) {
        const reason = `hidden:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: panel hidden', { panelVisible, width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        const reason = `invalid:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: invalid size', { width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      destroyChart();
      chartState.lastSkip = '';
      if (!window.Chart) {
        console.error('[chart] Chart.js not loaded');
        return;
      }
      const ctx = els.charts.canvas.getContext('2d');
      els.charts.canvas.width = width;
      els.charts.canvas.height = height;
      const labels = extractChartLabels();
      const datasets = buildChartDatasets();
      chartState.chart = new Chart(ctx, {
        type: 'line',
        data: {labels, datasets},
        options: {
          animation: false,
          responsive: false,
          maintainAspectRatio: false,
          parsing: false,
          resizeDelay: 0,
          scales: {
            x: {
              type: 'time',
              time: {unit: 'second'},
              min: hasRange ? chartState.range.from : undefined,
              max: hasRange ? chartState.range.to : undefined,
              ticks: {color: '#94a3b8'},
              grid: {color: 'rgba(255,255,255,0.05)'},
            },
            y: {
              ticks: {color: '#94a3b8'},
              grid: {
                color: (ctx) => {
                  if (ctx.tick && ctx.tick.value === 0) return '#ffffff';
                  return 'rgba(255,255,255,0.05)';
                },
                borderColor: 'rgba(255,255,255,0.08)',
              },
            },
          },
          plugins: {
            legend: {display: false},
            tooltip: {
              mode: 'nearest',
              intersect: false,
              callbacks: {
                title: (items) => items.length ? new Date(items[0].parsed.x).toISOString() : '',
                label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y ?? '—'}`,
              },
            },
            zoom: {
              zoom: {wheel: {enabled: false}, pinch: {enabled: false}, mode: 'x'},
              pan: {enabled: false},
            },
          },
          interaction: {mode: 'nearest', intersect: false},
        },
      });
      chartLog('rebuild chart', { width, height, datasets: chartState.datasets.size });
      updateChartMeta();
      renderLegendTable();
    }

    function destroyChart() {
      const existing = (window.Chart && typeof Chart.getChart === 'function') ? Chart.getChart(els.charts.canvas) : null;
      if (existing) existing.destroy();
      if (chartState.chart) {
        chartState.chart.destroy();
        chartState.chart = null;
      }
    }

    function extractChartLabels() {
      const labels = new Set();
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => labels.add(p.x));
      });
      return Array.from(labels).sort((a, b) => a - b);
    }

    function resetChartZoom() {
    }

    function autoZoomY() {
      if (!chartState.chart) return;
      let minY = Infinity;
      let maxY = -Infinity;
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => {
          if (p.y == null) return;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        });
      });
      if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
        minY = 0; maxY = 1;
      }
      chartState.chart.options.scales.y.min = minY;
      chartState.chart.options.scales.y.max = maxY;
      chartState.chart.update('none');
      updateChartMeta();
    }

    function trimDataset(ds, currentTs) {
      // Если известен диапазон from/to — отбрасываем всё, что за его пределами.
      if (chartState.range.from && chartState.range.to) {
        ds.data = ds.data.filter(p => p.x >= chartState.range.from && p.x <= chartState.range.to);
        return;
      }
      if (!chartState.windowSec || chartState.windowSec <= 0) return;
      const threshold = currentTs - chartState.windowSec * 1000;
      ds.data = ds.data.filter(p => p.x >= threshold);
    }

    function appendChartPoint(tsStr, updates) {
      if (!chartState.selected.length || !tsStr) return;
      if (!chartState.autoUpdate) return;
      if (els.charts.autoUpdate && !els.charts.autoUpdate.checked) return;
      const d = parseISO(tsStr);
      if (!d) return;
      const t = d.getTime();
      const hasFixedRange = chartState.range.from && chartState.range.to;
      if (hasFixedRange && (t < chartState.range.from || t > chartState.range.to)) {
        // За пределами выбранного диапазона отбрасываем.
        return;
      }
      const updateMap = new Map();
      (updates || []).forEach(item => {
        const id = Number(item.id);
        if (Number.isFinite(id)) updateMap.set(id, item.value);
      });
      const usedColors = new Set();
      chartState.datasets.forEach(ds => {
        if (ds.color) usedColors.add(String(ds.color).toLowerCase());
      });
      chartState.selected.forEach((id, idx) => {
        if (!chartState.datasets.has(id)) {
          const color = pickChartColor(id, usedColors, idx);
          chartState.datasets.set(id, {
            label: chartLabelByID(id),
            color,
            data: [],
            lastValue: null,
            lastTs: null,
          });
          usedColors.add(String(color).toLowerCase());
        }
        const ds = chartState.datasets.get(id);
        const val = updateMap.has(id) ? updateMap.get(id) : ds.lastValue;
        const y = val === undefined ? null : val;
        ds.lastValue = y;
        ds.lastTs = t;
        ds.data.push({x: t, y});
        if (ds.data.length > chartState.maxPoints) ds.data.shift();
        trimDataset(ds, t);
      });
      if (chartState.chart) {
        syncChartData();
      } else {
        rebuildChart();
      }
    }

    function applyChartSensors(list) {
      const normalized = normalizeSensorList(list || []);
      chartState.selected = normalized;
      if (els.charts.sensors) {
        els.charts.sensors.value = '';
      }
      rebuildChartSeries();
      hideChartSuggestions();
    }

    function clearChart() {
      chartState.datasets.forEach((ds) => {
        ds.data = [];
        ds.lastValue = null;
        ds.lastTs = null;
      });
      if (chartState.chart) {
        syncChartData();
      } else {
        rebuildChart();
      }
      if (els.charts.sensors) els.charts.sensors.value = '';
    }

    function addSensorsFromInput() {
      const raw = els.charts.sensors?.value || '';
      const ids = parseChartSensors(raw);
      const filtered = ids.filter(id => !chartState.selected.includes(id));
      if (!filtered.length) {
        log('Датчики не найдены в подсказках/конфиге или уже добавлены', false);
        return;
      }
      const merged = Array.from(new Set([...chartState.selected, ...filtered]));
      applyChartSensors(merged);
      hideChartSuggestions();
    }

    function hydrateChartDefaultsFromParams() {
      if (chartState.selected.length) return;
      const params = state.model.params || state.model.Params || {};
      const sensors = params.Sensors || params.sensors;
      if (Array.isArray(sensors) && sensors.length) {
        applyChartSensors(sensors);
      }
    }

    function paramsSignature(params) {
      if (!params) return '';
      const sensors = params.Sensors || params.sensors || [];
      const from = params.From || params.from;
      const to = params.To || params.to;
      return JSON.stringify({sensors, from, to});
    }

    function syncChartWithParams(params) {
      const sig = paramsSignature(params);
      if (sig && sig !== chartState.lastParamsSig) {
        chartState.lastParamsSig = sig;
        const sensors = params?.Sensors || params?.sensors;
        if (Array.isArray(sensors) && sensors.length) {
          applyChartSensors(sensors);
        } else {
          clearChart();
        }
      }
    }

    function requestJSON(method, url, body) {
      logUI(`fetch ${method} ${url} body=${body ? JSON.stringify(body) : ''}`);
      const init = { method, headers: {} };
      if (body !== undefined) {
        init.headers['Content-Type'] = 'application/json';
        init.body = JSON.stringify(body);
      }
      return fetch(url, init).then(async (resp) => {
        const text = await resp.text();
        let payload = null;
        if (text) { try { payload = JSON.parse(text); } catch (_) {} }
        logUI(`fetch result ${resp.status} ${resp.statusText} payload=${text || '<empty>'}`);
        if (!resp.ok) {
          throw new Error(payload?.error || text || `HTTP ${resp.status}`);
        }
        return payload;
      });
    }

    function mergeSensorsFromAPI(list) {
      if (!Array.isArray(list)) return;
      list.forEach((item) => {
        const id = Number(item.id);
        if (!Number.isFinite(id)) return;
        registerSensorMeta(id, item.name, item.textname);
      });
      refreshChartSuggestions();
    }

    async function fetchSnapshotFallback() {
      try {
        const tsDate = currentTsFromServer();
        const ts = tsDate ? toRFC3339(tsDate) : '';
        if (!ts) return;
        const data = await requestJSON('POST', '/api/v1/snapshot', { ts });
        const updates = data?.updates || data?.Updates || [];
        const stepTs = data?.step_ts || data?.StepTS || '';
        applySnapshot(updates, stepTs);
        renderTable(true);
      } catch (err) {
        log(`Snapshot fallback: ${err.message}`, false);
      }
    }

    async function preloadSensors() {
      if (sensorIndex.hydrated) return;
      try {
        const data = await requestJSON('GET', '/api/v2/sensors');
        const list = data?.sensors || [];
        mergeSensorsFromAPI(list);
        sensorIndex.hydrated = list.length > 0;
        renderChartSuggestions(els.charts.sensors?.value || '');
      } catch (err) {
        logUI(`[chart] preload sensors failed: ${err.message}`);
      }
    }

    function statusNormalize(s) {
      return String(s || 'idle').toLowerCase();
    }

    function parseISO(v) {
      const d = new Date(v);
      return Number.isNaN(d.getTime()) ? null : d;
    }

    function getRange(params) {
      const from = parseISO(params.From || params.from);
      const to = parseISO(params.To || params.to);
      return { from, to, valid: !!from && !!to && to > from };
    }

    function getEffectiveRange(params, pending) {
      const r1 = getRange(params || {});
      if (r1.valid) return r1;
      const pendingRange = pending?.range || pending?.Range || {};
      const r2 = getRange(pendingRange);
      if (pending?.range_set || pending?.RangeSet) {
        return r2;
      }
      return r2.valid ? r2 : { from: null, to: null, valid: false };
    }

    function syncChartRange(params, pending) {
      const range = getEffectiveRange(params, pending);
      if (!range.valid) {
        chartState.range = { from: null, to: null };
        return;
      }
      const fromMs = range.from.getTime();
      const toMs = range.to.getTime();
      const prevFrom = chartState.range.from;
      const prevTo = chartState.range.to;
      chartState.range = { from: fromMs, to: toMs };
      if (prevFrom !== fromMs || prevTo !== toMs) {
        // Перебираем датасеты и удаляем точки за пределами нового диапазона.
        chartState.datasets.forEach(ds => {
          ds.data = ds.data.filter(p => p.x >= fromMs && p.x <= toMs);
        });
        if (chartState.chart) {
          syncChartData();
        } else {
          rebuildChart(true);
        }
      }
    }

    function currentTsFromServer() {
      const st = statusNormalize(state.model.status);
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const params = state.model.params || state.model.Params || {};
      const range = getEffectiveRange(params, pending);
      const lastTs = parseISO(state.model.last_ts || state.model.LastTS);
      const pendingTs = pendingSeek ? parseISO(pendingSeek) : null;
      // Во всех нерunning состояниях приоритет у pending seek (например, после stop/done).
      if (st !== 'running' && st !== 'stopping' && pendingTs && !Number.isNaN(pendingTs.getTime()) && pendingTs.getFullYear() > 1) {
        return pendingTs;
      }
      // В активных состояниях используем последний ts от сервера, если валиден.
      if (lastTs && !Number.isNaN(lastTs.getTime()) && lastTs.getFullYear() > 1) {
        return lastTs;
      }
      if ((st === 'idle' || st === 'pending') && pendingTs) {
        return pendingTs;
      }
      if ((st === 'idle' || st === 'pending') && range.valid) {
        return range.from;
      }
      if (pendingTs) {
        return pendingTs;
      }
      if (range.valid) {
        return range.from;
      }
      return null;
    }

    function updateStatusView() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const curTs = currentTsFromServer();
      const stepID = state.model.step_id ?? state.model.StepID ?? '-';
      const lastTsText = curTs ? toRFC3339(curTs) : (state.model.last_ts ?? state.model.LastTS ?? '-');
      const updates = state.model.updates_sent ?? state.model.UpdatesSent ?? '-';
      els.status.badge.textContent = st;
      els.chipStatus.textContent = st;
      els.status.step.textContent = stepID;
      els.status.ts.textContent = lastTsText;
      els.status.updates.textContent = updates;
      els.status.error.textContent = state.model.error ? `Ошибка: ${state.model.error}` : '';
      els.chipStatus.className = 'status-value';
      if (st === 'running') els.chipStatus.classList.add('status-ok');
      if (st === 'paused' || st === 'pending') els.chipStatus.classList.add('status-warn');
      if (st === 'failed') els.chipStatus.classList.add('status-err');
      els.status.badge.classList.toggle('badge-done', st === 'done');
      if (pendingSeek && (st === 'pending' || st === 'idle')) {
        els.status.ts.textContent = pendingSeek;
      }
      syncChartRange(params, pending);
      updateTimeline();
      updateControls();
      logIndicators(st);
      toggleChartAutoUpdate(st);
      updateChartMeta();
    }

    function toggleChartAutoUpdate(status) {
      if (!els.charts.autoUpdate) return;
      const shouldRun = status === 'running' || status === 'stopping';
      chartState.autoUpdate = shouldRun;
      els.charts.autoUpdate.checked = shouldRun;
    }

    function logIndicators(status) {
      const step = state.model.step_id || state.model.StepID || '-';
      const ts = state.model.last_ts || state.model.LastTS || '-';
      const updates = state.model.updates_sent || state.model.UpdatesSent || '-';
      const pending = state.model.pending || state.model.Pending || {};
      logUI(`indicators status=${status} step=${step} ts=${ts} updates=${updates} pendingRange=${pending.range_set || pending.RangeSet ? 'yes' : 'no'}`);
    }

    function updateTimeline() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const slider = els.timeline;
      if (!range.valid) {
        slider.disabled = true;
        slider.value = 0;
        els.fromLabel.textContent = 'from: -';
        els.toLabel.textContent = 'to: -';
        els.currentLabel.textContent = '-';
        return;
      }
      els.fromLabel.textContent = `from: ${range.from.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      els.toLabel.textContent = `to: ${range.to.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      slider.disabled = false;
      const rangeMs = range.to - range.from;
      let pos = 0;
      const st = statusNormalize(state.model.status);
      let curTs = currentTsFromServer();
      if (state.previewTs && st !== 'running' && st !== 'stopping') {
        curTs = state.previewTs;
      }
      if (curTs) {
        pos = Math.max(0, Math.min(1, (curTs - range.from) / rangeMs));
        els.currentLabel.textContent = toRFC3339(curTs);
        logUI(`timeline render ${toRFC3339(curTs)} source=${state.previewTs ? 'preview' : 'server'}`);
      } else {
        els.currentLabel.textContent = pending.seek_ts || pending.SeekTS || toRFC3339(range.from) || '-';
      }
      slider.value = Math.round(pos * 1000);
    }

    function updateControls() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const active = st === 'running' || st === 'paused' || st === 'stopping';
      const paused = st === 'paused';
      const curTs = currentTsFromServer();
      const atStart = !range.valid || !curTs || curTs.getTime() <= range.from.getTime();
      const atEnd = !range.valid || !curTs || curTs.getTime() >= range.to.getTime();

      setDisabled(els.controls.stepBack, st === 'failed' || !range.valid || !paused || atStart);
      setDisabled(els.controls.stepFwd, st === 'failed' || !range.valid || !paused || atEnd);
      setDisabled(els.controls.stop, !active);
      // Play доступна почти всегда; в running подсвечиваем как primary (Pause).
      setDisabled(els.controls.playPause, st === 'failed');
      const playLike = paused || st === 'idle' || st === 'done' || st === 'pending';
      els.controls.playPause.textContent = playLike ? '▶️ Play' : '⏸ Pause';
      els.controls.playPause.classList.toggle('primary', st === 'running');
      // Ползунок доступен при валидном диапазоне (даже до старта), чтобы можно было выбрать точку.
      setDisabled(els.timeline, !range.valid);
      if (els.rangeBtn) {
        setDisabled(els.rangeBtn, active); // не трогаем диапазон во время активной задачи
      }
      if (els.controls.jumpStart) {
        setDisabled(els.controls.jumpStart, !range.valid || st === 'running' || st === 'stopping');
      }
      if (els.controls.jumpEnd) {
        setDisabled(els.controls.jumpEnd, !range.valid || st === 'running' || st === 'stopping');
      }
    }

    function setDisabled(el, disabled) {
      if (!el) return;
      el.disabled = !!disabled;
    }

    function validateStartForm() {
      const errors = [];
      const from = els.inputs.from.value.trim();
      const to = els.inputs.to.value.trim();
      const step = els.inputs.step.value.trim();
      const speedVal = els.inputs.speed.value.trim();
      const windowVal = els.inputs.window.value.trim();
      if (!isValidISO(from)) errors.push('From: RFC3339, например 2024-06-01T00:00:00Z.');
      if (!isValidISO(to)) errors.push('To: RFC3339.');
      if (isValidISO(from) && isValidISO(to) && new Date(to) <= new Date(from)) errors.push('To позже From.');
      if (!isValidDuration(step)) errors.push('Step: 1s/200ms/1m.');
      let speed = parseFloat(speedVal || '1');
      if (!Number.isFinite(speed) || speed <= 0) errors.push('Speed: положительное число.');
      if (windowVal && !isValidDuration(windowVal)) errors.push('Window: 5s/1m.');
      els.startErrors.textContent = errors.join(' ');
      if (errors.length) return null;
      const payload = { from, to, step, speed };
      if (windowVal) payload.window = windowVal;
      return payload;
    }

    function isValidISO(v) {
      const d = new Date(v);
      return v && !Number.isNaN(d.getTime());
    }

    function isValidDuration(v) {
      return /^\d+(ms|s|m|h)$/.test(v);
    }

    async function refresh(full = false) {
      const url = '/api/v2/job';
      logUI(`refresh ${full ? 'full' : 'state'} start last_ts=${state.model.last_ts || state.model.LastTS}`);
      const data = await requestJSON('GET', url);
      const status = statusNormalize(data?.status || data?.Status || state.model.status);
      const pending = data?.pending || data?.Pending || {};
      state.model = { ...data, status, pending };
      // Если нет активных params, но есть pending range — используем его для отображения.
      const pendingRange = pending.range_set ? pending.range : pending.Range;
      if (!state.model.params && !state.model.Params && pendingRange) {
        state.model.params = pendingRange;
        state.model.Params = pendingRange;
      }
      hydrateChartDefaultsFromParams();
      syncChartWithParams(state.model.params || state.model.Params);
      syncChartRange(state.model.params || state.model.Params, pending);
      logUI(`refresh result status=${status} last_ts=${state.model.last_ts || state.model.LastTS} pendingRange=${pendingRange ? 'yes' : 'no'}`);
      updateStatusView();
    }

    async function startJob() {
      const payload = validateStartForm();
      if (!payload) return;
      logUI(`set range v2 ${JSON.stringify(payload)}`);
      await requestJSON('POST', '/api/v2/job/range', payload);
      logUI('startJob (v2) using pending');
      try {
        await requestJSON('POST', '/api/v2/job/start', {});
        log('Старт отправлен');
        await refresh(true);
      } catch (err) {
        log(`Старт: ${err.message}`, false);
      }
    }

    function bindActions() {
      els.tabs.forEach(btn => {
        btn.addEventListener('click', () => setTab(btn.dataset.tab));
      });
      if (els.table.filter) {
        els.table.filter.addEventListener('input', () => {
          tableState.filter = els.table.filter.value.toLowerCase();
          renderTable();
        });
      }
      document.querySelectorAll('[data-preset-min]').forEach(btn => {
        btn.addEventListener('click', () => applyPresetMinutes(parseInt(btn.dataset.presetMin, 10)));
      });
      document.querySelectorAll('[data-picker]').forEach(btn => {
        btn.addEventListener('click', () => openPicker(btn.dataset.picker));
      });
      els.dialog.addEventListener('close', () => {
        if (els.dialog.returnValue !== 'ok') return;
        const target = els.dialog.dataset.target;
        const val = els.dialogInput.value;
        if (!target || !val) return;
        const iso = localInputToISO(val);
        const input = document.getElementById(target);
        if (input && iso) input.value = iso;
      });
      els.timeline.addEventListener('change', onTimelineSeek);
      els.timeline.addEventListener('input', onTimelinePreview);
      els.timeline.addEventListener('pointerdown', () => {
        const params = state.model.params || state.model.Params || {};
        const pending = state.model.pending || state.model.Pending || {};
        const range = getEffectiveRange(params, pending);
        if (!range.valid) return;
        const v = Number(els.timeline.value) / 1000;
        const ts = toRFC3339(new Date(range.from.getTime() + (range.to - range.from) * v));
        if (ts) logUI(`timeline drag start ${ts}`);
      });
      els.controls.stepBack.addEventListener('click', () => action('step назад', '/api/v2/job/step/backward', { apply: true }));
      els.controls.stepFwd.addEventListener('click', () => action('step вперёд', '/api/v2/job/step/forward'));
      els.controls.stop.addEventListener('click', () => {
        logUI('Stop button: clicked');
        action('stop', '/api/v2/job/stop');
      });
      els.controls.playPause.addEventListener('click', onPlayPause);
      els.controls.seekManual.addEventListener('click', () => {
        const ts = els.seekManualTs.value.trim();
        action('seek', '/api/v2/job/seek', { ts, apply: false });
      });
      els.clearLog.addEventListener('click', () => { els.log.innerHTML = ''; });
      if (els.rangeBtn) {
        els.rangeBtn.addEventListener('click', () => applyAvailableRange());
      }
      if (els.controls.jumpStart) {
        els.controls.jumpStart.addEventListener('click', () => jumpToEdge('start'));
      }
      if (els.controls.jumpEnd) {
        els.controls.jumpEnd.addEventListener('click', () => jumpToEdge('end'));
      }
      if (els.charts.apply) {
        els.charts.apply.addEventListener('click', () => {
          addSensorsFromInput();
        });
      }
      if (els.charts.clear) {
        els.charts.clear.addEventListener('click', () => clearChart());
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.addEventListener('change', () => {
          chartState.autoUpdate = !!els.charts.autoUpdate.checked;
          updateChartMeta();
        });
      }
      if (els.charts.legendBody) {
        els.charts.legendBody.addEventListener('input', (e) => {
          const target = e.target;
          if (target && target.matches('input.chart-color-input')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            const color = target.value || '#22d3ee';
            if (!chartState.datasets.has(id)) return;
            const ds = chartState.datasets.get(id);
            ds.color = color;
            rebuildChart();
          }
        });
        els.charts.legendBody.addEventListener('click', (e) => {
          const target = e.target;
          if (target && target.matches('button.chart-remove-btn')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            const filtered = chartState.selected.filter(x => x !== id);
            applyChartSensors(filtered);
          }
        });
      }
      if (els.charts.suggestBox) {
        els.charts.suggestBox.addEventListener('mousedown', (e) => {
          const target = e.target.closest('.chart-suggest-item');
          if (!target) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          applyChartSensors([...chartState.selected, id]);
          hideChartSuggestions();
        });
      }
      if (els.charts.window) {
        els.charts.window.addEventListener('change', () => {
          const v = Number(els.charts.window.value);
          if (!Number.isFinite(v) || v < 0) return;
          chartState.windowSec = v;
          const now = Date.now();
          chartState.datasets.forEach(ds => trimDataset(ds, now));
          syncChartData();
        });
      }
      if (els.charts.sensors) {
        els.charts.sensors.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const active = chartState.suggest.items[chartState.suggest.active];
            if (active) {
              applyChartSensors([...chartState.selected, active.id]);
              hideChartSuggestions();
            } else {
              addSensorsFromInput();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            e.target.blur();
            hideChartSuggestions();
          } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            moveSuggestActive(e.key === 'ArrowDown' ? 1 : -1);
          } else {
            setTimeout(() => renderChartSuggestions(e.target.value), 0);
          }
        });
        els.charts.sensors.addEventListener('input', (e) => renderChartSuggestions(e.target.value));
        els.charts.sensors.addEventListener('change', () => addSensorsFromInput());
        els.charts.sensors.addEventListener('focus', (e) => renderChartSuggestions(e.target.value));
        els.charts.sensors.addEventListener('blur', () => setTimeout(hideChartSuggestions, 120));
      }
      if (els.charts.fill) {
        els.charts.fill.addEventListener('change', () => syncChartData());
      }
    }

    async function onPlayPause() {
      const st = statusNormalize(state.model.status);
      if (st === 'running') {
        logUI('Play button: pausing');
        await action('pause', '/api/v2/job/pause');
        state.previewTs = null;
        return;
      }
      if (st === 'paused') {
        logUI('Play button: resuming with seek');
        const targetDate = currentTsFromServer();
        const target = targetDate ? toRFC3339(targetDate) : (state.model.last_ts || inputs.from.value.trim());
        if (target) {
          await action('seek', '/api/v2/job/seek', { ts: target, apply: false });
        }
        state.previewTs = null;
        await action('resume', '/api/v2/job/resume');
        return;
      }
      logUI('Play button: starting job');
      state.previewTs = null;
      await startJob();
    }

    function onTimelinePreview() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const dt = new Date(from.getTime() + (to - from) * v);
      const iso = toRFC3339(dt);
      if (!iso) return;
      state.previewTs = dt;
      els.currentLabel.textContent = iso;
    }

    async function onTimelineSeek() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const ts = toRFC3339(new Date(from.getTime() + (to - from) * v));
      state.previewTs = parseISO(ts);
      logUI(`timeline seek ${ts}`);
      await seekOrPreview(ts);
    }

    async function action(label, url, body, refreshFull = true) {
      logUI(`action ${label} ${url} ${body ? JSON.stringify(body) : ''}`);
      try {
        await requestJSON('POST', url, body);
        log(`${label}: ok`);
        await refresh(refreshFull);
      } catch (err) {
        log(`${label}: ${err.message}`, false);
      }
    }

    function openPicker(targetId) {
      const input = document.getElementById(targetId);
      const current = input ? input.value.trim() : '';
      els.dialog.dataset.target = targetId;
      els.dialogInput.value = isoToLocalInput(current) || '';
      els.dialog.showModal();
    }

    function isoToLocalInput(iso) {
      const d = parseISO(iso);
      if (!d) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function localInputToISO(val) {
      if (!val) return '';
      const d = new Date(val);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function applyPresetMinutes(mins) {
      if (!Number.isFinite(mins) || mins <= 0) return;
      const now = new Date();
      const from = new Date(now.getTime() - mins * 60 * 1000);
      els.inputs.from.value = toRFC3339(from);
      els.inputs.to.value = toRFC3339(now);
      state.previewTs = null;
    }

    async function jumpToEdge(where) {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const st = statusNormalize(state.model.status);
      logUI(`jump button ${where} click status=${st} rangeValid=${range.valid}`);
      if (!range.valid) {
        log('Нет диапазона для перемещения', false);
        return;
      }
      let target = where === 'end' ? range.to : range.from;
      els.seekManualTs.value = target.toISOString().replace(/\.\d{3}Z$/, 'Z');
      await seekOrPreview(target.toISOString().replace(/\.\d{3}Z$/, 'Z'));
    }

    async function seekOrPreview(ts) {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      if (!range.valid) return;
      logUI(`seekOrPreview request ts=${ts}`);
      await action('seek', '/api/v2/job/seek', { ts, apply: false });
    }

    function toRFC3339(d) {
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    async function startPolling() {
      try { await refresh(true); } catch (err) { log(`Init: ${err.message}`, false); }
      setInterval(async () => {
        try {
          await refresh(false);
          state.pollErrorNotified = false;
        } catch (err) {
          if (!state.pollErrorNotified) {
            log(`Poll: ${err.message}`, false);
            state.pollErrorNotified = true;
          }
        }
      }, state.pollingMs);
    }

    bindActions();
    updateControls();
    preloadSensors();
    startPolling();
    connectWS();
    renderTable(true);
    updateChartMeta();

    if (new URLSearchParams(location.search).get('test') === '1') {
      const script = document.createElement('script');
      script.src = '/ui/index.test.js';
      script.defer = true;
      document.body.appendChild(script);
    }

    async function applyAvailableRange() {
      try {
        logUI('range button clicked');
        const data = await requestJSON('GET', '/api/v2/job/range');
        logUI('Диапазон получен через v2');
        if (!data || !data.from || !data.to) {
          log('Диапазон: нет данных', false);
          return;
        }
        els.inputs.from.value = data.from;
        els.inputs.to.value = data.to;
        log(`Диапазон установлен: ${data.from} → ${data.to}`);
        const payload = validateStartForm();
        if (payload) {
          await requestJSON('POST', '/api/v2/job/range', payload);
        }
        await refresh(true);
      } catch (err) {
        log(`Диапазон: ${err.message}`, false);
      }
    }
  </script>
</body>
</html>
