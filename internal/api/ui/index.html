<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>TimeMachine Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root { font-family: "Space Grotesk", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif; color: #e5e7eb; background: #0b1220; }
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at 10% 10%, rgba(20,184,166,0.08), transparent 22%), radial-gradient(circle at 80% 0%, rgba(14,165,233,0.12), transparent 30%), #0b1220; }
    .page { max-width: 1200px; margin: 0 auto; padding: 26px 18px 60px; }
    .header { display: flex; justify-content: space-between; gap: 14px; align-items: center; }
    .title h1 { margin: 4px 0 6px; font-size: 26px; color: #f8fafc; letter-spacing: -0.01em; }
    .eyebrow { text-transform: uppercase; font-size: 12px; letter-spacing: 0.24em; color: #f8fafc; margin: 0; }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { padding: 8px 12px; border-radius: 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: #e2e8f0; font-weight: 600; font-size: 13px; display: inline-flex; align-items: center; gap: 6px; }
    .chip.ok { color: #10b981; border-color: rgba(16,185,129,0.4); background: rgba(16,185,129,0.12); }
    .chip.warn { color: #f59e0b; border-color: rgba(245,158,11,0.35); background: rgba(245,158,11,0.12); }
    .chip.err { color: #f87171; border-color: rgba(248,113,113,0.4); background: rgba(248,113,113,0.12); }
    .card { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 14px 16px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); margin-top: 14px; }
    .row { display: flex; gap: 10px; }
    .row.wrap { flex-wrap: wrap; }
    .row.center { align-items: center; }
    label { display: block; font-size: 12px; color: #9ca3af; margin-bottom: 4px; }
    input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #233143; background: #0b1324; color: #e2e8f0; font-size: 14px; outline: none; }
    input:focus { border-color: #22d3ee; box-shadow: 0 0 0 3px rgba(34,211,238,0.12); }
    input::placeholder { color: #94a3b8; }
    button { border: none; border-radius: 12px; padding: 12px; background: linear-gradient(135deg, #0ea5e9, #14b8a6); color: #0b1220; font-weight: 700; cursor: pointer; transition: transform 0.08s ease, box-shadow 0.14s ease, opacity 0.12s, background 0.12s, color 0.12s, border-color 0.12s; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(14,165,233,0.35); }
    button:active:not(:disabled) { background: linear-gradient(135deg, #0284c7, #0ea5e9); box-shadow: 0 6px 18px rgba(14,165,233,0.28); }
    button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background: #1b2535; color: #94a3b8; }
    .ghost { background: rgba(255,255,255,0.06); color: #e2e8f0; border: 1px solid #1f2937; }
    .player button { background: #111a2b; color: #e2e8f0; border: 1px solid #233143; border-radius: 10px; padding: 0 10px; height: 42px; min-width: 0; display: inline-flex; align-items: center; justify-content: center; gap: 4px; font-size: 13px; transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
    .player button:hover:not(:disabled) { background: #16223a; border-color: #2f3f58; }
    .player button:disabled { opacity: 0.55; cursor: not-allowed; background: #0b1324; color: #94a3b8; }
    .play-btn { background: #111a2b; color: #e2e8f0; border: 1px solid #233143; }
    .input-with-btn { display: grid; grid-template-columns: 1fr auto; gap: 6px; }
    .picker-btn { width: 42px; padding: 10px 0; border-radius: 10px; border: 1px solid #233143; background: #111a2b; color: #e2e8f0; font-weight: 700; }
    .picker-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .preset-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .preset-btn { padding: 8px 10px; border-radius: 10px; background: #111a2b; border: 1px solid #233143; color: #e2e8f0; font-weight: 600; cursor: pointer; }
    .preset-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .status-line { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .status-item { background: #0b1324; border: 1px solid #1f2937; border-radius: 10px; padding: 8px 10px; color: #e5e7eb; font-weight: 600; min-width: 120px; }
    .status-item span { color: #94a3b8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; display: block; }
    .status-value { font-weight: 700; color: #e5e7eb; padding: 0; line-height: 20px; }
    .status-ok { color: #34d399; }
    .status-warn { color: #fbbf24; }
    .status-err { color: #f87171; }
    .badge-done { background: rgba(16,185,129,0.12); border: 1px solid rgba(16,185,129,0.35); color: #34d399; border-radius: 8px; padding: 4px 8px; display: inline-block; font-weight: 700; }
    .error-text { color: #f87171; min-height: 18px; font-size: 13px; }
    .muted { color: #94a3b8; font-size: 12px; }
    .timeline { display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; }
    .timeline input[type="range"] { width: 100%; accent-color: #22d3ee; }
    .timeline-label { font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #cbd5e1; }
    .player { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
    .toggle { display: flex; align-items: center; gap: 6px; color: #cbd5e1; font-size: 13px; }
    .placeholder-muted::placeholder { color: #64748b; opacity: 0.7; }
    .log { background: #0b1324; border: 1px solid #1f2937; border-radius: 12px; padding: 12px; max-height: 280px; overflow: auto; font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #e2e8f0; }
    .log-entry { padding: 7px 8px; border-radius: 8px; margin-bottom: 6px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.03); }
    .log-entry.ok { border-color: rgba(16,185,129,0.4); }
    .log-entry.warn { border-color: rgba(245,158,11,0.45); }
    .log-entry.err { border-color: rgba(248,113,113,0.45); }
    .log-entry .ts { color: #9ca3af; font-size: 11px; margin-bottom: 2px; }
    dialog { border: 1px solid #1f2937; background: #0f172a; color: #e2e8f0; border-radius: 12px; padding: 16px; min-width: 320px; box-shadow: 0 20px 60px rgba(0,0,0,0.55); }
    dialog::backdrop { background: rgba(0,0,0,0.55); }
    .dlg-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
    .tabs { display: flex; gap: 10px; margin: 16px 0 4px; }
    .tab { padding: 10px 14px; border-radius: 12px; border: 1px solid #1f2937; background: #0c1625; color: #cbd5e1; font-weight: 700; cursor: pointer; opacity: 0.75; }
    .tab.active { border-color: #22d3ee; box-shadow: 0 8px 24px rgba(34,211,238,0.16); background: #10253a; color: #e5e7eb; opacity: 1; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .table-wrap { overflow: auto; max-height: 520px; border: 1px solid #1f2937; border-radius: 12px; }
    table { width: 100%; border-collapse: collapse; background: #0f141a; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #1f2937; color: #e5e7eb; }
    th { position: sticky; top: 0; background: #111a24; z-index: 1; }
    tbody tr:nth-child(odd) { background-color: #0e1a2c; }
    tbody tr:nth-child(even) { background-color: #101f35; }
    tbody tr.changed { position: relative; }
    tbody tr.changed td:first-child { position: relative; }
    tbody tr.changed td:first-child::before { content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; background: #1c93d3; opacity: 0.9; }
    tbody tr.selected { background: rgba(34,211,238,0.12); }
    tbody tr.selected:nth-child(even) { background: rgba(34,211,238,0.14); }
    td.value { font-family: "JetBrains Mono", ui-monospace, monospace; width: 140px; white-space: nowrap; }
    th.value { width: 140px; }
    .table-graph-btn { padding: 6px 10px; background: #0f172a; border: 1px solid #1f2937; border-radius: 8px; color: #e5e7eb; cursor: pointer; min-width: 38px; text-align: center; }
    .table-graph-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .table-meta { color: #94a3b8; font-size: 13px; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: rgba(255,255,255,0.06); border: 1px solid #1f2937; }
    .chart-wrap { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 12px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); min-height: 420px; }
    .chart-box { width: 100%; max-width: 1100px; min-width: 720px; height: 420px; min-height: 320px; margin: 0 auto; position: relative; overflow: hidden; }
    .chart-box.step { height: 220px; min-height: 160px; }
    .chart-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .chart-controls input { max-width: 320px; }
    .chart-meta { color: #94a3b8; font-size: 13px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .chart-legend-wrap { height: 180px; min-height: 140px; max-height: 360px; overflow-y: auto; overflow-x: hidden; border: 1px solid #1f2937; border-radius: 10px; margin-top: 8px; position: relative; padding-bottom: 10px; }
    .chart-legend-table { width: 100%; border-collapse: collapse; font-size: 13px; color: #e5e7eb; }
    .chart-legend-table th, .chart-legend-table td { padding: 6px 8px; border-bottom: 1px solid #1f2937; }
    .chart-legend-table th:nth-child(1), .chart-legend-table td:nth-child(1) { width: 32px; text-align: center; }
    .chart-legend-table th:nth-child(2), .chart-legend-table td:nth-child(2) { width: 20%; }
    .chart-legend-table th:nth-child(3), .chart-legend-table td:nth-child(3) { width: 18%; }
    .chart-legend-table th:nth-child(4), .chart-legend-table td:nth-child(4) { width: 20%; }
    .chart-legend-table th:nth-child(5), .chart-legend-table td:nth-child(5) { width: auto; }
    .chart-legend-table th:nth-child(6), .chart-legend-table td:nth-child(6) { text-align: right; width: 60px; }
    .chart-legend-color { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 1px solid #1f2937; }
    .chart-color-btn { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #334155; background: #22d3ee; padding: 0; cursor: pointer; }
    .legend-muted { opacity: 0.4; }
    .legend-active { opacity: 1; }
    .chart-color-input { width: 32px; height: 24px; padding: 0; border: none; background: transparent; cursor: pointer; }
    .chart-suggest-wrap { position: relative; }
    .chart-suggest-box { position: absolute; top: 100%; left: 0; right: 0; background: #0f172a; border: 1px solid #1f2937; border-radius: 10px; margin-top: 4px; box-shadow: 0 12px 30px rgba(0,0,0,0.4); max-height: 220px; overflow-y: auto; z-index: 5; display: none; }
    .resize-handle { position: relative; left: 0; right: 0; height: 12px; cursor: ns-resize; background: linear-gradient(180deg, rgba(148,163,184,0.15), rgba(148,163,184,0.05)); border-top: 1px solid #1f2937; display: flex; align-items: center; justify-content: center; }
    .resize-handle::after { content: ''; width: 38px; height: 4px; border-radius: 999px; background: rgba(148,163,184,0.45); }
    .chart-resize-handle { margin-top: 6px; }
    .legend-resize-handle { position: sticky; left: 0; right: 0; bottom: 0; height: 12px; margin-top: 4px; cursor: ns-resize; z-index: 2; }
    .chart-suggest-item { padding: 8px 10px; cursor: pointer; color: #e5e7eb; }
    .chart-suggest-item:hover { background: rgba(34,211,238,0.08); }
    .chart-suggest-item.active { background: rgba(34,211,238,0.12); }
    .chart-suggestion-highlight { color: #22d3ee; font-weight: 700; }
    datalist { display: none; }
    .input-disabled { opacity: 0.5; pointer-events: none; }
    .brand-click { position: relative; cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M3.5 12c2.2-3.5 5.8-5.5 8.5-5.5S18.3 8.5 20.5 12c-2.2 3.5-5.8 5.5-8.5 5.5S5.7 15.5 3.5 12Z" fill="none" stroke="%23bcdcff" stroke-width="1.6"/><circle cx="12" cy="12" r="2.4" fill="none" stroke="%23bcdcff" stroke-width="1.6"/></svg>') 12 12, pointer; }
    .brand-fadeout { animation: brandFadeOut 0.65s ease forwards; }
    .brand-fadein { animation: brandFadeIn 0.65s ease forwards; }
    @keyframes brandFadeOut { 0% { opacity: 1; } 100% { opacity: 0; } }
    @keyframes brandFadeIn { 0% { opacity: 0; } 100% { opacity: 1; } }
    .easter { position: relative; display: inline-flex; align-items: center; gap: 8px; font-size: 11px; letter-spacing: 0.2em; color: #f8fbff; overflow: hidden; opacity: 0; }
    .easter.show { opacity: 1; }
    .easter.run { animation: easterFade 6s ease forwards; }
    @keyframes easterFade {
      0% { opacity: 0.18; }
      12% { opacity: 0.32; }
      50% { opacity: 0.6; }
      70% { opacity: 0.95; }
      100% { opacity: 1; }
    }
    .easter .shine { position: absolute; top: 0; left: -50%; width: 42%; height: 100%; background: linear-gradient(120deg, transparent, rgba(255,255,255,0.35), transparent); transform: skewX(-20deg); animation: sweep 2s ease-in-out infinite alternate; pointer-events: none; mix-blend-mode: screen; }
    @keyframes sweep { 0% { left: -60%; opacity: 0; } 30% { opacity: 1; } 100% { left: 180%; opacity: 0; } }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="title">
        <p class="eyebrow" style="color:#f8fafc;">
          <span id="brandContainer"><span id="brandEaster" class="brand-click">TimeMachine</span> · Player · v2</span>
        </p>
        <h1 style="color:#94a3b8;">Sensors history</h1>
      </div>
      <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-end; min-width:320px;">
        <div class="status-line" style="justify-content:flex-end; gap:10px;">
          <div id="controlLockChip" class="chip warn" style="display:none; background:#78350f; color:#fbbf24; border:1px solid #f59e0b;">Управление отключено</div>
          <div class="status-item"><span>Status</span><div id="chipStatus">idle</div></div>
          <div id="statusBadge" style="display:none;">idle</div>
          <div class="status-item"><span>Step</span><div id="statStep">-</div></div>
          <div class="status-item"><span>TS</span><div id="statTs">-</div></div>
          <div class="status-item"><span>Updates</span><div id="statUpdates">-</div></div>
        </div>
      </div>
    </div>

      <div class="tabs" style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button class="tab active" data-tab="control">Управление</button>
          <button class="tab" data-tab="table">Датчики</button>
          <button class="tab" data-tab="charts">Графики</button>
        </div>
        <div class="player" style="display:flex; gap:8px; align-items:center; background:#0f172a; border:1px solid #1f2937; border-radius:14px; padding:6px 8px;">
          <button id="stepBackBtn" class="ghost" aria-label="Шаг назад" title="Шаг назад" style="width:60px;" disabled>⏮</button>
          <button id="playPauseBtn" class="play-btn" aria-label="Play/Pause" title="Play/Pause" style="width:88px;" disabled>▶️ Play</button>
          <button id="stopBtn" class="ghost" aria-label="Stop" title="Stop" style="width:88px; font-size:15px;" disabled>■ Stop</button>
          <button id="stepFwdBtn" class="ghost" aria-label="Шаг вперёд" title="Шаг вперёд" style="width:60px;" disabled>⏭</button>
        </div>
        <div class="chips" style="justify-content:flex-end; display:flex; gap:10px; flex-wrap:wrap;">
          <span class="chip" id="wsSpeedChip">ws —</span>
          <span class="chip ok" id="pollingChip">polling 1.5s</span>
          <span class="chip">REST /api/v2/*</span>
        </div>
      </div>

    <div id="panel-control" class="tab-panel active">
    <div class="card">
      <div class="row" style="gap:12px; align-items:flex-end; justify-content:space-between; flex-wrap:wrap;">
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <button id="workingLoadBtn" class="ghost" type="button" style="padding:6px 10px; min-width:120px; font-size:13px;">Загрузить</button>
          <div id="workingMeta" class="muted" style="font-size:13px;">Рабочий список датчиков: —</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
          <button id="claimControlBtn" class="ghost" type="button" style="display:none; padding:6px 10px; font-size:12px;">Забрать управление</button>
          <div id="controlLockNotice" class="muted" style="display:none; color:#fbbf24; font-size:13px;">Управление недоступно: занято другой сессией</div>
        </div>
      </div>
      <div class="row wrap" style="gap:12px; align-items:flex-end; margin-top:6px;">
        <div style="flex:2; min-width: 320px;">
          <label>Диапазон</label>
          <button id="rangePickerBtn" class="ghost" type="button" style="width:100%; text-align:left; padding:12px 12px;">
            <span id="rangeLabelValue" style="color:#fbbf24;">не задан</span>
          </button>
        </div>
        <div style="flex:1; min-width: 160px;">
          <label for="saveToSM">Сохранять в SM</label>
          <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer; user-select:none;">
            <input id="saveToSM" type="checkbox" style="width:18px; height:18px;">
            <span style="color:#e5e7eb;">Включить</span>
          </label>
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="step">Шаг</label>
          <input id="step" type="text" value="1s">
        </div>
        <div style="flex:1; min-width: 120px;">
          <label for="speed">Скорость</label>
          <input id="speed" type="number" step="0.1" value="1">
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="window">Кэш</label>
          <input id="window" type="text" value="15s">
        </div>
      </div>
      <div style="display:none;">
        <input id="from" type="text" placeholder="2024-06-01T00:00:00Z">
        <input id="to" type="text" placeholder="2024-06-01T01:00:00Z">
      </div>
      <div class="muted" id="startErrors" style="margin-top:8px;"></div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:center; margin-bottom:8px;">
        <div class="status-item" style="min-width:200px; text-align:center;">
          <div id="currentLabel">-</div>
        </div>
      </div>
      <div class="timeline">
        <div class="timeline-label" id="fromLabel">from: -</div>
        <input id="timeline" type="range" min="0" max="1000" value="0" disabled>
        <div class="timeline-label" id="toLabel">to: -</div>
      </div>
      <div class="muted" id="errorNote" style="text-align:center; margin-top:6px;"></div>
    </div>

    <div class="card">
      <div class="row center" style="justify-content:space-between; margin-bottom:8px;">
        <h3 style="margin:0; color:#f8fafc; font-size:16px;">Лог</h3>
        <div class="row center" style="gap:8px;">
          <label class="checkbox-inline" style="color:#e5e7eb; font-size:12px;">
            <input type="checkbox" id="diagEnable" style="margin-right:4px; width:auto;"> Диагностика
          </label>
          <label class="checkbox-inline" style="color:#e5e7eb; font-size:12px;">
            <input type="checkbox" id="diagNetEnable" style="margin-right:4px; width:auto;"> Логировать сетевой обмен
          </label>
          <button class="ghost" id="diagDownload" style="padding:6px 10px; font-size:12px;" disabled>Выгрузить</button>
          <button class="ghost" id="diagClear" style="padding:6px 10px; font-size:12px;" disabled>Очистить диагностику</button>
          <button class="ghost" id="clearLogBtn" style="padding:6px 10px; font-size:12px;">Очистить</button>
        </div>
      </div>
      <div class="log" id="log"></div>
    </div>
    </div>

    <div id="panel-table" class="tab-panel">
      <div class="card">
        <div class="row center" style="justify-content:flex-start; gap:12px; flex-wrap:wrap;">
          <input id="tableFilter" type="text" placeholder="Введите имя или текст..." style="max-width:340px; flex:0 0 auto;">
          <span class="table-meta" id="tableMeta" style="min-width:220px;">—</span>
        </div>
        <div class="table-wrap" style="margin-top:12px;">
          <table>
            <thead>
              <tr>
                <th style="width:40px; text-align:center;"><input id="tableSelectAll" type="checkbox" style="width:auto; margin:0;"></th>
                <th style="width:180px;">Name</th>
                <th class="value">
                  Value
                  <select id="tablePrecision" style="background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:6px; padding:2px 6px; font-size:12px; margin-left:6px;">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                  </select>
                </th>
                <th>Text</th>
                <th style="width:80px; text-align:center;">Тип</th>
                <th style="width:60px; text-align:center;"></th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div id="panel-charts" class="tab-panel">
      <div class="card">
        <div class="chart-controls">
          <div style="flex:1; min-width:260px;" class="chart-suggest-wrap">
            <label for="chartSensors">Добавить датчик</label>
            <input id="chartSensors" type="text" placeholder="Введите имя или текст..." autocomplete="off">
            <div id="chartSuggestionsBox" class="chart-suggest-box"></div>
          </div>
          <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap;">
            <button id="chartClearBtn" class="ghost" type="button">Очистить</button>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartAutoUpdate" type="checkbox" checked style="width:auto; margin:0;">
              Автообновление
            </label>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartFill" type="checkbox" checked style="width:auto; margin:0;">
              Фон
            </label>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartSmooth" type="checkbox" checked style="width:auto; margin:0;">
              Сглаживание
            </label>
          </div>
          <div class="chart-meta" id="chartMeta">Нет данных</div>
        </div>
        <div class="chart-wrap">
          <div class="chart-box" id="chartBox" style="height:420px;">
            <canvas id="chartCanvas" style="width:100%; height:100%;"></canvas>
          </div>
          <div class="resize-handle chart-resize-handle" id="chartResizeHandle" title="Потяните, чтобы изменить высоту графика"></div>
          <div class="chart-box step" id="chartBoxStep" style="height:220px; margin-top:12px;">
            <canvas id="chartCanvasStep" style="width:100%; height:100%;"></canvas>
          </div>
          <div class="resize-handle chart-resize-handle" id="chartResizeHandleStep" title="Потяните, чтобы изменить высоту дискретного графика"></div>
          <div id="chartEmpty" class="muted" style="text-align:center; margin-top:8px;">Нет данных для отображения</div>
          <div class="chart-legend-wrap" id="chartLegendWrap" style="height:180px; overflow-y:auto; overflow-x:hidden;">
            <table class="chart-legend-table" id="chartLegendTable">
              <thead><tr>
                <th></th>
                <th>Датчик</th>
                <th>
                  Значение,
                  <select id="chartPrecision" style="background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:6px; padding:2px 6px; font-size:12px;">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                  </select>
                </th>
                <th>Время</th>
                <th>Текст</th>
                <th></th>
              </tr></thead>
              <tbody id="chartLegendBody"></tbody>
            </table>
          </div>
            <div class="resize-handle legend-resize-handle" id="legendResizeHandle" title="Потяните, чтобы изменить высоту легенды"></div>
          </div>
      </div>
    </div>
  </div>

  <dialog id="datetimeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 6px;">Выбор даты/времени</h3>
      <p class="muted" style="margin:0 0 10px;">Локальное время → сохраняем как RFC3339 с Z.</p>
      <input id="dtInput" type="datetime-local" step="1" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0;">
      <div class="dlg-actions">
        <button type="submit" value="cancel" class="ghost">Отмена</button>
        <button type="submit" value="ok">Применить</button>
      </div>
    </form>
  </dialog>

  <dialog id="colorDialog">
    <form method="dialog">
      <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
        <input id="colorInput" type="color" style="appearance:none; width:42px; height:42px; padding:0; border:1px solid #1f2937; border-radius:8px; background:transparent; cursor:pointer;">
        <span style="font-size:15px; font-weight:700; color:#e5e7eb;">Выбрать цвет</span>
      </div>
      <div class="dlg-actions">
        <button type="submit" value="ok">Применить</button>
        <button type="submit" value="cancel" class="ghost">Отмена</button>
      </div>
    </form>
  </dialog>

  <dialog id="rangeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 8px;">Диапазон</h3>
      <div class="muted" style="margin-bottom:8px;">Быстрый диапазон</div>
      <div class="preset-row" style="margin:0 0 12px; gap:8px; align-items:center;">
        <button class="preset-btn" data-quick-min="5" type="button">5м</button>
        <button class="preset-btn" data-quick-min="10" type="button">10м</button>
        <button class="preset-btn" data-quick-min="30" type="button">30м</button>
        <button class="preset-btn" data-quick-min="60" type="button">1ч</button>
        <button class="preset-btn" data-quick-min="180" type="button">3ч</button>
        <button class="ghost" id="rangeBtn" type="button" style="margin-left:auto;">Установить доступный диапазон</button>
      </div>
      <div class="row wrap" style="gap:12px;">
        <div style="flex:1; min-width:260px;">
          <label for="rangeDialogFrom">From</label>
          <input id="rangeDialogFrom" type="datetime-local" step="1">
        </div>
        <div style="flex:1; min-width:260px;">
          <label for="rangeDialogTo">To</label>
          <input id="rangeDialogTo" type="datetime-local" step="1">
        </div>
      </div>
      <div class="dlg-actions">
        <button type="submit" value="ok">Применить</button>
        <button type="submit" value="cancel" class="ghost">Отмена</button>
      </div>
    </form>
  </dialog>

  <dialog id="sensorsDialog">
    <form method="dialog" style="min-width:640px;">
      <h3 style="margin:0 0 6px;">Рабочий список датчиков</h3>
      <p class="muted" style="margin:0 0 10px;">Выберите датчики, с которыми будет работать плеер. По умолчанию используются все.</p>
      <div class="tabs" id="sensorsTabs" style="margin-top:8px;">
        <button type="button" class="tab active" data-sensortab="existing">Выбрать из существующих</button>
        <button type="button" class="tab" data-sensortab="file">Загрузить из файла</button>
      </div>
      <div class="tab-panel active" id="sensorsPanelExisting">
        <div style="border-top:1px solid #1f2937; padding-top:12px; margin-top:10px;">
        <div class="row wrap" style="gap:8px; align-items:center; margin-bottom:8px;">
          <div style="flex:1; min-width:220px;">
            <label for="sensorsFilter">Фильтр</label>
            <input id="sensorsFilter" type="text" placeholder="Введите имя или текст...">
          </div>
          <label class="toggle" style="margin-top:18px;">
            <input id="sensorsSelectAll" type="checkbox" style="width:16px; height:16px;">
            <span>Выбрать все</span>
          </label>
        </div>
        <div class="table-wrap" style="max-height:320px; min-height:220px;">
          <table>
            <thead><tr>
              <th style="text-align:center; width:36px;"></th>
              <th>Датчик</th>
              <th>Имя</th>
              <th style="text-align:center; width:80px;">Тип</th>
            </tr></thead>
            <tbody id="sensorsDialogBody"></tbody>
          </table>
        </div>
        <div class="table-meta" id="sensorsDialogMeta" style="margin-top:6px;">—</div>
        </div>
      </div>
      <div class="tab-panel" id="sensorsPanelFile">
        <div style="border-top:1px solid #1f2937; padding-top:12px; margin-top:10px;">
          <div style="margin-bottom:12px;">
            <label for="sensorsFileInput">Файл со списком (id или name на строку)</label>
            <input id="sensorsFileInput" type="file" accept=".txt,.lst,.csv">
          </div>
          <div style="margin-top:12px;">
            <label for="sensorsFileArea">Или вставьте список вручную</label>
            <textarea id="sensorsFileArea" rows="6" class="placeholder-muted" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0; resize:vertical; margin-top:8px;" placeholder="Sensor10001&#10;10002&#10;..."></textarea>
          </div>
        </div>
        <div class="table-meta" id="sensorsFileMeta" style="margin-top:6px;">Загрузите файл или вставьте список.</div>
      </div>
      <div id="sensorsDialogError" class="error-text" style="margin-top:6px; min-height:18px;"></div>
      <div class="dlg-actions">
        <button type="button" id="sensorsResetBtn" class="ghost" style="margin-right:auto;">Сбросить на все</button>
        <button type="submit" value="cancel" id="sensorsCancelBtn" class="ghost">Отмена</button>
        <button type="submit" value="ok" id="sensorsApplyBtn">Применить</button>
      </div>
    </form>
  </dialog>

  <dialog id="preciseTimeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 6px;">Точная позиция воспроизведения</h3>
      <p class="muted" style="margin:0 0 10px;">Укажите точное время для перемотки.</p>
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:10px;">
        <div>
          <label for="preciseDate">Дата</label>
          <input id="preciseDate" type="date" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0;">
        </div>
        <div>
          <label for="preciseTime">Время (ЧЧ:ММ:СС)</label>
          <input id="preciseTime" type="text" placeholder="12:34:56" pattern="[0-2][0-9]:[0-5][0-9]:[0-5][0-9]" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0; font-family: 'JetBrains Mono', monospace;">
        </div>
      </div>
      <div>
        <label for="preciseMillis">Миллисекунды (0-999)</label>
        <input id="preciseMillis" type="number" min="0" max="999" step="1" placeholder="000" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0; font-family: 'JetBrains Mono', monospace;">
      </div>
      <div id="preciseTimeError" class="error-text" style="margin-top:8px; min-height:18px;"></div>
      <div class="dlg-actions">
        <button type="submit" value="cancel" class="ghost">Отмена</button>
        <button type="submit" value="ok">Применить</button>
      </div>
    </form>
  </dialog>

  <script src="/ui/chart.umd.min.js"></script>
  <script src="/ui/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="/ui/chartjs-plugin-zoom.min.js"></script>
  <script>
  // Диагностическое логирование (в UI и для выгрузки).
  const logUIEnabled = false;
  const diagBuffer = [];
  const diagLimit = 1000;
  function updateDiagButtons() {
    if (typeof els === 'undefined' || !els || !els.diagEnable) return;
    els.diagEnable.checked = !!state.diagEnabled;
    if (els.diagNetEnable) els.diagNetEnable.checked = !!state.netLogEnabled;
    const has = diagBuffer.length > 0;
    if (els.diagDownload) els.diagDownload.disabled = !has;
    if (els.diagClear) els.diagClear.disabled = !has;
  }
  function pushDiag(line) {
    if (!state.diagEnabled && !state.netLogEnabled) return;
    diagBuffer.push(line);
    if (diagBuffer.length > diagLimit) diagBuffer.shift();
    updateDiagButtons();
  }
  function pushDiagAction(line) {
    if (!state.diagEnabled) return;
    pushDiag(line);
  }
  function pushDiagNet(line, { truncateForDiag = false } = {}) {
    if (!state.diagEnabled && !state.netLogEnabled) return;
    let msg = line;
    if (!state.netLogEnabled && truncateForDiag) {
      msg = truncate(line, 30);
    }
    pushDiag(msg);
  }
  function truncate(str, max = 30) {
    if (!str) return '';
    if (str.length <= max) return str;
    return `${str.slice(0, max)}…`;
  }
  function downloadDiag() {
    if (!diagBuffer.length) return;
    const blob = new Blob([diagBuffer.join('\n')], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    a.href = url;
    a.download = `diagnostics-${ts}.txt`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }
  function clearDiag() {
    diagBuffer.length = 0;
    updateDiagButtons();
  }
  const logUI = (msg, warn = false) => {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    if (logUIEnabled) console.info(`[UI LOG] ${msg}`);
    pushDiagAction(line);
  };
  const chartLogEnabled = true;
  const chartLog = (msg, payload) => {
    if (!chartLogEnabled) return;
    if (payload !== undefined) {
      console.info(`[chart] ${msg}`, payload);
    } else {
      console.info(`[chart] ${msg}`);
    }
    pushDiagAction(`[${new Date().toLocaleTimeString()}] [chart] ${msg}${payload ? ' ' + JSON.stringify(payload).slice(0, 200) : ''}`);
  };

  const els = {
      inputs: {
        from: document.getElementById('from'),
        to: document.getElementById('to'),
        step: document.getElementById('step'),
        speed: document.getElementById('speed'),
        window: document.getElementById('window'),
        saveToSM: document.getElementById('saveToSM'),
      },
      working: {
        btn: document.getElementById('workingLoadBtn'),
        meta: document.getElementById('workingMeta'),
      },
      controlLock: {
        notice: document.getElementById('controlLockNotice'),
        claim: document.getElementById('claimControlBtn'),
        chip: document.getElementById('controlLockChip'),
      },
      brandContainer: document.getElementById('brandContainer'),
      brandClick: document.getElementById('brandEaster'),
      tabs: document.querySelectorAll('[data-tab]'),
      panels: {
        control: document.getElementById('panel-control'),
        table: document.getElementById('panel-table'),
        charts: document.getElementById('panel-charts'),
      },
      startErrors: document.getElementById('startErrors'),
      chipStatus: document.getElementById('chipStatus'),
      wsSpeed: document.getElementById('wsSpeedChip'),
      status: {
        badge: document.getElementById('statusBadge'),
        error: document.getElementById('errorNote'),
        step: document.getElementById('statStep'),
        ts: document.getElementById('statTs'),
        updates: document.getElementById('statUpdates'),
      },
      testChip: document.getElementById('testChip'),
      timeline: document.getElementById('timeline'),
      fromLabel: document.getElementById('fromLabel'),
      toLabel: document.getElementById('toLabel'),
      currentLabel: document.getElementById('currentLabel'),
      controls: {
        stepBack: document.getElementById('stepBackBtn'),
        playPause: document.getElementById('playPauseBtn'),
        stop: document.getElementById('stopBtn'),
        stepFwd: document.getElementById('stepFwdBtn'),
      },
      log: document.getElementById('log'),
      clearLog: document.getElementById('clearLogBtn'),
      diagEnable: document.getElementById('diagEnable'),
      diagNetEnable: document.getElementById('diagNetEnable'),
      diagDownload: document.getElementById('diagDownload'),
      diagClear: document.getElementById('diagClear'),
      dialog: document.getElementById('datetimeDialog'),
      dialogInput: document.getElementById('dtInput'),
      rangePicker: document.getElementById('rangePickerBtn'),
      rangeDialog: document.getElementById('rangeDialog'),
      rangeFrom: document.getElementById('rangeDialogFrom'),
      rangeTo: document.getElementById('rangeDialogTo'),
      rangeLabelValue: document.getElementById('rangeLabelValue'),
      table: {
        body: document.getElementById('tableBody'),
        filter: document.getElementById('tableFilter'),
        meta: document.getElementById('tableMeta'),
        precision: document.getElementById('tablePrecision'),
        selectAll: document.getElementById('tableSelectAll'),
      },
      charts: {
        sensors: document.getElementById('chartSensors'),
        clear: document.getElementById('chartClearBtn'),
        meta: document.getElementById('chartMeta'),
        empty: document.getElementById('chartEmpty'),
        suggestions: document.getElementById('chartSensorsSuggestions'),
        suggestBox: document.getElementById('chartSuggestionsBox'),
        canvas: document.getElementById('chartCanvas'),
        stepCanvas: document.getElementById('chartCanvasStep'),
        box: document.getElementById('chartBox'),
        boxStep: document.getElementById('chartBoxStep'),
        resizeHandle: document.getElementById('chartResizeHandle'),
        resizeHandleStep: document.getElementById('chartResizeHandleStep'),
        legendBody: document.getElementById('chartLegendBody'),
        legendWrap: document.getElementById('chartLegendWrap'),
        legendHandle: document.getElementById('legendResizeHandle'),
        fill: document.getElementById('chartFill'),
        autoUpdate: document.getElementById('chartAutoUpdate'),
        precision: document.getElementById('chartPrecision'),
        colorDialog: document.getElementById('colorDialog'),
        colorInput: document.getElementById('colorInput'),
        smooth: document.getElementById('chartSmooth'),
      },
      rangeBtn: document.getElementById('rangeBtn'),
      sensorsDialog: document.getElementById('sensorsDialog'),
      sensorsDialogTabs: document.querySelectorAll('[data-sensortab]'),
      sensorsPanelExisting: document.getElementById('sensorsPanelExisting'),
      sensorsPanelFile: document.getElementById('sensorsPanelFile'),
      sensorsFilter: document.getElementById('sensorsFilter'),
      sensorsSelectAll: document.getElementById('sensorsSelectAll'),
      sensorsDialogBody: document.getElementById('sensorsDialogBody'),
      sensorsDialogMeta: document.getElementById('sensorsDialogMeta'),
      sensorsFileInput: document.getElementById('sensorsFileInput'),
      sensorsFileArea: document.getElementById('sensorsFileArea'),
      sensorsFileMeta: document.getElementById('sensorsFileMeta'),
      sensorsDialogError: document.getElementById('sensorsDialogError'),
      sensorsResetBtn: document.getElementById('sensorsResetBtn'),
      sensorsApplyBtn: document.getElementById('sensorsApplyBtn'),
      sensorsCancelBtn: document.getElementById('sensorsCancelBtn'),
      preciseTimeDialog: document.getElementById('preciseTimeDialog'),
      preciseDate: document.getElementById('preciseDate'),
      preciseTime: document.getElementById('preciseTime'),
      preciseMillis: document.getElementById('preciseMillis'),
      preciseTimeError: document.getElementById('preciseTimeError'),
    };
    const inputs = els.inputs;
    // Стартовые значения: блокируем плеер до загрузки диапазона.
    setDisabled(els.controls.playPause, true);
    setDisabled(els.controls.stop, true);
    setDisabled(els.controls.stepBack, true);
    setDisabled(els.controls.stepFwd, true);
    setDisabled(els.timeline, true);

    // Fallbacks for tests: ensure invisible statusBadge exists.
    if (!els.status.badge) {
      const badge = document.createElement('div');
      badge.id = 'statusBadge';
      badge.style.display = 'none';
      badge.textContent = 'idle';
      document.body.appendChild(badge);
      els.status.badge = badge;
    }

  const state = {
      model: { status: 'idle' },
      pollingMs: 1500,
      pollErrorNotified: false,
      ws: null,
      reconnectIn: null,
      previewTs: null,
      lastParamsSig: '',
      pausedAtTs: null,
      testRunning: false,
      saveAllowed: false,
      wsBytes: [],
      saveDirty: false,
      diagEnabled: new URLSearchParams(window.location.search).get('diag') === '1',
      netLogEnabled: false,
      rangePicked: false,
      workingSensors: [],
      workingSet: new Set(),
      workingDefault: true,
      workingReady: false,
      sessionToken: '',
      isController: true,
      controlLocked: false,
      canClaim: false,
      controllerPresent: false,
      controlTimeoutSec: 0,
    };

    syncSaveToggle();

    setInterval(updateWsChip, 1000);
    window.addEventListener('offline', () => {
      state.ws = null;
      state.wsBytes = [];
      updateWsChip();
    });
    window.addEventListener('online', () => {
      updateWsChip();
      if (!state.ws) {
        connectWS();
      }
      loadWorkingSensors().catch(() => {});
    });

    window.__setTestIndicator = (active, text = 'Идёт тестирование…') => {
      state.testRunning = !!active;
      // Оставляем только зелёный индикатор из тест-хелпера; штатный чип скрываем.
      if (els.testChip) {
        els.testChip.style.display = 'none';
      }
    };

  const tableState = {
    rows: new Map(),
    meta: new Map(),
    filter: '',
    lastStep: '-',
    lastTs: '-',
    precision: 3,
    selected: new Set(),
  };
  const workingPicker = {
    tab: 'existing',
    filter: '',
    selected: new Set(),
    fileText: '',
    fileParsed: { valid: [], rejected: [] },
  };
    const chartState = {
      selected: [],
      datasets: new Map(), // id -> {label,color,data: [{x,y}], lastValue}
      chart: null,
      chartStep: null,
      maxPoints: 800,
      autoUpdate: true,
      smooth: true,
      windowSec: 300,
      lastParamsSig: '',
      lastSkip: '',
      range: { from: null, to: null },
      suggest: { items: [], active: -1, locked: false, lastQuery: '' },
      focused: null,
      pendingChartUpdate: false,
    };
  const sensorIndex = {
      byId: new Map(),    // id -> {id,name,textname}
      byName: new Map(),  // lower(name) -> id
      hydrated: false,
    };

  function getSensorMeta(id) {
    return sensorIndex.byId.get(id) || tableState.meta.get(id) || {};
  }
  function getSensorType(id) {
    const t = (getSensorMeta(id)?.iotype || '').toString().toUpperCase();
    return t;
  }
  function isDiscreteIO(io) {
    const t = (io || '').toString().toUpperCase();
    return t === 'DI' || t === 'DO';
  }
  function isAnalogIO(io) {
    const t = (io || '').toString().toUpperCase();
    if (!t) return true;
    return t === 'AI' || t === 'AO' || t === '';
  }
  function isDiscreteSensor(id) {
    const t = getSensorType(id);
    return isDiscreteIO(t);
  }
  function isAnalogSensor(id) {
    const t = getSensorType(id);
    return isAnalogIO(t);
  }

  function allSensorIds() {
    return Array.from(sensorIndex.byId.keys()).sort((a, b) => a - b);
  }

  function dedupeIds(list) {
    const set = new Set();
    list.forEach((n) => {
      const id = Number(n);
      if (Number.isFinite(id)) set.add(id);
    });
    return Array.from(set).sort((a, b) => a - b);
  }

  function isWorkingSensor(id) {
    if (!state.workingReady) return true;
    if (!state.workingSensors.length) return false;
    if (state.workingSet && state.workingSet.size) {
      return state.workingSet.has(id);
    }
    return state.workingSensors.includes(id);
  }

  function setWorkingLocal(ids, isDefault = false) {
    const uniq = dedupeIds(ids || []);
    state.workingSensors = uniq;
    state.workingSet = new Set(uniq);
    state.workingDefault = !!isDefault;
    state.workingReady = true;
    updateWorkingMeta();
    if (els.sensorsDialog && !els.sensorsDialog.open) {
      workingPicker.selected = new Set(uniq);
    }
    updateControls();
  }

  function updateWorkingMeta() {
    if (!els.working?.meta) return;
    if (!state.workingReady) {
      els.working.meta.textContent = 'Рабочий список: загружаем...';
      els.working.meta.style.color = '#94a3b8';
      return;
    }
    const total = sensorIndex.byId.size || state.workingSensors.length;
    const count = state.workingSensors.length;
    if (!state.workingSensors.length) {
      els.working.meta.textContent = 'Рабочий список датчиков: не выбран';
      els.working.meta.style.color = '#fbbf24';
      return;
    }
    if (state.workingDefault) {
      els.working.meta.textContent = `Рабочий список датчиков: все (${total})`;
      els.working.meta.style.color = '#94a3b8';
      return;
    }
    els.working.meta.textContent = `Рабочий список датчиков: ${count}/${total}`;
    els.working.meta.style.color = '#e5e7eb';
  }

  async function loadWorkingSensors() {
    if (state.workingLoading) return;
    state.workingLoading = true;
    try {
      const data = await requestJSON('GET', '/api/v2/job/sensors');
      const ids = (data?.sensors || []).map(Number).filter(Number.isFinite);
      const isDefault = !!data?.default;
      setWorkingLocal(ids.length ? ids : allSensorIds(), isDefault || !ids.length);
      pushDiagAction(`[working] loaded count=${ids.length} default=${isDefault ? 'yes' : 'no'}`);
    } catch (err) {
      pushDiagAction(`[working] load failed: ${err.message}`);
      // Фолбэк: используем полный список, если он уже загружен.
      if (sensorIndex.byId.size) {
        setWorkingLocal(allSensorIds(), true);
      } else {
        state.workingReady = true;
        state.workingSensors = [];
        state.workingSet = new Set();
        updateWorkingMeta();
      }
    } finally {
      state.workingLoading = false;
    }
  }

  async function applyWorkingSensors(ids, opts = {}) {
    const uniq = dedupeIds(ids);
    if (!uniq.length) {
      throw new Error('Нет валидных датчиков');
    }
    pushDiagAction(`[working] apply ids=${uniq.length}`);
    const data = await requestJSON('POST', '/api/v2/job/sensors', { sensors: uniq });
    const accepted = (data?.sensors || uniq).map(Number).filter(Number.isFinite);
    const isDefault = !!data?.default;
    setWorkingLocal(accepted, isDefault);
    const rejected = (data?.rejected || []).length;
    if (rejected) {
      log(`Некоторые датчики отсутствуют (${rejected} шт.), они пропущены`, 'warn');
      setSensorsDialogError(`Пропущено: ${rejected} (нет в справочнике)`);
    }
    if (opts?.toast) {
      log(`Рабочий список обновлён: ${accepted.length} шт.`, true);
    }
    workingPicker.selected = new Set(accepted);
  }

  function parseSensorList(text) {
    const lines = (text || '').split(/\r?\n/).map(l => l.trim()).filter(Boolean);
    const valid = [];
    const rejected = [];
    const byName = sensorIndex.byName;
    lines.forEach((line) => {
      if (!line) return;
      const num = Number(line);
      if (Number.isFinite(num) && sensorIndex.byId.has(num)) {
        valid.push(num);
        return;
      }
      const id = byName.get(line.toLowerCase());
      if (id !== undefined) {
        valid.push(id);
        return;
      }
      rejected.push(line);
    });
    return { valid: dedupeIds(valid), rejected };
  }

  let chartValuePrecision = 3;
  let tableValuePrecision = 3;
  let tableRenderTimer = null;
  let tableFilterTimer = null;
  let chartUpdateTimer = null;
  const chartMaxSeries = 30;
  const chartAutoAddLimit = 30;
  let rangeSensorCount = Infinity;
  let rangeSensorCountKnown = false;

  function clamp(v, min, max) {
    return Math.min(Math.max(v, min), max);
  }

  function itemHasValue(item, hadValue = false) {
    if (!item || typeof item !== 'object') return hadValue;
    if (item.value !== undefined && item.value !== null) return true;
    if (item.has_value !== undefined) return !!item.has_value || hadValue;
    if (item.hasValue !== undefined) return !!item.hasValue || hadValue;
    return hadValue;
  }

  function normalizeUpdates(msg) {
    if (Array.isArray(msg?.u)) {
      return msg.u
        .map((row) => {
          const id = Number(row?.[0]);
          if (!Number.isFinite(id)) return null;
          const value = row?.[1];
          const has = (row?.length || 0) > 2 ? row[2] !== 0 : true;
          return { id, value, has_value: has };
        })
        .filter(Boolean);
    }
    if (Array.isArray(msg?.updates)) return msg.updates;
    if (Array.isArray(msg?.Updates)) return msg.Updates;
    return [];
  }

  function toStepValue(v) {
    if (v === null || v === undefined) return 0;
    const num = Number(v);
    if (!Number.isFinite(num)) return 0;
    return num > 0 ? 1 : 0;
  }

  function formatChartValue(v) {
    if (v === null || v === undefined) return '0';
    const num = Number(v);
    if (!Number.isFinite(num)) return '0';
    return num.toFixed(chartValuePrecision);
  }

  function formatTableValue(v) {
    if (v === null || v === undefined) return '0';
    const num = Number(v);
    if (!Number.isFinite(num)) return '0';
    return num.toFixed(tableValuePrecision);
  }

    function log(message, state = true) {
      const level = typeof state === 'string' ? state : (state ? 'ok' : 'err');
      const row = document.createElement('div');
      row.className = `log-entry ${level}`;
      row.innerHTML = `<div class="ts">${new Date().toLocaleTimeString()}</div><div>${message}</div>`;
      els.log.prepend(row);
      while (els.log.children.length > 200) {
        els.log.removeChild(els.log.lastChild);
      }
      pushDiagAction(`[${new Date().toLocaleTimeString()}] [log] ${message}`);
    }

    function trackWsBytes(n) {
      const now = Date.now();
      state.wsBytes.push({ t: now, n });
      // Оставляем последние 5 секунд.
      const cutoff = now - 5000;
      while (state.wsBytes.length && state.wsBytes[0].t < cutoff) {
        state.wsBytes.shift();
      }
    }

    function formatSpeed(bytesPerSec) {
      if (!Number.isFinite(bytesPerSec) || bytesPerSec <= 0) return '—';
      const kb = 1024;
      const mb = kb * 1024;
      if (bytesPerSec >= mb) return `${(bytesPerSec / mb).toFixed(1)} MB/s`;
      if (bytesPerSec >= kb) return `${(bytesPerSec / kb).toFixed(1)} kB/s`;
      return `${bytesPerSec.toFixed(0)} B/s`;
    }

    function updateWsChip() {
      if (!els.wsSpeed) return;
      const now = Date.now();
      const cutoff = now - 5000;
      state.wsBytes = state.wsBytes.filter(item => item.t >= cutoff);
      const total = state.wsBytes.reduce((acc, item) => acc + item.n, 0);
      const windowSec = 5;
      const speed = total / windowSec;
      const online = !!state.ws;
      els.wsSpeed.textContent = `ws ${online ? formatSpeed(speed) : '—'}`;
      els.wsSpeed.classList.toggle('ok', online);
      els.wsSpeed.classList.toggle('warn', !online);
    }

    function setTab(tab) {
      els.tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
      Object.entries(els.panels).forEach(([name, node]) => {
        if (!node) return;
        node.classList.toggle('active', name === tab);
      });
      if (tab === 'charts') {
        setTimeout(() => {
          rebuildChart(true);
          if (!chartState.chartStep) {
            const hasRange = chartState.range.from && chartState.range.to;
            rebuildStepChart(hasRange);
          }
        }, 0);
      }
    }

    function connectWS() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const host = location.host || 'localhost:8080';
      const url = `${proto}://${host}/api/v2/ws/state`;
      try {
        const ws = new WebSocket(url);
        state.ws = ws;
        ws.onopen = () => {
          state.wsBytes = [];
          updateWsChip();
          log('WS: connected');
          loadWorkingSensors().catch(() => {});
        };
        ws.onclose = () => {
          state.ws = null;
          state.wsBytes = [];
          updateWsChip();
          if (state.reconnectIn) clearTimeout(state.reconnectIn);
          state.reconnectIn = setTimeout(connectWS, 2000);
        };
        ws.onerror = () => ws.close();
        ws.onmessage = (ev) => {
          if (typeof ev.data === 'string') {
            trackWsBytes(ev.data.length);
          } else if (ev.data && typeof ev.data.size === 'number') {
            // Blob-like
            trackWsBytes(ev.data.size);
          } else if (ev.data && ev.data.byteLength) {
            trackWsBytes(ev.data.byteLength);
          }
          try {
            const msg = JSON.parse(ev.data);
            handleWSMessage(msg);
          } catch (err) {
            log(`WS parse: ${err.message}`, false);
            fetchSnapshotFallback();
            ws.close();
          }
        };
      } catch (err) {
        log(`WS connect: ${err.message}`, false);
      }
    }

    function unixToISO(v) {
      if (!Number.isFinite(v) || v <= 0) return '';
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function handleWSMessage(msg) {
      if (!msg || typeof msg !== 'object') return;
      if (msg.controller_present !== undefined) {
        state.controllerPresent = !!msg.controller_present;
      }
      if (msg.control_timeout_sec !== undefined) {
        state.controlTimeoutSec = Number(msg.control_timeout_sec) || state.controlTimeoutSec;
      }
      if (state.controllerPresent && !state.isController) {
        state.controlLocked = true;
      }
      updateControlLockUI();
      const tsStr = msg.step_ts || unixToISO(msg.step_unix);
      if (msg.step_id !== undefined) {
        tableState.lastStep = msg.step_id || 0;
      }
      if (tsStr) {
        tableState.lastTs = tsStr;
        state.pausedAtTs = tsStr;
      }
    const normalizedUpdates = normalizeUpdates(msg);
      switch (msg.type) {
      case 'reset':
        tableState.rows.clear();
        seedTableFromMeta();
        if (!sensorIndex.hydrated) {
          preloadSensors().catch(() => {});
        }
        scheduleRenderTable(true);
        pushDiagAction('[ws] reset');
          break;
        case 'snapshot':
          applySnapshot(msg.updates || [], tsStr);
          appendChartPoint(tsStr, msg.updates || []);
          break;
        case 'updates':
          applyTableUpdates(normalizedUpdates, tsStr);
          appendChartPoint(tsStr, normalizedUpdates);
          break;
        default:
          break;
      }
      scheduleRenderTable();
    }

    function applySnapshot(list, tsStr) {
      if (!Array.isArray(list)) return;
      pushDiagAction(`[ws] snapshot rows=${list.length} ts=${tsStr || '-'}`);
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        registerSensorMeta(key, item.name, item.textname, item.iotype);
        const hasValue = itemHasValue(item);
        tableState.rows.set(key, {
          id: key,
          name: item.name || `${key}`,
          textname: item.textname || '',
          value: item.value,
          hasValue,
          stepID: tableState.lastStep || 0,
          ts: tsStr || '',
        });
      });
      refreshChartSuggestions();
    }

  function applyTableUpdates(list, tsStr) {
    if (!Array.isArray(list)) return;
    const now = Date.now();
      pushDiagAction(`[ws] updates rows=${list.length} ts=${tsStr || '-'}`);
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        const prev = tableState.rows.get(key) || {};
        const hadValue = prev.hasValue;
        const changed = !hadValue || prev.value !== item.value;
        const meta = tableState.meta.get(key) || {};
        const name = item.name || meta.name || prev.name || `${key}`;
        registerSensorMeta(key, name, item.textname || meta.textname || prev.textname, item.iotype || meta.iotype || prev.iotype);
        const hasValue = itemHasValue(item, hadValue);
        tableState.rows.set(key, {
          id: key,
          name,
          textname: item.textname || meta.textname || prev.textname || '',
          value: item.value,
          hasValue,
          stepID: item.step_id || tableState.lastStep || prev.stepID || 0,
          ts: tsStr || tableState.lastTs || prev.ts || '',
          changedAt: changed ? now : prev.changedAt,
        });
      });
      refreshChartSuggestions();
    }

    function scheduleRenderTable(force) {
      if (force) {
        if (tableRenderTimer) {
          clearTimeout(tableRenderTimer);
          tableRenderTimer = null;
        }
        renderTable(true);
        return;
      }
      if (tableRenderTimer) return;
      tableRenderTimer = setTimeout(() => {
        tableRenderTimer = null;
        renderTable();
      }, 50);
    }

    function clearTableFilter() {
      if (!els.table.filter) return;
      els.table.filter.value = '';
      tableState.filter = '';
      els.table.filter.blur();
      scheduleRenderTable(true);
    }

  function getFilteredTableRows(applySelected = true) {
    const filter = (tableState.filter || '').trim();
    const useMeta = !!filter;
    const workingOn = state.workingReady && state.workingSensors.length > 0;
    const inWorking = (id) => !workingOn || isWorkingSensor(id);
    const baseRows = useMeta
      ? Array.from(tableState.meta.entries()).map(([id, meta]) => {
            if (!inWorking(id)) return null;
            const row = tableState.rows.get(id) || {};
            const hasValue = !!row.hasValue;
            return {
              id,
              name: meta.name || `${id}`,
              textname: meta.textname || '',
              value: hasValue ? row.value : '—',
              hasValue,
              stepID: row.stepID,
              ts: row.ts,
              changedAt: row.changedAt,
            };
          }).filter(Boolean)
        : Array.from(tableState.rows.values()).filter(r => inWorking(r.id));
    let filtered = filter
      ? baseRows.filter(r => {
          const name = (r.name || '').toLowerCase();
          const textname = (r.textname || '').toLowerCase();
          return name.includes(filter) || textname.includes(filter);
          })
        : baseRows;
      const applySelection = applySelected && tableState.selected.size > 0 && !filter;
      if (applySelection) {
        filtered = filtered.filter(r => tableState.selected.has(r.id));
      }
      filtered.sort((a, b) => {
        if (a.name === b.name) return a.id - b.id;
        return a.name.localeCompare(b.name);
      });
      return filtered;
    }

  function renderTable(force) {
    if (!els.table.body) return;
    const filtered = getFilteredTableRows(true);
      const now = Date.now();
      const html = filtered.map(r => {
        const isChanged = r.changedAt && now - r.changedAt < 4000;
        const value = r.hasValue ? formatTableValue(r.value) : '—';
        const metaText = tableState.meta.get(r.id)?.textname || sensorIndex.byId.get(r.id)?.textname || '';
        const metaType = tableState.meta.get(r.id)?.iotype || sensorIndex.byId.get(r.id)?.iotype || '';
        const text = r.textname || metaText || '';
        const checked = tableState.selected.has(r.id) ? 'checked' : '';
        const rowClass = `${isChanged ? 'changed' : ''} ${checked ? 'selected' : ''}`;
        return `<tr class="${rowClass.trim()}">
          <td style="text-align:center;"><input type="checkbox" class="table-select" data-sensor="${r.id}" ${checked}></td>
          <td>${r.name || ''}</td>
          <td class="value">${value}</td>
          <td>${text}</td>
          <td style="text-align:center;">${metaType || ''}</td>
          <td style="text-align:center;"><button class="table-graph-btn" data-chart-add="${r.id}" title="Добавить на график">📊</button></td>
        </tr>`;
      }).join('');
      els.table.body.innerHTML = html || `<tr><td colspan="6" style="text-align:center; color:#94a3b8; padding:16px;">Нет данных</td></tr>`;
      if (els.table.meta) {
        const ts = tableState.lastTs || '—';
        const total = getFilteredTableRows(false).length;
        const sel = tableState.selected.size;
        els.table.meta.textContent = `Step: ${tableState.lastStep || '—'} · ${ts} · ${filtered.length}/${total} строк · Выбрано: ${sel}`;
      }
      if (els.table.filter) {
        setDisabled(els.table.filter, false);
      }
      if (els.table.precision) {
        els.table.precision.value = String(tableState.precision ?? 3);
      }
      if (els.table.selectAll) {
        const base = getFilteredTableRows(false);
        const allSelected = base.length > 0 && base.every(r => tableState.selected.has(r.id));
        els.table.selectAll.checked = allSelected && tableState.selected.size > 0;
        els.table.selectAll.indeterminate = tableState.selected.size > 0 && !allSelected;
      }
    }

  function setSensorsDialogError(msg) {
    if (!els.sensorsDialogError) return;
    els.sensorsDialogError.textContent = msg || '';
    if (msg) {
      els.sensorsDialogError.style.color = '#fbbf24';
    } else {
      els.sensorsDialogError.style.color = '#f87171';
    }
  }

  function setSensorsTab(tab) {
    workingPicker.tab = tab;
    if (!els.sensorsDialogTabs) return;
    els.sensorsDialogTabs.forEach(btn => btn.classList.toggle('active', btn.dataset.sensortab === tab));
    if (els.sensorsPanelExisting) els.sensorsPanelExisting.classList.toggle('active', tab === 'existing');
    if (els.sensorsPanelFile) els.sensorsPanelFile.classList.toggle('active', tab === 'file');
    setSensorsDialogError('');
    if (tab === 'existing') renderSensorsDialogTable();
    if (tab === 'file') updateSensorsFileMeta();
  }

  function renderSensorsDialogTable() {
    if (!els.sensorsDialogBody) return;
    const filter = (workingPicker.filter || '').trim().toLowerCase();
    const rows = [];
    sensorIndex.byId.forEach((meta, id) => {
      const name = meta.name || `${id}`;
      const text = meta.textname || '';
      const type = (meta.iotype || '').toUpperCase();
      if (filter && !name.toLowerCase().includes(filter) && !text.toLowerCase().includes(filter)) return;
      rows.push({ id, name, text, type });
    });
    rows.sort((a, b) => {
      if (a.name === b.name) return a.id - b.id;
      return a.name.localeCompare(b.name);
    });
    const html = rows.map(r => {
      const checked = workingPicker.selected.has(r.id) ? 'checked' : '';
      return `<tr>
        <td style="text-align:center;"><input type="checkbox" class="dlg-select" data-sensor="${r.id}" ${checked}></td>
        <td>${r.name}</td>
        <td>${r.text || ''}</td>
        <td style="text-align:center;">${r.type || ''}</td>
      </tr>`;
    }).join('');
    els.sensorsDialogBody.innerHTML = html || `<tr><td colspan="4" style="text-align:center; color:#94a3b8; padding:10px;">Нет датчиков</td></tr>`;
    if (els.sensorsDialogMeta) {
      const total = sensorIndex.byId.size;
      const filtered = rows.length;
      const sel = workingPicker.selected.size;
      els.sensorsDialogMeta.textContent = `Выбрано: ${sel} · Отфильтровано: ${filtered}/${total}`;
    }
    if (els.sensorsSelectAll) {
      const allSelected = rows.length > 0 && rows.every(r => workingPicker.selected.has(r.id));
      els.sensorsSelectAll.checked = allSelected && workingPicker.selected.size > 0;
      els.sensorsSelectAll.indeterminate = workingPicker.selected.size > 0 && !allSelected;
    }
  }

  function updateSensorsFileMeta() {
    if (!els.sensorsFileMeta) return;
    const parsed = parseSensorList(workingPicker.fileText || '');
    workingPicker.fileParsed = parsed;
    if (!workingPicker.fileText.trim()) {
      els.sensorsFileMeta.textContent = 'Загрузите файл или вставьте список.';
      return;
    }
    const totalLines = (workingPicker.fileText || '').split(/\r?\n/).filter(Boolean).length;
    const warn = parsed.rejected.length ? `; отклонено: ${parsed.rejected.length}` : '';
    els.sensorsFileMeta.textContent = `Строк: ${totalLines}; валидных: ${parsed.valid.length}${warn}`;
  }

  function syncPickerSelectionFromWorking() {
    workingPicker.selected = new Set(state.workingSensors || []);
    renderSensorsDialogTable();
  }

  function openSensorsDialog() {
    setSensorsDialogError('');
    workingPicker.filter = '';
    if (els.sensorsFilter) els.sensorsFilter.value = '';
    syncPickerSelectionFromWorking();
    if (state.workingDefault) {
      workingPicker.selected.clear();
      renderSensorsDialogTable();
    }
    setSensorsTab('existing');
    if (els.sensorsFileArea) {
      els.sensorsFileArea.value = '';
      workingPicker.fileText = '';
      updateSensorsFileMeta();
    }
    if (els.sensorsDialog) {
      els.sensorsDialog.showModal();
    }
  }

  async function applySensorsDialog(activeTab) {
    setSensorsDialogError('');
    if (activeTab === 'file') {
      updateSensorsFileMeta();
      const parsed = workingPicker.fileParsed || parseSensorList(workingPicker.fileText || '');
      if (!parsed.valid.length) {
        setSensorsDialogError(parsed.rejected.length ? 'Ни одного валидного датчика в списке' : 'Список пуст');
        return;
      }
      try {
        await applyWorkingSensors(parsed.valid, { toast: true });
        if (parsed.rejected.length) {
          log(`Пропущено ${parsed.rejected.length} строк: нет таких датчиков`, 'warn');
        }
        if (els.sensorsDialog) els.sensorsDialog.close();
      } catch (err) {
        setSensorsDialogError(err.message);
      }
      return;
    }
    // existing
    const ids = Array.from(document.querySelectorAll('input.dlg-select:checked'))
      .map((n) => Number(n.getAttribute('data-sensor')))
      .filter(Number.isFinite);
    if (!ids.length) {
      setSensorsDialogError('Нужно выбрать хотя бы один датчик');
      return;
    }
    try {
      await applyWorkingSensors(ids, { toast: true });
      if (els.sensorsDialog) els.sensorsDialog.close();
    } catch (err) {
      setSensorsDialogError(err.message);
      return;
    }
  }

    const chartColors = ['#22d3ee', '#34d399', '#f59e0b', '#f472b6', '#a78bfa', '#f87171', '#4ade80', '#60a5fa'];

    function pickChartColor(id, usedColors, idxHint) {
      const used = usedColors || new Set();
      for (let i = 0; i < chartColors.length; i++) {
        const color = chartColors[(idxHint + i) % chartColors.length];
        if (!used.has(color.toLowerCase())) return color;
      }
      const hue = (Number(id) * 37 + (idxHint || 0) * 53) % 360;
      const color = `hsl(${hue}, 68%, 58%)`;
      if (!used.has(color.toLowerCase())) return color;
      const alt = `hsl(${(hue + 27) % 360}, 68%, 58%)`;
      return alt;
    }

    function normalizeHexColor(color) {
      if (typeof color !== 'string') return '#22d3ee';
      let hex = color.trim();
      const shortHex = /^#([0-9a-fA-F]{3})$/;
      const fullHex = /^#([0-9a-fA-F]{6})$/;
      if (shortHex.test(hex)) {
        const expanded = hex.slice(1).split('').map(c => c + c).join('');
        return `#${expanded}`;
      }
      if (fullHex.test(hex)) return hex;
      try {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.fillStyle = hex;
        const computed = ctx.fillStyle;
        if (fullHex.test(computed)) return computed;
      } catch (_) {
        /* ignore */
      }
      return '#22d3ee';
    }

    function chartLabelByID(id) {
      const meta = tableState.meta.get(id) || sensorIndex.byId.get(id) || {};
      if (meta.name) return `${meta.name} (${id})`;
      return `${id}`;
    }

    function registerSensorMeta(id, name, textname, iotype) {
      if (!Number.isFinite(id)) return;
      const prev = tableState.meta.get(id) || {};
      const resolvedName = name || prev.name || `${id}`;
      const resolvedText = textname !== undefined ? textname : prev.textname;
      const resolvedIO = iotype !== undefined ? iotype : prev.iotype;
      tableState.meta.set(id, { name: resolvedName, textname: resolvedText || '', iotype: resolvedIO || '' });
      sensorIndex.byId.set(id, { id, name: resolvedName, textname: resolvedText || '', iotype: resolvedIO || '' });
      sensorIndex.byName.set(String(resolvedName).toLowerCase(), id);
    }

    function knownSensorIdByToken(token) {
      if (!token) return null;
      const num = Number(token);
      if (Number.isFinite(num) && sensorIndex.byId.has(num)) {
        return num;
      }
      const byName = sensorIndex.byName.get(token.toLowerCase());
      return Number.isFinite(byName) ? byName : null;
    }

    function parseChartSensors(input) {
      if (!input) return [];
      const tokens = input.split(',').map(t => t.trim()).filter(Boolean);
      if (!tokens.length) return [];
      const out = [];
      tokens.forEach(tok => {
        const id = knownSensorIdByToken(tok);
        if (Number.isFinite(id)) out.push(id);
      });
      return Array.from(new Set(out));
    }

    function normalizeSensorList(list) {
      if (!Array.isArray(list)) return [];
      const res = [];
      list.forEach((id) => {
        const num = Number(id);
        if (!Number.isFinite(num)) return;
        if (!sensorIndex.byId.has(num)) {
        registerSensorMeta(num, `${num}`, '', '');
        }
        if (sensorIndex.byId.has(num)) res.push(num);
      });
      return Array.from(new Set(res));
    }

    function rebuildChartSeries() {
      const prev = chartState.datasets;
      const next = new Map();
      const used = new Set();
      chartState.selected.forEach((id, idx) => {
        const existing = prev.get(id);
        const preserved = existing?.color;
        const color = preserved || pickChartColor(id, used, idx);
        if (color) used.add(color.toLowerCase());
        const data = existing?.data ? existing.data.slice() : [];
        const lastValue = existing?.lastValue ?? null;
        const lastTs = existing?.lastTs ?? null;
        const iotype = existing?.iotype || getSensorType(id);
        next.set(id, {
          id,
          label: chartLabelByID(id),
          color,
          data: data ? data.slice() : [],
          lastValue,
          lastTs,
          iotype,
        });
      });
      chartState.datasets = next;
      if (chartState.chart) {
        scheduleChartSync();
      } else {
        rebuildChart();
      }
    }

    function updateChartMeta(msg) {
      if (!els.charts.meta) return;
      const sensors = chartState.selected.length ? chartState.selected.map(chartLabelByID).join(', ') : '—';
      const points = chartState.chart
        ? (chartState.chart.data.labels?.length || 0)
        : Array.from(chartState.datasets.values()).reduce((acc, ds) => Math.max(acc, ds.data?.length || 0), 0);
      let metaText = chartState.selected.length ? `Точек: ${points}` : 'Нет данных';
      if (chartState.range.from && chartState.range.to) {
        const from = new Date(chartState.range.from).toISOString().replace(/\.\d{3}Z$/, 'Z');
        const to = new Date(chartState.range.to).toISOString().replace(/\.\d{3}Z$/, 'Z');
        metaText += ` · X: ${from} → ${to}`;
      }
      els.charts.meta.textContent = metaText;
      if (msg) {
        els.charts.meta.textContent += ` · ${msg}`;
      }
      if (els.charts.empty) {
        const showEmpty = !chartState.selected.length || points === 0;
        const autoAddNote = rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit
          ? ` · автодобавление отключено (${rangeSensorCount} датчиков, лимит ${chartAutoAddLimit})`
          : '';
        els.charts.empty.textContent = chartState.selected.length
          ? `Нет данных для отображения${autoAddNote}`
          : `Выберите датчики для графика${autoAddNote}`;
        els.charts.empty.style.display = showEmpty ? 'flex' : 'none';
      }
      if (chartState.selected.length > chartMaxSeries) {
        els.charts.meta.textContent += ` · Max ${chartMaxSeries} линий`;
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.checked = chartState.autoUpdate;
      }
      if (els.charts.window) {
        els.charts.window.value = chartState.windowSec;
      }
    }

    function renderLegendTable() {
      if (!els.charts.legendBody) return;
      try {
        const rows = chartState.selected.map((id) => {
          const ds = chartState.datasets.get(id) || {};
          const val = formatChartValue(ds.lastValue);
          const color = ds.color || '#22d3ee';
          const ts = ds.lastTs ? toRFC3339(new Date(ds.lastTs)) : '—';
          const text = (sensorIndex.byId.get(id)?.textname) || '—';
          const muted = chartState.focused !== null && chartState.focused !== id;
          const rowClass = muted ? 'legend-muted' : 'legend-active';
          return `<tr data-sensor="${id}" class="${rowClass}"><td><button class="chart-color-btn" data-sensor="${id}" style="background:${color};"></button></td><td>${chartLabelByID(id)}</td><td>${val}</td><td>${ts}</td><td>${text}</td><td style="text-align:right;"><button class="ghost chart-remove-btn" data-sensor="${id}" type="button" style="padding:6px 10px;">✕</button></td></tr>`;
        }).join('');
        els.charts.legendBody.innerHTML = rows || '<tr><td colspan="6" style="color:#94a3b8;">Нет выбранных датчиков</td></tr>';
      } catch (err) {
        els.charts.legendBody.innerHTML = `<tr><td colspan="6" style="color:#f87171;">${err?.message || err}</td></tr>`;
      }
    }

    function openColorDialog(id) {
      const dlg = els.charts.colorDialog;
      const input = els.charts.colorInput;
      if (!dlg || !input) return;
      const ds = chartState.datasets.get(id);
      if (!ds) return;
      const color = normalizeHexColor(ds.color || '#22d3ee');
      input.value = color;
      dlg.dataset.sensor = String(id);
      if (!dlg.open) {
        dlg.showModal();
      } else {
        input.focus();
      }
    }

  function refreshChartSuggestions() {
    const opts = [];
    const usedValues = new Set();
    sensorIndex.byId.forEach((meta, id) => {
        if (!isWorkingSensor(id)) return;
      if (chartState.selected.includes(id)) return; // уже на графике
      const label = meta?.name ? `${meta.name}` : `${id}`;
      const val = meta?.name || `${id}`;
      if (!val || usedValues.has(val)) return;
      usedValues.add(val);
        opts.push({ value: val, label: `${label} (${id})` });
      });
      renderChartSuggestions(els.charts.sensors?.value || '');
      updateChartInputState();
    }

  function renderChartSuggestions(query) {
    if (!els.charts.suggestBox) return;
    const q = (query || '').trim().toLowerCase();
    const sameQuery = q === (chartState.suggest.lastQuery || '');
    if (chartState.suggest.locked && sameQuery && els.charts.suggestBox.style.display === 'block') {
        updateChartInputState();
        return; // не сбрасываем выделение, пока пользователь навигирует по списку
      }
      chartState.suggest.lastQuery = q;
      chartState.suggest.locked = false;
    const items = [];
    let availableCount = 0;
    sensorIndex.byId.forEach((meta, id) => {
        if (!isWorkingSensor(id)) return;
        if (chartState.selected.includes(id)) return;
        const name = meta?.name || `${id}`;
        const text = name.toLowerCase();
        if (q && !text.includes(q) && !String(id).includes(q)) return;
        items.push({ id, name });
        availableCount++;
      });
      if (!q) {
        hideChartSuggestions();
        updateChartInputState(availableCount);
        return;
      }
      items.sort((a, b) => a.name.localeCompare(b.name));
      const limited = items.slice(0, 50);
      if (!limited.length) {
        els.charts.suggestBox.style.display = 'none';
        els.charts.suggestBox.innerHTML = '';
        updateChartInputState(availableCount);
        return;
      }
      chartState.suggest.items = limited;
      chartState.suggest.active = limited.length ? 0 : -1;
      const highlight = (str) => {
        if (!q) return str;
        const idx = str.toLowerCase().indexOf(q);
        if (idx === -1) return str;
        const before = str.slice(0, idx);
        const match = str.slice(idx, idx + q.length);
        const after = str.slice(idx + q.length);
        return `${before}<span class="chart-suggestion-highlight">${match}</span>${after}`;
      };
      els.charts.suggestBox.innerHTML = limited.map((item, idx) => {
        const activeClass = idx === chartState.suggest.active ? 'active' : '';
        return `<div class="chart-suggest-item ${activeClass}" data-sensor="${item.id}">${highlight(item.name)} <span style="color:#94a3b8;">(${item.id})</span></div>`;
      }).join('');
      els.charts.suggestBox.style.display = 'block';
      updateChartInputState(availableCount);
    }

    function hideChartSuggestions() {
      if (!els.charts.suggestBox) return;
      els.charts.suggestBox.style.display = 'none';
      els.charts.suggestBox.innerHTML = '';
      chartState.suggest = { items: [], active: -1, locked: false, lastQuery: chartState.suggest.lastQuery || '' };
    }

    function moveSuggestActive(delta) {
      const items = chartState.suggest.items || [];
      if (!items.length || !els.charts.suggestBox) return;
      chartState.suggest.locked = true;
      const next = (chartState.suggest.active + delta + items.length) % items.length;
      chartState.suggest.active = next;
      Array.from(els.charts.suggestBox.children).forEach((el, idx) => {
        el.classList.toggle('active', idx === next);
      });
    }

    function buildChartDatasets() {
      return Array.from(chartState.datasets.values())
        .filter(ds => isAnalogIO(ds.iotype) && isAnalogSensor(ds.id))
        .map(ds => ({
        label: ds.label,
        data: ds.data,
        borderColor: ds.color || '#22d3ee',
        backgroundColor: els.charts.fill?.checked ? hexToRGBA(ds.color || '#22d3ee', 0.15) : ds.color || '#22d3ee',
        tension: chartState.smooth ? 0.25 : 0,
        spanGaps: true,
        pointRadius: 0,
        borderWidth: 1,
        fill: !!(els.charts.fill && els.charts.fill.checked),
        hidden: chartState.focused !== null && chartState.focused !== ds.id,
      }));
    }

    function getStepOffsets() {
      const offsets = new Map();
      const discrete = chartState.selected.filter(isDiscreteSensor);
      discrete.forEach((id, idx) => offsets.set(id, idx));
      return offsets;
    }

    function buildStepDatasets() {
      const offsets = getStepOffsets();
      const used = new Set(Array.from(chartState.datasets.values()).map(ds => (ds.color || '').toLowerCase()).filter(Boolean));
      const discreteIds = chartState.selected.filter(isDiscreteSensor);
      return discreteIds.map((id, idx) => {
        const ds = chartState.datasets.get(id) || {};
        const color = ds.color || pickChartColor(id, used, idx) || '#22d3ee';
        if (color) used.add(color.toLowerCase());
        return {
          label: ds.label || chartLabelByID(id),
          data: (ds.data || []).map(p => {
            const step = toStepValue(p.y);
            const offset = (offsets.get(id) || 0) * 2;
            return { x: p.x, y: step === null ? null : offset + step };
          }),
          borderColor: color,
          backgroundColor: 'transparent',
          tension: 0,
          stepped: true,
          spanGaps: true,
          pointRadius: 0,
          borderWidth: 1,
          fill: false,
          hidden: chartState.focused !== null && chartState.focused !== id,
        };
      });
    }

    function hexToRGBA(hex, alpha) {
      if (!hex) return hex;
      const h = hex.replace('#', '');
      const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateChartInputState(availableCount) {
      if (!els.charts.sensors) return;
      const totalAvailable = availableCount !== undefined ? availableCount : Math.max(sensorIndex.byId.size - chartState.selected.length, 0);
      // Не блокируем поле, чтобы можно было вводить даже при пустых подсказках.
      els.charts.sensors.disabled = false;
      if (els.charts.sensors.parentElement) {
        els.charts.sensors.parentElement.classList.remove('input-disabled');
      }
      if (totalAvailable <= 0) hideChartSuggestions();
    }

    function syncChartData() {
      const hasRange = chartState.range.from && chartState.range.to;
      if (chartState.chart) {
        chartState.chart.data.labels = extractChartLabels();
        chartState.chart.data.datasets = buildChartDatasets();
        chartState.chart.options.scales.x.min = hasRange ? chartState.range.from : undefined;
        chartState.chart.options.scales.x.max = hasRange ? chartState.range.to : undefined;
        chartState.chart.update('none');
      }
      if (chartState.chartStep) {
        chartState.chartStep.data.labels = extractChartLabels();
        chartState.chartStep.data.datasets = buildStepDatasets();
        chartState.chartStep.options.scales.x.min = hasRange ? chartState.range.from : undefined;
        chartState.chartStep.options.scales.x.max = hasRange ? chartState.range.to : undefined;
        const tracks = Math.max(chartState.selected.filter(isDiscreteSensor).length, 1);
        chartState.chartStep.options.scales.y.min = 0;
        chartState.chartStep.options.scales.y.max = tracks * 2;
        chartState.chartStep.update('none');
      }
      updateChartMeta();
      renderLegendTable();
    }

    function rebuildStepChart(hasRange) {
      if (!els.charts.stepCanvas) return;
      const container = els.charts.stepCanvas.parentElement || els.charts.stepCanvas;
      const rawW = container.clientWidth || container.offsetWidth || 0;
      const rawH = container.clientHeight || container.offsetHeight || 0;
      const width = Math.max(320, Math.floor(rawW || 800));
      const height = Math.max(160, Math.floor(rawH || 200));
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return;
      }
      destroyStepChart();
      if (!window.Chart) return;
      const ctx = els.charts.stepCanvas.getContext('2d');
      els.charts.stepCanvas.width = width;
      els.charts.stepCanvas.height = height;
      const labels = extractChartLabels();
      const datasets = buildStepDatasets();
      const tracks = Math.max(chartState.selected.filter(isDiscreteSensor).length, 1);
      chartState.chartStep = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          animation: false,
          responsive: false,
          maintainAspectRatio: false,
          parsing: false,
          resizeDelay: 0,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'second',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm:ss',
                  hour: 'HH:mm',
                  day: 'yyyy-MM-dd',
                  week: 'yyyy-MM-dd',
                  month: 'yyyy-MM',
                  quarter: 'yyyy-MM',
                  year: 'yyyy',
                },
              },
              min: hasRange ? chartState.range.from : undefined,
              max: hasRange ? chartState.range.to : undefined,
              ticks: { color: '#94a3b8' },
              grid: { color: 'rgba(255,255,255,0.05)' },
            },
            y: {
              ticks: {
                color: '#94a3b8',
                stepSize: 1,
                callback: (val) => {
                  if (!Number.isInteger(val)) return '';
                  return val % 2 === 0 ? '0' : '1';
                },
              },
              min: 0,
              max: tracks * 2,
              grid: {
                color: 'rgba(255,255,255,0.05)',
                borderColor: 'rgba(255,255,255,0.08)',
              },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: true,
              displayColors: false,
              mode: 'nearest',
              intersect: false,
              position: 'nearest',
              callbacks: {
                title: (items) => {
                  const ts = items?.[0]?.parsed?.x;
                  if (!Number.isFinite(ts)) return '';
                  return new Date(ts).toISOString().replace(/\.\d{3}Z$/, 'Z');
                },
                label: (ctx) => {
                  const v = Number.isFinite(ctx.parsed.y) ? ctx.parsed.y % 2 : 0;
                  const val = v === 1 ? '1' : '0';
                  return `${ctx.dataset?.label || ''}: ${val}`.trim();
                },
              },
            },
          },
        },
      });
    }

    function scheduleChartSync() {
      if (!chartState.chart) {
        rebuildChart();
        return;
      }
      if (chartUpdateTimer) return;
      chartUpdateTimer = setTimeout(() => {
        chartUpdateTimer = null;
        syncChartData();
      }, 150);
    }

    function rebuildChart(force = false) {
      if (!els.charts.canvas) return;
      if (!chartState.selected.length) {
        destroyChart();
        updateChartMeta();
        renderLegendTable();
        return;
      }
      if (chartState.selected.length > chartMaxSeries) {
        log(`На графике можно держать не более ${chartMaxSeries} датчиков одновременно`, false);
        chartState.selected = chartState.selected.slice(0, chartMaxSeries);
      }
      const hasRange = chartState.range.from && chartState.range.to;
      const panelVisible = els.panels?.charts?.classList.contains('active');
      const container = els.charts.canvas.parentElement || els.charts.canvas;
      const rawW = container.clientWidth || container.offsetWidth || 0;
      const rawH = container.clientHeight || container.offsetHeight || 0;
      const width = Math.max(320, Math.floor(rawW || 800));
      const height = Math.max(300, Math.floor(rawH || 420));
      if (!panelVisible && !force) {
        const reason = `hidden:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: panel hidden', { panelVisible, width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        const reason = `invalid:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: invalid size', { width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      destroyChart();
      destroyStepChart();
      chartState.lastSkip = '';
      if (!window.Chart) {
        console.error('[chart] Chart.js not loaded');
        return;
      }
      const ctx = els.charts.canvas.getContext('2d');
      els.charts.canvas.width = width;
      els.charts.canvas.height = height;
      const labels = extractChartLabels();
      const datasets = buildChartDatasets();
      chartState.chart = new Chart(ctx, {
        type: 'line',
        data: {labels, datasets},
        options: {
          animation: false,
          responsive: false,
          maintainAspectRatio: false,
          parsing: false,
          resizeDelay: 0,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'second',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm:ss',
                  hour: 'HH:mm',
                  day: 'yyyy-MM-dd',
                  week: 'yyyy-MM-dd',
                  month: 'yyyy-MM',
                  quarter: 'yyyy-MM',
                  year: 'yyyy',
                },
              },
              min: hasRange ? chartState.range.from : undefined,
              max: hasRange ? chartState.range.to : undefined,
              ticks: {color: '#94a3b8'},
              grid: {color: 'rgba(255,255,255,0.05)'},
            },
            y: {
              ticks: {color: '#94a3b8'},
              grid: {
                color: (ctx) => {
                  if (ctx.tick && ctx.tick.value === 0) return '#ffffff';
                  return 'rgba(255,255,255,0.05)';
                },
                borderColor: 'rgba(255,255,255,0.08)',
              },
            },
          },
          plugins: {
            legend: {display: false},
            tooltip: {
              mode: 'nearest',
              intersect: false,
              callbacks: {
                title: (items) => items.length ? new Date(items[0].parsed.x).toISOString() : '',
                label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y ?? '—'}`,
              },
            },
            zoom: {
              zoom: {wheel: {enabled: false}, pinch: {enabled: false}, mode: 'x'},
              pan: {enabled: false},
            },
          },
          interaction: {mode: 'nearest', intersect: false},
        },
      });
      chartLog('rebuild chart', { width, height, datasets: chartState.datasets.size });
      rebuildStepChart(hasRange);
      updateChartMeta();
      renderLegendTable();
    }

    function destroyChart() {
      const existing = (window.Chart && typeof Chart.getChart === 'function') ? Chart.getChart(els.charts.canvas) : null;
      if (existing) existing.destroy();
      if (chartState.chart) {
        chartState.chart.destroy();
        chartState.chart = null;
      }
    }

    function destroyStepChart() {
      const existing = (window.Chart && typeof Chart.getChart === 'function') ? Chart.getChart(els.charts.stepCanvas) : null;
      if (existing) existing.destroy();
      if (chartState.chartStep) {
        chartState.chartStep.destroy();
        chartState.chartStep = null;
      }
    }

    function extractChartLabels() {
      const labels = new Set();
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => labels.add(p.x));
      });
      return Array.from(labels).sort((a, b) => a - b);
    }

    function resetChartZoom() {
    }

    function autoZoomY() {
      if (!chartState.chart) return;
      let minY = Infinity;
      let maxY = -Infinity;
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => {
          if (p.y == null) return;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        });
      });
      if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
        minY = 0; maxY = 1;
      }
      chartState.chart.options.scales.y.min = minY;
      chartState.chart.options.scales.y.max = maxY;
      chartState.chart.update('none');
      updateChartMeta();
    }

    function trimDataset(ds, currentTs) {
      // Если известен диапазон from/to — отбрасываем всё, что за его пределами.
      if (chartState.range.from && chartState.range.to) {
        ds.data = ds.data.filter(p => p.x >= chartState.range.from && p.x <= chartState.range.to);
        return;
      }
      if (!chartState.windowSec || chartState.windowSec <= 0) return;
      const threshold = currentTs - chartState.windowSec * 1000;
      ds.data = ds.data.filter(p => p.x >= threshold);
    }

    function decimateDataset(ds) {
      const max = chartState.maxPoints;
      if (!ds || !Array.isArray(ds.data)) return;
      const len = ds.data.length;
      if (len <= max) return;
      const stride = Math.ceil(len / max);
      if (stride <= 1) return;
      const decimated = [];
      for (let i = 0; i < len; i += stride) {
        decimated.push(ds.data[i]);
      }
      // сохраняем последний элемент, если не попал
      const last = ds.data[len - 1];
      if (decimated[decimated.length - 1]?.x !== last.x) decimated.push(last);
      ds.data = decimated;
    }

    function truncateChartAfter(tsMs) {
      if (!Number.isFinite(tsMs)) return;
      let changed = false;
      chartState.datasets.forEach((ds) => {
        if (!ds || !Array.isArray(ds.data)) return;
        const filtered = ds.data.filter(p => Number.isFinite(p?.x) && p.x <= tsMs);
        if (filtered.length !== ds.data.length) {
          ds.data = filtered;
          const last = filtered[filtered.length - 1];
          ds.lastTs = last?.x || null;
          ds.lastValue = last?.y ?? null;
          changed = true;
        } else if (ds.lastTs && ds.lastTs > tsMs) {
          ds.lastTs = null;
          ds.lastValue = null;
          changed = true;
        }
      });
      if (changed) {
        scheduleChartSync();
        renderLegendTable();
        updateChartMeta();
      }
    }

    function appendChartPoint(tsStr, updates) {
      if (!tsStr) return;
      const canAutoAdd = rangeSensorCountKnown && rangeSensorCount > 0 && rangeSensorCount <= chartAutoAddLimit;
      if (!chartState.selected.length && canAutoAdd && updates?.length) {
        const ids = Array.from(new Set((updates || []).map(u => Number(u.id)).filter(Number.isFinite)));
        if (ids.length) {
          applyChartSensors(ids);
        }
      }
      if (!chartState.selected.length) return;
      if (chartState.selected.length >= chartAutoAddLimit && !updates?.length) return;
      if (!chartState.autoUpdate) return;
      if (els.charts.autoUpdate && !els.charts.autoUpdate.checked) return;
      const d = parseISO(tsStr);
      if (!d) return;
      const t = d.getTime();
      const hasFixedRange = chartState.range.from && chartState.range.to;
      if (hasFixedRange && (t < chartState.range.from || t > chartState.range.to)) {
        // За пределами выбранного диапазона отбрасываем.
        return;
      }
      const updateMap = new Map();
      (updates || []).forEach(item => {
        const id = Number(item.id);
        if (Number.isFinite(id)) updateMap.set(id, item.value);
      });
      const usedColors = new Set();
      chartState.datasets.forEach(ds => {
        if (ds.color) usedColors.add(String(ds.color).toLowerCase());
      });
      chartState.selected.forEach((id, idx) => {
        if (!chartState.datasets.has(id)) {
          const color = pickChartColor(id, usedColors, idx);
          chartState.datasets.set(id, {
            id,
            label: chartLabelByID(id),
            color,
            data: [],
            lastValue: null,
            lastTs: null,
          });
          usedColors.add(String(color).toLowerCase());
        }
        const ds = chartState.datasets.get(id);
        const val = updateMap.has(id) ? updateMap.get(id) : (ds.lastValue ?? 0);
        const numVal = Number.isFinite(Number(val)) ? Number(val) : 0;
        const y = numVal;
        ds.lastValue = y;
        ds.lastTs = t;
        ds.data.push({x: t, y});
        decimateDataset(ds);
        trimDataset(ds, t);
      });
      if (chartState.chart) {
        scheduleChartSync();
      } else {
        rebuildChart();
      }
    }

    function applyChartSensors(list) {
      if ((chartState.selected.length || 0) >= chartAutoAddLimit && !list.length) {
        // Если уже достаточно линий, не авто-добавляем новые без явного списка.
        return;
      }
      const normalized = normalizeSensorList(list || []);
      if (normalized.length > chartMaxSeries) {
        normalized.length = chartMaxSeries;
      }
      const withValues = normalized.filter(sensorHasValue);
      const picked = withValues.length ? withValues : normalized;
      chartState.selected = picked.slice(0, chartMaxSeries);
      if (chartState.focused !== null && !chartState.selected.includes(chartState.focused)) {
        chartState.focused = null;
      }
      if (els.charts.sensors) {
        els.charts.sensors.value = '';
      }
      rebuildChartSeries();
      hideChartSuggestions();
    }

    function sensorHasValue(id) {
      const row = tableState.rows.get(id);
      if (row && row.hasValue) return true;
      const ds = chartState.datasets.get(id);
      return ds && ds.lastValue !== undefined && ds.lastValue !== null;
    }

    function clearChart() {
      chartState.datasets.forEach((ds) => {
        ds.data = [];
        ds.lastValue = null;
        ds.lastTs = null;
      });
      if (chartState.chart) {
        syncChartData();
      } else {
        rebuildChart();
      }
      if (els.charts.sensors) els.charts.sensors.value = '';
    }

    function addSensorsFromInput() {
      const raw = els.charts.sensors?.value || '';
      const ids = parseChartSensors(raw);
      const filtered = ids.filter(id => !chartState.selected.includes(id));
      if (!filtered.length) {
        log('Датчики не найдены в подсказках/конфиге или уже добавлены', false);
        return;
      }
      const merged = Array.from(new Set([...chartState.selected, ...filtered]));
      applyChartSensors(merged);
      hideChartSuggestions();
    }

    function canAutoAddSensors(list) {
      const cnt = Array.isArray(list) ? list.length : 0;
      if (rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit) return false;
      if (cnt > chartAutoAddLimit) return false;
      return true;
    }

    function hydrateChartDefaultsFromParams() {
      if (chartState.selected.length) return;
      const params = state.model.params || state.model.Params || {};
      const sensors = params.Sensors || params.sensors;
      if (Array.isArray(sensors) && sensors.length && canAutoAddSensors(sensors)) {
        applyChartSensors(sensors);
      }
    }

    function paramsSignature(params) {
      if (!params) return '';
      const sensors = params.Sensors || params.sensors || [];
      const from = params.From || params.from;
      const to = params.To || params.to;
      return JSON.stringify({sensors, from, to});
    }

    function syncChartWithParams(params) {
      const sig = paramsSignature(params);
      const sensors = params?.Sensors || params?.sensors;
      const hasSensors = Array.isArray(sensors) && sensors.length;
      // Не затираем ручной выбор, если сервер не передал Sensors.
      if (!hasSensors && chartState.selected.length) return;
      if (sig && sig !== chartState.lastParamsSig) {
        chartState.lastParamsSig = sig;
        if (hasSensors && canAutoAddSensors(sensors)) {
          applyChartSensors(sensors);
        } else if (!chartState.selected.length) {
          clearChart();
        }
      }
    }

  function requestJSON(method, url, body) {
    const bodyStr = body !== undefined ? JSON.stringify(body) : '';
    const stamp = new Date().toLocaleTimeString();
    const tokenPrefix = state.sessionToken ? state.sessionToken.substring(0, 8) : 'none';
    pushDiagNet(`[${stamp}] [fetch] ${method} ${url} token=${tokenPrefix}... body=${bodyStr}`, { truncateForDiag: true });
    logUI(`fetch ${method} ${url} body=${bodyStr ? truncate(bodyStr, 200) : ''}`);
    const init = { method, headers: {} };
    if (state.sessionToken) {
      init.headers['X-TM-Session'] = state.sessionToken;
    }
    if (body !== undefined) {
      init.headers['Content-Type'] = 'application/json';
      init.body = bodyStr;
    }
    return fetch(url, init).then(async (resp) => {
      const text = await resp.text();
      let payload = null;
      if (text) { try { payload = JSON.parse(text); } catch (_) {} }
      const respMsg = `[${new Date().toLocaleTimeString()}] [fetch] ${method} ${url} -> ${resp.status} ${resp.statusText} ${text || '<empty>'}`;
      pushDiagNet(respMsg, { truncateForDiag: true });
      logUI(`fetch result ${resp.status} ${resp.statusText} payload=${text ? truncate(text, 200) : '<empty>'}`);
      if (!resp.ok) {
        if (resp.status === 403) {
          state.controlLocked = true;
          state.isController = false;
          state.canClaim = false;
          updateControls();
        }
        throw new Error(payload?.error || text || `HTTP ${resp.status}`);
      }
      return payload;
    });
    }

  async function initSession() {
    // Всегда запрашиваем новый session token при загрузке страницы,
    // чтобы каждая вкладка получила уникальную сессию.
    try {
      // КРИТИЧНО: Сбрасываем токен ДО запроса! При дублировании вкладки
      // браузер копирует JavaScript память включая state.sessionToken.
      // Если не сбросить - старый токен попадёт в заголовок запроса.
      const oldToken = state.sessionToken;
      state.sessionToken = '';
      console.log(`[INIT SESSION] requesting new session token... (clearing old=${oldToken.substring(0,8) || 'none'}...)`);
      pushDiagAction(`[init] requesting new session token... (clearing old=${oldToken.substring(0,8) || 'none'}...)`);
      // ВАЖНО: Добавляем уникальный параметр _t для cache-busting
      // чтобы браузер не использовал кэшированный ответ при дублировании вкладки
      const timestamp = Date.now() + Math.random();
      const resp = await fetch(`/api/v2/session?_t=${timestamp}`, {
        cache: 'no-store',
        // КРИТИЧНО: НЕ передаём X-TM-Session чтобы сервер сгенерировал НОВЫЙ токен
        headers: {
          'X-TM-Session': ''
        }
      });
      const data = await resp.json();
      if (!resp.ok) {
        throw new Error(data?.error || `HTTP ${resp.status}`);
      }
      const token = data.session || '';
      console.log(`[INIT SESSION] received token=${token} is_ctrl=${data.is_controller} ctrl_present=${data.controller_present}`);
      pushDiagAction(`[init] received token=${token.substring(0,8)}... is_ctrl=${data.is_controller} ctrl_present=${data.controller_present}`);
      state.sessionToken = token;
      state.controlTimeoutSec = data.control_timeout_sec || 0;
      state.controllerPresent = !!data.controller_present;
      // Если контроллера нет - можем управлять; если есть - проверяем что МЫ контроллер
      state.isController = !!data.is_controller || !state.controllerPresent;
      state.canClaim = !!data.can_claim;
      state.controlLocked = state.controllerPresent && !state.isController;
      console.log(`[INIT SESSION] => isCtrl=${state.isController} locked=${state.controlLocked}`);
      pushDiagAction(`[init] => isCtrl=${state.isController} locked=${state.controlLocked}`);
      updateControlLockUI();
      updateControls();
    } catch (err) {
      log(`Session init: ${err.message}`, false);
    }
  }

  async function keepAlive() {
    if (!state.sessionToken || !state.isController) return;
    try {
      await fetch('/api/v2/session?ping=1', { headers: { 'X-TM-Session': state.sessionToken } });
    } catch (err) {
      log(`Session ping: ${err.message}`, false);
    }
  }

  function mergeSensorsFromAPI(list) {
    if (!Array.isArray(list)) return;
    list.forEach((item) => {
      const id = Number(item.id);
      if (!Number.isFinite(id)) return;
      registerSensorMeta(id, item.name, item.textname, item.iotype);
    });
    seedTableFromMeta();
    refreshChartSuggestions();
  }

  function seedTableFromMeta() {
    sensorIndex.byId.forEach((meta, id) => {
      if (!tableState.rows.has(id)) {
        tableState.rows.set(id, {
          id,
          name: meta.name || `${id}`,
          textname: meta.textname || '',
          value: undefined,
          hasValue: false,
          stepID: tableState.lastStep || 0,
          ts: tableState.lastTs || '',
        });
      }
    });
    scheduleRenderTable(true);
  }

    async function fetchSnapshotFallback() {
      try {
        const tsDate = currentTsFromServer();
        const ts = tsDate ? toRFC3339(tsDate) : '';
        if (!ts) return;
        const data = await requestJSON('POST', '/api/v2/snapshot', { ts });
        const updates = data?.updates || data?.Updates || [];
        const stepTs = data?.step_ts || data?.StepTS || '';
        applySnapshot(updates, stepTs);
        scheduleRenderTable(true);
      } catch (err) {
        log(`Snapshot fallback: ${err.message}`, false);
      }
    }

  async function preloadSensors() {
      if (sensorIndex.hydrated) {
        pushDiagAction('[sensors] skip preload: hydrated');
        return;
      }
      try {
        pushDiagAction('[sensors] preload start');
        const data = await requestJSON('GET', '/api/v2/sensors');
        const list = data?.sensors || [];
        mergeSensorsFromAPI(list);
        sensorIndex.hydrated = list.length > 0;
        pushDiagAction(`[sensors] loaded count=${list.length}`);
        renderChartSuggestions(els.charts.sensors?.value || '');
        if (chartState.selected.length) {
          rebuildChart(true);
        }
      } catch (err) {
        logUI(`[chart] preload sensors failed: ${err.message}`);
        pushDiagAction(`[sensors] preload failed: ${err.message}`);
      }
    }

    function statusNormalize(s) {
      return String(s || 'idle').toLowerCase();
    }

    function parseISO(v) {
      const d = new Date(v);
      return Number.isNaN(d.getTime()) ? null : d;
    }

    function getRange(params) {
      const from = parseISO(params.From || params.from);
      const to = parseISO(params.To || params.to);
      return { from, to, valid: !!from && !!to && to > from };
    }

    function getEffectiveRange(params, pending) {
      const r1 = getRange(params || {});
      if (r1.valid) return r1;
      const pendingRange = pending?.range || pending?.Range || {};
      const r2 = getRange(pendingRange);
      if (pending?.range_set || pending?.RangeSet) {
        return r2;
      }
      return r2.valid ? r2 : { from: null, to: null, valid: false };
    }

    function extractSaveOutput(params, pending) {
      const pendingRange = pending?.range || pending?.Range;
      if ((pending?.range_set || pending?.RangeSet) && pendingRange) {
        const v = pendingRange.SaveOutput ?? pendingRange.save_output;
        if (v !== undefined) return { value: !!v, known: true };
      }
      if (params) {
        const v = params.SaveOutput ?? params.save_output;
        if (v !== undefined) return { value: !!v, known: true };
      }
      return { value: false, known: false };
    }

    function syncSaveToggle(status) {
      if (!els.inputs.saveToSM) return;
      const allowed = !!(state.model.save_allowed ?? state.model.SaveAllowed ?? state.saveAllowed);
      state.saveAllowed = allowed;
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const saveInfo = extractSaveOutput(params, pending);
      const st = status || state.model.status || '';
      const runningLike = st === 'running' || st === 'stopping';
      if (allowed && !runningLike) {
        if (!state.saveDirty && saveInfo.known) {
          els.inputs.saveToSM.checked = !!saveInfo.value;
        }
      } else if (!allowed) {
        els.inputs.saveToSM.checked = false;
      } else if (runningLike && saveInfo.known && !state.saveDirty) {
        els.inputs.saveToSM.checked = !!saveInfo.value;
      }
      setDisabled(els.inputs.saveToSM, !allowed || runningLike);
    }

    function syncChartRange(params, pending) {
      const range = getEffectiveRange(params, pending);
      if (!range.valid) {
        chartState.range = { from: null, to: null };
        return;
      }
      const fromMs = range.from.getTime();
      const toMs = range.to.getTime();
      const prevFrom = chartState.range.from;
      const prevTo = chartState.range.to;
      chartState.range = { from: fromMs, to: toMs };
      if (prevFrom !== fromMs || prevTo !== toMs) {
        // Перебираем датасеты и удаляем точки за пределами нового диапазона.
        chartState.datasets.forEach(ds => {
          ds.data = ds.data.filter(p => p.x >= fromMs && p.x <= toMs);
        });
        if (chartState.chart) {
          syncChartData();
        } else {
          rebuildChart(true);
        }
      }
    }

    function currentTsFromServer() {
      const st = statusNormalize(state.model.status);
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const params = state.model.params || state.model.Params || {};
      const range = getEffectiveRange(params, pending);
      const lastTs = parseISO(state.model.last_ts || state.model.LastTS);
      const pendingTs = pendingSeek ? parseISO(pendingSeek) : null;
      // Во всех нерunning состояниях приоритет у pending seek (например, после stop/done).
      if (st !== 'running' && st !== 'stopping' && pendingTs && !Number.isNaN(pendingTs.getTime()) && pendingTs.getFullYear() > 1) {
        return pendingTs;
      }
      // В активных состояниях используем последний ts от сервера, если валиден.
      if (lastTs && !Number.isNaN(lastTs.getTime()) && lastTs.getFullYear() > 1) {
        return lastTs;
      }
      if ((st === 'idle' || st === 'pending') && pendingTs) {
        return pendingTs;
      }
      if ((st === 'idle' || st === 'pending') && range.valid) {
        return range.from;
      }
      if (pendingTs) {
        return pendingTs;
      }
      if (range.valid) {
        return range.from;
      }
      return null;
    }

    function updateStatusView() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const curTs = currentTsFromServer();
      const stepID = state.model.step_id ?? state.model.StepID ?? '-';
      const lastTsText = curTs ? toRFC3339(curTs) : (state.model.last_ts ?? state.model.LastTS ?? '-');
      const updates = state.model.updates_sent ?? state.model.UpdatesSent ?? '-';
      if (els.status.badge) {
        els.status.badge.textContent = st;
        els.status.badge.classList.toggle('badge-done', st === 'done');
      }
      els.chipStatus.textContent = st;
      els.status.step.textContent = stepID;
      els.status.ts.textContent = lastTsText;
      els.status.updates.textContent = updates;
      els.status.error.textContent = state.model.error ? `Ошибка: ${state.model.error}` : '';
      els.chipStatus.className = 'status-value';
      if (st === 'running') els.chipStatus.classList.add('status-ok');
      if (st === 'paused' || st === 'pending') els.chipStatus.classList.add('status-warn');
      if (st === 'failed') els.chipStatus.classList.add('status-err');
      if (pendingSeek && (st === 'pending' || st === 'idle')) {
        els.status.ts.textContent = pendingSeek;
      }
      syncSaveToggle(st);
      syncChartRange(params, pending);
      updateTimeline();
      updateControls();
      logIndicators(st);
      toggleChartAutoUpdate(st);
      updateChartMeta();
    }

    function toggleChartAutoUpdate(status) {
      if (!els.charts.autoUpdate) return;
      const shouldRun = status === 'running' || status === 'stopping';
      chartState.autoUpdate = shouldRun;
      els.charts.autoUpdate.checked = shouldRun;
    }

    function logIndicators(status) {
      const step = state.model.step_id || state.model.StepID || '-';
      const ts = state.model.last_ts || state.model.LastTS || '-';
      const updates = state.model.updates_sent || state.model.UpdatesSent || '-';
      const pending = state.model.pending || state.model.Pending || {};
      logUI(`indicators status=${status} step=${step} ts=${ts} updates=${updates} pendingRange=${pending.range_set || pending.RangeSet ? 'yes' : 'no'}`);
    }

    function updateTimeline() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const slider = els.timeline;
      if (!range.valid) {
        slider.disabled = true;
        slider.value = 0;
        els.fromLabel.textContent = 'from: -';
        els.toLabel.textContent = 'to: -';
        els.currentLabel.textContent = '-';
        return;
      }
      els.fromLabel.textContent = `from: ${range.from.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      els.toLabel.textContent = `to: ${range.to.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      slider.disabled = false;
      const rangeMs = range.to - range.from;
      let pos = 0;
      const st = statusNormalize(state.model.status);
      let curTs = currentTsFromServer();
      if (state.previewTs && st !== 'running' && st !== 'stopping') {
        curTs = state.previewTs;
      }
      if (curTs) {
        pos = Math.max(0, Math.min(1, (curTs - range.from) / rangeMs));
        els.currentLabel.textContent = toRFC3339(curTs);
        logUI(`timeline render ${toRFC3339(curTs)} source=${state.previewTs ? 'preview' : 'server'}`);
      } else {
        els.currentLabel.textContent = pending.seek_ts || pending.SeekTS || toRFC3339(range.from) || '-';
      }
      slider.value = Math.round(pos * 1000);
    }

    function updateControls() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const pendingRange = !!(pending?.range_set || pending?.RangeSet);
      const hasWorking = state.workingReady && state.workingSensors.length > 0;
      const readOnly = !!state.controlLocked;
      const active = hasWorking && (st === 'running' || st === 'paused' || st === 'stopping');
      const paused = st === 'paused';
      const curTs = currentTsFromServer();
      const atStart = !range.valid || !curTs || curTs.getTime() <= range.from.getTime();
      const atEnd = !range.valid || !curTs || curTs.getTime() >= range.to.getTime();
      const canStep = hasWorking && range.valid && st !== 'failed' && st !== 'running' && st !== 'stopping';
      const runningLike = st === 'running' || st === 'stopping';

      setDisabled(els.controls.stepBack, readOnly || !canStep || atStart);
      setDisabled(els.controls.stepFwd, readOnly || !canStep || atEnd);
      setDisabled(els.controls.stop, readOnly || !active);
      const hasRange = range.valid && (active || pendingRange || state.rangePicked); // диапазон считаем заданным если активен, есть pending или пользователь выбрал его в этой сессии
      setDisabled(els.controls.playPause, readOnly || st === 'failed' || !hasRange || !hasWorking);
      const playLike = paused || st === 'idle' || st === 'done' || st === 'pending';
      els.controls.playPause.textContent = playLike ? '▶️ Play' : '⏸ Pause';
      els.controls.playPause.classList.remove('primary');
      // Ползунок доступен при валидном диапазоне (даже до старта), чтобы можно было выбрать точку.
      setDisabled(els.timeline, readOnly || !range.valid || !hasWorking);
      if (els.rangeBtn) {
        setDisabled(els.rangeBtn, readOnly || active); // не трогаем диапазон во время активной задачи
      }
      if (els.rangePicker) {
        setDisabled(els.rangePicker, readOnly); // блокируем кнопку выбора диапазона если нет управления
      }
      if (els.inputs.saveToSM) {
        const allowed = !!(state.model.save_allowed ?? state.model.SaveAllowed ?? state.saveAllowed);
        setDisabled(els.inputs.saveToSM, readOnly || runningLike || !allowed);
      }
      setDisabled(els.inputs.from, readOnly);
      setDisabled(els.inputs.to, readOnly);
      setDisabled(els.inputs.step, readOnly);
      setDisabled(els.inputs.speed, readOnly);
      setDisabled(els.inputs.window, readOnly);
      if (els.working?.btn) {
        setDisabled(els.working.btn, readOnly);
      }
      updateControlLockUI();
      updateWorkingMeta();
    }

    function setDisabled(el, disabled) {
      if (!el) return;
      el.disabled = !!disabled;
      el.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      if (disabled) el.classList.add('is-disabled');
      else el.classList.remove('is-disabled');
    }

    function updateControlLockUI() {
      const locked = !!state.controlLocked;
      pushDiagAction(`[lock-ui] locked=${locked} hasNotice=${!!els.controlLock?.notice} display=${locked ? 'block' : 'none'}`);
      if (els.controlLock?.notice) {
        els.controlLock.notice.style.display = locked ? 'block' : 'none';
      }
      if (els.controlLock?.claim) {
        const showClaim = locked && state.canClaim;
        els.controlLock.claim.style.display = showClaim ? 'inline-flex' : 'none';
      }
      if (els.controlLock?.chip) {
        els.controlLock.chip.style.display = locked ? 'inline-flex' : 'none';
        els.controlLock.chip.textContent = 'Управление отключено';
      }
    }

    const originalBrandHTML = `<span id="brandEaster" class="brand-click">TimeMachine</span> · Player · v2`;
    let easterTimer = null;
    function triggerEaster() {
      if (!els.brandContainer) return;
      const target = els.brandContainer;
      if (easterTimer) clearTimeout(easterTimer);
      target.classList.remove('brand-fadein', 'brand-fadeout');
      target.classList.add('brand-fadeout');
      setTimeout(() => {
        target.innerHTML = `<span class="easter show run"><span class="shine"></span><span>прошлое невозможно вернуть, но его можно увидеть..</span></span>`;
        target.classList.remove('brand-fadeout');
        target.classList.add('brand-fadein');
      }, 320);
      easterTimer = setTimeout(() => {
        target.classList.remove('brand-fadein');
        target.classList.add('brand-fadeout');
        setTimeout(() => {
          target.innerHTML = originalBrandHTML;
          els.brandClick = document.getElementById('brandEaster');
          if (els.brandClick) els.brandClick.addEventListener('click', triggerEaster);
          target.classList.remove('brand-fadeout');
          target.classList.add('brand-fadein');
        }, 340);
      }, 6200);
    }

    function updateRangeLabel() {
      if (!els.rangePicker) return;
      const from = els.inputs.from.value.trim();
      const to = els.inputs.to.value.trim();
      const valid = isValidISO(from) && isValidISO(to);
      const label = valid ? `${from} → ${to}` : 'не задан';
      if (els.rangeLabelValue) {
        els.rangeLabelValue.textContent = label;
        els.rangeLabelValue.style.color = valid ? '#e5e7eb' : '#fbbf24';
      } else {
        els.rangePicker.textContent = `${label}`;
      }
    }

    function validateStartForm() {
      const errors = [];
      const from = els.inputs.from.value.trim();
      const to = els.inputs.to.value.trim();
      const step = els.inputs.step.value.trim();
      const speedVal = els.inputs.speed.value.trim();
      const windowVal = els.inputs.window.value.trim();
      if (!isValidISO(from)) errors.push('From: RFC3339, например 2024-06-01T00:00:00Z.');
      if (!isValidISO(to)) errors.push('To: RFC3339.');
      if (isValidISO(from) && isValidISO(to) && new Date(to) <= new Date(from)) errors.push('To позже From.');
      if (!isValidDuration(step)) errors.push('Step: 1s/200ms/1m.');
      let speed = parseFloat(speedVal || '1');
      if (!Number.isFinite(speed) || speed <= 0) errors.push('Speed: положительное число.');
      if (windowVal && !isValidDuration(windowVal)) errors.push('Window: 5s/1m.');
      els.startErrors.textContent = errors.join(' ');
      if (errors.length) return null;
      const payload = { from, to, step, speed };
      if (windowVal) payload.window = windowVal;
      const saveOutput = state.saveAllowed && els.inputs.saveToSM && els.inputs.saveToSM.checked;
      payload.save_output = !!saveOutput;
      return payload;
    }

    function isValidISO(v) {
      const d = new Date(v);
      return v && !Number.isNaN(d.getTime());
    }

    function isValidDuration(v) {
      return /^\d+(ms|s|m|h)$/.test(v);
    }

  async function refresh(full = false) {
    if (!sensorIndex.hydrated) {
      await preloadSensors();
    }
    if (!state.workingReady) {
      await loadWorkingSensors().catch(() => {});
    }
    // Проверяем статус контроллера при каждом refresh.
    // Отправляем наш токен чтобы узнать: являемся ли МЫ контроллером,
    // и есть ли вообще активный контроллер.
    try {
      const sessionResp = await fetch('/api/v2/session', {
        headers: state.sessionToken ? { 'X-TM-Session': state.sessionToken } : {}
      });
      const sessionData = await sessionResp.json();
      if (sessionResp.ok) {
        state.controllerPresent = !!sessionData.controller_present;
        // Если контроллера нет - можем управлять; если есть - проверяем что МЫ контроллер
        state.isController = !!sessionData.is_controller || !state.controllerPresent;
        state.canClaim = !!sessionData.can_claim;
        state.controlLocked = state.controllerPresent && !state.isController;
        pushDiagAction(`[session] is_ctrl=${sessionData.is_controller} ctrl_present=${sessionData.controller_present} => isCtrl=${state.isController} locked=${state.controlLocked}`);
        updateControlLockUI();
      }
    } catch (err) {
      logUI(`Session check in refresh: ${err.message}`);
    }
    const url = '/api/v2/job';
      logUI(`refresh ${full ? 'full' : 'state'} start last_ts=${state.model.last_ts || state.model.LastTS}`);
      const data = await requestJSON('GET', url);
      const status = statusNormalize(data?.status || data?.Status || state.model.status);
      pushDiagAction(`[refresh] ${full ? 'full' : 'state'} status=${status} step=${data?.step_id ?? data?.StepID ?? '-'} ts=${data?.last_ts ?? data?.LastTS ?? '-'}`);
      const pending = data?.pending || data?.Pending || {};
      state.model = { ...data, status, pending };
      // Если нет активных params, но есть pending range — используем его для отображения.
    const pendingRange = pending.range_set ? pending.range : pending.Range;
    if (!state.model.params && !state.model.Params && pendingRange) {
      state.model.params = pendingRange;
      state.model.Params = pendingRange;
    }
    // Если после обновления таблица пуста, а метаданные уже есть, подсетим строки.
    if (!tableState.rows.size && sensorIndex.byId.size) {
      seedTableFromMeta();
    } else if (!sensorIndex.hydrated) {
      preloadSensors().catch(() => {});
    }
    state.saveAllowed = !!(data?.save_allowed ?? data?.SaveAllowed ?? state.saveAllowed);
    syncSaveToggle();
    hydrateChartDefaultsFromParams();
    syncChartWithParams(state.model.params || state.model.Params);
    syncChartRange(state.model.params || state.model.Params, pending);
      // Если на сервере уже есть pending диапазон, считаем его выбранным (важно для восстановления состояния и тестов).
      if (pendingRange && !state.rangePicked) {
        state.rangePicked = true;
      }
      logUI(`refresh result status=${status} last_ts=${state.model.last_ts || state.model.LastTS} pendingRange=${pendingRange ? 'yes' : 'no'}`);
      updateStatusView();
  }

  async function startJob() {
      if (!sensorIndex.hydrated) {
        await preloadSensors().catch(() => {});
      }
    const payload = validateStartForm();
    if (!state.workingReady || !state.workingSensors.length) {
      log('Рабочий список датчиков не выбран', false);
      return;
    }
    if (!payload) return;
    if (rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit) {
      log(`В диапазоне ${rangeSensorCount} датчиков, автодобавление в графики отключено (лимит ${chartAutoAddLimit})`, true);
    }
      logUI(`set range v2 ${JSON.stringify(payload)}`);
      await requestJSON('POST', '/api/v2/job/range', payload);
      state.rangePicked = true;
      await fetchSensorCount(payload.from, payload.to);
      logUI('startJob (v2) using pending');
      try {
        pushDiagAction('[action] start');
        await requestJSON('POST', '/api/v2/job/start', { save_output: payload.save_output });
        log('Старт отправлен');
        await refresh(true);
      } catch (err) {
        log(`Старт: ${err.message}`, false);
      }
    }

    function bindActions() {
      if (els.controlLock?.claim) {
        els.controlLock.claim.addEventListener('click', async () => {
          try {
            await requestJSON('POST', '/api/v2/session/claim');
            state.isController = true;
            state.controlLocked = false;
            state.canClaim = false;
            updateControls();
            log('Управление передано этой сессии');
          } catch (err) {
            log(`Claim failed: ${err.message}`, false);
          }
        });
      }
      els.tabs.forEach(btn => {
        btn.addEventListener('click', () => setTab(btn.dataset.tab));
      });
      if (els.inputs.saveToSM) {
        els.inputs.saveToSM.addEventListener('change', () => {
          state.saveDirty = true;
        });
      }
      if (els.table.filter) {
        els.table.filter.addEventListener('input', (e) => {
          const v = e.target.value.toLowerCase();
          if (tableFilterTimer) clearTimeout(tableFilterTimer);
          tableFilterTimer = setTimeout(() => {
            tableState.filter = v;
            scheduleRenderTable(true);
          }, 150);
        });
        els.table.filter.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            clearTableFilter();
          }
        });
        els.table.filter.addEventListener('keyup', (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            clearTableFilter();
          }
        });
      }
      if (els.table.selectAll) {
        els.table.selectAll.addEventListener('change', () => {
          const rows = getFilteredTableRows(false);
          if (els.table.selectAll.checked) {
            rows.forEach(r => tableState.selected.add(r.id));
          } else {
            tableState.selected.clear();
          }
          renderTable(true);
        });
      }
      if (els.table.precision) {
        els.table.precision.addEventListener('change', () => {
          const v = Number(els.table.precision.value);
          tableValuePrecision = Number.isFinite(v) ? v : 3;
          tableState.precision = tableValuePrecision;
          renderTable(true);
        });
      }
      if (els.working?.btn) {
        els.working.btn.addEventListener('click', () => {
          if (!sensorIndex.hydrated) {
            preloadSensors().finally(openSensorsDialog);
          } else {
            openSensorsDialog();
          }
        });
      }
      if (els.sensorsDialogTabs) {
        els.sensorsDialogTabs.forEach(btn => {
          btn.addEventListener('click', () => setSensorsTab(btn.dataset.sensortab || 'existing'));
        });
      }
      if (els.sensorsFilter) {
        els.sensorsFilter.addEventListener('input', (e) => {
          workingPicker.filter = (e.target.value || '').toLowerCase();
          renderSensorsDialogTable();
        });
      }
      if (els.sensorsSelectAll) {
        els.sensorsSelectAll.addEventListener('change', () => {
          const filter = (workingPicker.filter || '').trim().toLowerCase();
          const ids = [];
          sensorIndex.byId.forEach((meta, id) => {
            const name = meta.name || `${id}`;
            const text = meta.textname || '';
            if (filter && !name.toLowerCase().includes(filter) && !text.toLowerCase().includes(filter)) return;
            ids.push(id);
          });
          if (els.sensorsSelectAll.checked) ids.forEach(id => workingPicker.selected.add(id));
          else ids.forEach(id => workingPicker.selected.delete(id));
          renderSensorsDialogTable();
        });
      }
      if (els.sensorsDialogBody) {
        els.sensorsDialogBody.addEventListener('change', (e) => {
          const target = e.target;
          if (!(target instanceof HTMLInputElement)) return;
          if (!target.classList.contains('dlg-select')) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (target.checked) workingPicker.selected.add(id);
          else workingPicker.selected.delete(id);
          renderSensorsDialogTable();
        });
      }
      if (els.sensorsFileInput) {
        els.sensorsFileInput.addEventListener('change', (e) => {
          const file = e.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (ev) => {
            workingPicker.fileText = String(ev.target?.result || '');
            if (els.sensorsFileArea) els.sensorsFileArea.value = workingPicker.fileText;
            updateSensorsFileMeta();
          };
          reader.readAsText(file);
        });
      }
      if (els.sensorsFileArea) {
        els.sensorsFileArea.addEventListener('input', (e) => {
          workingPicker.fileText = e.target.value || '';
          updateSensorsFileMeta();
        });
      }
      if (els.sensorsResetBtn) {
        els.sensorsResetBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          try {
            await applyWorkingSensors(allSensorIds(), { toast: true });
            if (els.sensorsDialog) els.sensorsDialog.close();
          } catch (err) {
            setSensorsDialogError(err.message);
          }
        });
      }
      if (els.sensorsApplyBtn) {
        els.sensorsApplyBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          await applySensorsDialog(workingPicker.tab || 'existing');
        });
      }
      if (els.sensorsCancelBtn) {
        els.sensorsCancelBtn.addEventListener('click', (e) => {
          e.preventDefault();
          if (els.sensorsDialog) els.sensorsDialog.close('cancel');
        });
      }
      if (els.sensorsDialog) {
        els.sensorsDialog.addEventListener('close', () => setSensorsDialogError(''));
      }
      if (els.table.body) {
        els.table.body.addEventListener('change', (e) => {
          const target = e.target;
          if (!target || !target.matches('input.table-select')) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (target.checked) {
            tableState.selected.add(id);
          } else {
            tableState.selected.delete(id);
          }
          renderTable(false);
        });
        els.table.body.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-chart-add]');
          if (!btn) return;
          const id = Number(btn.dataset.chartAdd);
          if (!Number.isFinite(id)) return;
          (async () => {
            if (!sensorIndex.hydrated) {
              try { await preloadSensors(); } catch (_) { /* ignore */ }
            }
            const next = Array.from(new Set([...chartState.selected, id]));
            applyChartSensors(next);
          })();
        });
      }
      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        const panelTable = document.getElementById('panel-table');
        if (!panelTable || !panelTable.classList.contains('active')) return;
        clearTableFilter();
      });
      if (els.rangePicker) {
        els.rangePicker.addEventListener('click', () => openRangeDialog());
      }
      document.querySelectorAll('[data-picker]').forEach(btn => {
        btn.addEventListener('click', () => openPicker(btn.dataset.picker));
      });
      els.dialog.addEventListener('close', () => {
        if (els.dialog.returnValue !== 'ok') return;
        const target = els.dialog.dataset.target;
        const val = els.dialogInput.value;
        if (!target || !val) return;
        const iso = localInputToISO(val);
        const input = document.getElementById(target);
        if (input && iso) input.value = iso;
      });
      if (els.rangeDialog) {
        els.rangeDialog.addEventListener('close', () => {
          if (els.rangeDialog.returnValue !== 'ok') return;
          const from = localInputToISO(els.rangeFrom?.value || '');
          const to = localInputToISO(els.rangeTo?.value || '');
          if (from) els.inputs.from.value = from;
          if (to) els.inputs.to.value = to;
          state.previewTs = null;
          updateRangeLabel();
          (async () => {
            const payload = validateStartForm();
            if (!payload) return;
            try {
              await requestJSON('POST', '/api/v2/job/range', payload);
              state.rangePicked = true;
              await fetchSensorCount(payload.from, payload.to);
              await refresh(true);
            } catch (err) {
              log(`Диапазон: ${err.message}`, false);
            }
          })();
        });
        els.rangeDialog.querySelectorAll('[data-quick-min]').forEach(btn => {
          btn.addEventListener('click', () => applyQuickRange(parseInt(btn.dataset.quickMin, 10)));
        });
      }
      if (els.charts.colorDialog) {
        els.charts.colorDialog.addEventListener('close', () => {
          const id = Number(els.charts.colorDialog.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (els.charts.colorDialog.returnValue !== 'ok') return;
          const color = normalizeHexColor(els.charts.colorInput?.value || '');
          const ds = chartState.datasets.get(id);
          if (!ds) return;
          ds.color = color;
          rebuildChartSeries();
          renderLegendTable();
        });
      }
      if (els.preciseTimeDialog) {
        // Обработчик submit формы для валидации
        const preciseForm = els.preciseTimeDialog.querySelector('form');
        if (preciseForm) {
          preciseForm.addEventListener('submit', async (e) => {
            const submitValue = (e.submitter && e.submitter.value) || '';
            if (submitValue !== 'ok') {
              // Отмена - разрешаем закрытие
              return;
            }

            // Проверка перед закрытием
            e.preventDefault();
            els.preciseTimeError.textContent = '';

            const date = els.preciseDate.value;
            const time = els.preciseTime.value;
            const millis = els.preciseMillis.value || '0';

            if (!date || !time) {
              els.preciseTimeError.textContent = 'Заполните дату и время';
              return;
            }

            // Парсим время
            const timeParts = time.match(/^(\d{2}):(\d{2}):(\d{2})$/);
            if (!timeParts) {
              els.preciseTimeError.textContent = 'Неверный формат времени (ЧЧ:ММ:СС)';
              return;
            }

            const hours = parseInt(timeParts[1], 10);
            const minutes = parseInt(timeParts[2], 10);
            const seconds = parseInt(timeParts[3], 10);
            const milliseconds = parseInt(millis, 10);

            if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59 || milliseconds < 0 || milliseconds > 999) {
              els.preciseTimeError.textContent = 'Значения вне допустимых диапазонов';
              return;
            }

            // Создаём дату из введённых данных
            const targetDate = new Date(date + 'T00:00:00.000Z');
            targetDate.setUTCHours(hours);
            targetDate.setUTCMinutes(minutes);
            targetDate.setUTCSeconds(seconds);
            targetDate.setUTCMilliseconds(milliseconds);

            // Проверяем что дата в допустимом диапазоне
            const params = state.model.params || state.model.Params || {};
            const pending = state.model.pending || state.model.Pending || {};
            const range = getEffectiveRange(params, pending);

            if (!range.valid) {
              els.preciseTimeError.textContent = 'Диапазон не установлен';
              return;
            }

            if (targetDate < range.from || targetDate > range.to) {
              els.preciseTimeError.textContent = 'Время вне диапазона воспроизведения';
              return;
            }

            // Преобразуем в RFC3339 и отправляем seek
            const ts = toRFC3339(targetDate);
            if (!ts) {
              els.preciseTimeError.textContent = 'Ошибка преобразования даты';
              return;
            }

            logUI(`Точная перемотка на ${ts}`);

            try {
              await action('seek (точная)', '/api/v2/job/seek', { ts, apply: true });
              // Обновляем позицию слайдера
              const ratio = (targetDate - range.from) / (range.to - range.from);
              els.timeline.value = Math.round(ratio * 1000);
              state.previewTs = targetDate;

              // Успешно - закрываем диалог
              els.preciseTimeDialog.close('ok');
            } catch (err) {
              els.preciseTimeError.textContent = `Ошибка: ${err.message}`;
            }
          });
        }
      }
      els.timeline.addEventListener('change', onTimelineSeek);
      els.timeline.addEventListener('input', onTimelinePreview);
      els.timeline.addEventListener('pointerdown', () => {
        const params = state.model.params || state.model.Params || {};
        const pending = state.model.pending || state.model.Pending || {};
        const range = getEffectiveRange(params, pending);
        if (!range.valid) return;
        const v = Number(els.timeline.value) / 1000;
        const ts = toRFC3339(new Date(range.from.getTime() + (range.to - range.from) * v));
        if (ts) logUI(`timeline drag start ${ts}`);
      });
      els.timeline.addEventListener('dblclick', openPreciseTimeDialog);
      els.controls.stepBack.addEventListener('click', () => action('step назад', '/api/v2/job/step/backward', { apply: true }));
      els.controls.stepFwd.addEventListener('click', () => action('step вперёд', '/api/v2/job/step/forward'));
      els.controls.stop.addEventListener('click', () => {
        logUI('Stop button: clicked');
        action('stop', '/api/v2/job/stop');
      });
      els.controls.playPause.addEventListener('click', onPlayPause);
      els.clearLog.addEventListener('click', () => { els.log.innerHTML = ''; });
      if (els.diagEnable) {
        els.diagEnable.addEventListener('change', () => {
          state.diagEnabled = !!els.diagEnable.checked;
          if (!state.diagEnabled && !state.netLogEnabled) {
            diagBuffer.length = 0;
          } else if (!sensorIndex.hydrated) {
            preloadSensors().catch(() => {});
          }
          logUI(`Диагностика ${state.diagEnabled ? 'включена' : 'выключена'}`);
          updateDiagButtons();
        });
      }
      if (els.diagNetEnable) {
        els.diagNetEnable.addEventListener('change', () => {
          state.netLogEnabled = !!els.diagNetEnable.checked;
          if (!state.diagEnabled && !state.netLogEnabled) {
            diagBuffer.length = 0;
          }
          updateDiagButtons();
        });
      }
      if (els.diagDownload) {
        els.diagDownload.addEventListener('click', () => downloadDiag());
      }
      if (els.diagClear) {
        els.diagClear.addEventListener('click', () => clearDiag());
      }
      if (els.rangeBtn) {
        els.rangeBtn.addEventListener('click', () => applyAvailableRange(true));
      }
      if (els.charts.apply) {
        els.charts.apply.addEventListener('click', () => {
          addSensorsFromInput();
        });
      }
      if (els.charts.clear) {
        els.charts.clear.addEventListener('click', () => clearChart());
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.addEventListener('change', () => {
          chartState.autoUpdate = !!els.charts.autoUpdate.checked;
          updateChartMeta();
        });
      }
      if (els.charts.legendBody) {
        els.charts.legendBody.addEventListener('click', (e) => {
          const target = e.target;
          if (target && target.matches('button.chart-color-btn')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            openColorDialog(id);
            return;
          }
          if (target && target.matches('button.chart-remove-btn')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            const filtered = chartState.selected.filter(x => x !== id);
            applyChartSensors(filtered);
            return;
          }
          if (target && target.closest('input.chart-color-input')) {
            return;
          }
          const row = target.closest('tr[data-sensor]');
          if (!row) return;
          const id = Number(row.dataset.sensor);
          if (!Number.isFinite(id)) return;
          chartState.focused = chartState.focused === id ? null : id;
          if (chartState.chart) {
            syncChartData();
          }
          renderLegendTable();
        });
      }
      if (els.charts.suggestBox) {
        els.charts.suggestBox.addEventListener('mousedown', (e) => {
          const target = e.target.closest('.chart-suggest-item');
          if (!target) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (chartState.selected.length >= chartMaxSeries) {
            return;
          }
          applyChartSensors([...chartState.selected, id]);
          hideChartSuggestions();
        });
      }
      if (els.charts.window) {
        els.charts.window.addEventListener('change', () => {
          const v = Number(els.charts.window.value);
          if (!Number.isFinite(v) || v < 0) return;
          chartState.windowSec = v;
          const now = Date.now();
          chartState.datasets.forEach(ds => trimDataset(ds, now));
          syncChartData();
        });
      }
      if (els.charts.sensors) {
        els.charts.sensors.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const active = chartState.suggest.items[chartState.suggest.active];
            if (active) {
              applyChartSensors([...chartState.selected, active.id]);
              hideChartSuggestions();
            } else {
              addSensorsFromInput();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            e.target.blur();
            hideChartSuggestions();
          } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            moveSuggestActive(e.key === 'ArrowDown' ? 1 : -1);
          } else {
            setTimeout(() => renderChartSuggestions(e.target.value), 0);
          }
        });
        els.charts.sensors.addEventListener('input', (e) => {
          chartState.suggest.locked = false;
          renderChartSuggestions(e.target.value);
        });
        els.charts.sensors.addEventListener('change', () => {
          chartState.suggest.locked = false;
          addSensorsFromInput();
        });
        els.charts.sensors.addEventListener('focus', (e) => {
          chartState.suggest.locked = false;
          renderChartSuggestions(e.target.value);
        });
        els.charts.sensors.addEventListener('blur', () => setTimeout(hideChartSuggestions, 120));
      }
      if (els.charts.fill) {
        els.charts.fill.addEventListener('change', () => syncChartData());
      }
      if (els.charts.smooth) {
        els.charts.smooth.addEventListener('change', () => {
          chartState.smooth = !!els.charts.smooth.checked;
          syncChartData();
        });
      }
      if (els.charts.precision) {
        els.charts.precision.addEventListener('change', () => {
          const v = Number(els.charts.precision.value);
          chartValuePrecision = Number.isFinite(v) ? v : 3;
          renderLegendTable();
          syncChartData();
        });
      }
    }

    async function onPlayPause() {
      const st = statusNormalize(state.model.status);
      if (st === 'running') {
        logUI('Play button: pausing');
        await action('pause', '/api/v2/job/pause');
        state.previewTs = null;
        return;
      }
      if (st === 'paused') {
        logUI('Play button: resuming with seek');
        const targetDate = currentTsFromServer();
        const target = targetDate ? toRFC3339(targetDate) : (state.model.last_ts || inputs.from.value.trim());
        if (target) {
          await action('seek', '/api/v2/job/seek', { ts: target, apply: false });
        }
        state.previewTs = null;
        const saveOutput = state.saveAllowed && els.inputs.saveToSM && els.inputs.saveToSM.checked;
        state.saveDirty = false;
        await action('resume', '/api/v2/job/resume', { save_output: saveOutput });
        return;
      }
      logUI('Play button: starting job');
      state.previewTs = null;
      await startJob();
    }

    function onTimelinePreview() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const dt = new Date(from.getTime() + (to - from) * v);
      const iso = toRFC3339(dt);
      if (!iso) return;
      state.previewTs = dt;
      els.currentLabel.textContent = iso;
    }

    async function onTimelineSeek() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const ts = toRFC3339(new Date(from.getTime() + (to - from) * v));
      state.previewTs = parseISO(ts);
      logUI(`timeline seek ${ts}`);
      await seekOrPreview(ts);
    }

    async function action(label, url, body, refreshFull = true) {
      logUI(`action ${label} ${url} ${body ? JSON.stringify(body) : ''}`);
      try {
        await requestJSON('POST', url, body);
        log(`${label}: ok`);
        await refresh(refreshFull);
      } catch (err) {
        log(`${label}: ${err.message}`, false);
      }
    }

    function openPicker(targetId) {
      const input = document.getElementById(targetId);
      const current = input ? input.value.trim() : '';
      els.dialog.dataset.target = targetId;
      els.dialogInput.value = isoToLocalInput(current) || '';
      els.dialog.showModal();
    }

    function openRangeDialog() {
      if (!els.rangeDialog || !els.rangeFrom || !els.rangeTo) return;
      els.rangeFrom.value = isoToLocalInput(els.inputs.from.value.trim()) || '';
      els.rangeTo.value = isoToLocalInput(els.inputs.to.value.trim()) || '';
      els.rangeDialog.showModal();
    }

    function applyQuickRange(mins) {
      if (!Number.isFinite(mins) || mins <= 0) return;
      const now = new Date();
      const from = new Date(now.getTime() - mins * 60 * 1000);
      if (els.rangeFrom) els.rangeFrom.value = isoToLocalInput(toRFC3339(from));
      if (els.rangeTo) els.rangeTo.value = isoToLocalInput(toRFC3339(now));
    }

    function openPreciseTimeDialog() {
      if (!els.preciseTimeDialog) return;

      // Очищаем ошибки
      els.preciseTimeError.textContent = '';

      // Получаем текущую позицию из timeline
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);

      if (!range.valid) {
        els.preciseTimeError.textContent = 'Диапазон не установлен';
        els.preciseTimeDialog.showModal();
        return;
      }

      // Вычисляем текущую дату из позиции слайдера
      const v = Number(els.timeline.value) / 1000;
      const currentDate = new Date(range.from.getTime() + (range.to - range.from) * v);

      // Форматируем дату в формат YYYY-MM-DD
      const year = currentDate.getUTCFullYear();
      const month = String(currentDate.getUTCMonth() + 1).padStart(2, '0');
      const day = String(currentDate.getUTCDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;

      // Форматируем время в формат ЧЧ:ММ:СС
      const hours = String(currentDate.getUTCHours()).padStart(2, '0');
      const minutes = String(currentDate.getUTCMinutes()).padStart(2, '0');
      const seconds = String(currentDate.getUTCSeconds()).padStart(2, '0');
      const timeStr = `${hours}:${minutes}:${seconds}`;

      // Получаем миллисекунды
      const millis = String(currentDate.getUTCMilliseconds());

      // Заполняем поля диалога
      els.preciseDate.value = dateStr;
      els.preciseTime.value = timeStr;
      els.preciseMillis.value = millis;

      // Открываем диалог
      els.preciseTimeDialog.showModal();

      logUI(`Открыт диалог точной позиции для ${dateStr} ${timeStr}.${millis}`);
    }

    function isoToLocalInput(iso) {
      const d = parseISO(iso);
      if (!d) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function localInputToISO(val) {
      if (!val) return '';
      const d = new Date(val);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function applyPresetMinutes(mins) {
      if (!Number.isFinite(mins) || mins <= 0) return;
      const now = new Date();
      const from = new Date(now.getTime() - mins * 60 * 1000);
      els.inputs.from.value = toRFC3339(from);
      els.inputs.to.value = toRFC3339(now);
      state.previewTs = null;
      updateRangeLabel();
    }

    async function seekOrPreview(ts) {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      if (!range.valid) return;
      const target = new Date(ts);
      if (Number.isFinite(target.getTime())) {
        truncateChartAfter(target.getTime());
      }
      logUI(`seekOrPreview request ts=${ts}`);
      await action('seek', '/api/v2/job/seek', { ts, apply: false });
    }

    function toRFC3339(d) {
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function setupVerticalResize({ handle, target, storageKey, min = 240, max = 900, onChange }) {
      if (!handle || !target) return;
      const applyHeight = (h) => {
        const height = clamp(h, min, max);
        target.style.height = `${height}px`;
        if (onChange) onChange(height);
        return height;
      };
      const stored = Number(localStorage.getItem(storageKey));
      if (Number.isFinite(stored)) {
        applyHeight(stored);
      } else {
        const current = target.getBoundingClientRect().height || min;
        applyHeight(current);
      }
      handle.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const startY = e.clientY;
        const startH = target.getBoundingClientRect().height;
        let latest = startH;
        const onMove = (ev) => {
          ev.preventDefault();
          latest = applyHeight(startH + (ev.clientY - startY));
        };
        const onUp = () => {
          localStorage.setItem(storageKey, String(latest));
          document.removeEventListener('pointermove', onMove);
          document.removeEventListener('pointerup', onUp);
        };
        document.addEventListener('pointermove', onMove);
        document.addEventListener('pointerup', onUp);
      });
    }

    function initResizablePanels() {
      setupVerticalResize({
        handle: els.charts.resizeHandle,
        target: els.charts.box,
        storageKey: 'chartHeightPx',
        min: 320,
        max: 900,
        onChange: () => {
          if (chartState.chart) {
            chartState.chart.resize();
            scheduleChartSync();
          }
        },
      });
      setupVerticalResize({
        handle: els.charts.resizeHandleStep,
        target: els.charts.boxStep,
        storageKey: 'chartStepHeightPx',
        min: 140,
        max: 500,
        onChange: () => {
          rebuildStepChart(chartState.range.from && chartState.range.to);
        },
      });
      setupVerticalResize({
        handle: els.charts.legendHandle,
        target: els.charts.legendWrap,
        storageKey: 'chartLegendHeightPx',
        min: 140,
        max: 500,
      });
    }

    async function fetchSensorCount(from, to) {
      if (!isValidISO(from) || !isValidISO(to)) {
        rangeSensorCount = Infinity;
        rangeSensorCountKnown = false;
        log('Диапазон: количество датчиков неизвестно', false);
        return;
      }
      const qs = new URLSearchParams({ from, to }).toString();
      try {
        const data = await requestJSON('GET', `/api/v2/job/sensors/count?${qs}`);
        const cnt = Number(data?.sensor_count ?? data?.count);
        if (Number.isFinite(cnt)) {
          rangeSensorCount = cnt;
          rangeSensorCountKnown = true;
          log(`Диапазон: найдено ${rangeSensorCount} датчиков`, rangeSensorCount === 0 ? 'warn' : 'ok');
        } else {
          rangeSensorCount = Infinity;
          rangeSensorCountKnown = false;
          log('Диапазон: количество датчиков неизвестно', false);
        }
      } catch (err) {
        rangeSensorCount = Infinity;
        rangeSensorCountKnown = false;
        log(`Диапазон: ${err.message}`, false);
      }
      updateChartMeta();
    }

    async function startPolling() {
      try { await refresh(true); } catch (err) { log(`Init: ${err.message}`, false); }
      setInterval(async () => {
        try {
          await refresh(false);
          if (state.isController) {
            await keepAlive();
          }
          state.pollErrorNotified = false;
        } catch (err) {
          if (!state.pollErrorNotified) {
            log(`Poll: ${err.message}`, false);
            state.pollErrorNotified = true;
          }
        }
      }, state.pollingMs);
    }

    bindActions();
    if (els.brandClick) {
      els.brandClick.addEventListener('click', triggerEaster);
    }
    updateControls();
    initResizablePanels();
    scheduleRenderTable(true);
    updateChartMeta();
    updateRangeLabel();
    updateDiagButtons();
    updateWorkingMeta();

    // Диагностика автоматически включена через state.diagEnabled если ?diag=1
    if (state.diagEnabled) {
      console.log('[DIAG] Auto-enabled diagnostics via ?diag=1');
    }

    // Детект дублирования вкладки: используем sessionStorage который НЕ копируется при дублировании.
    // При первой загрузке генерируем уникальный ID и сохраняем в sessionStorage.
    // Если в state.sessionToken есть значение, но sessionStorage пуст - значит дублирование!
    const storageTabId = sessionStorage.getItem('tabId');
    if (!storageTabId) {
      // sessionStorage пуст - это либо первая загрузка, либо дублирование
      const newTabId = Math.random().toString(36).substring(2);
      sessionStorage.setItem('tabId', newTabId);

      if (state.sessionToken) {
        // state.sessionToken есть но sessionStorage пуст - ДУБЛИРОВАНИЕ!
        console.log(`[INIT] Detected duplicated tab (token exists but no storageTabId), clearing session`);
        console.log(`[INIT] Old token=${state.sessionToken.substring(0,8)}... clearing...`);
        state.sessionToken = '';
      } else {
        console.log(`[INIT] First load, generated tabId=${newTabId}`);
      }
    } else {
      console.log(`[INIT] Reload, keeping tabId=${storageTabId}`);
    }

    (async () => {
      await initSession();
      await preloadSensors().catch(() => {});
      await loadWorkingSensors().catch(() => {});
      startPolling();
      connectWS();
    })();

    async function applyAvailableRange(intoDialog = false) {
      try {
        logUI('range button clicked');
        const data = await requestJSON('GET', '/api/v2/job/range');
        logUI('Диапазон получен через v2');
        if (Number.isFinite(Number(data?.sensor_count))) {
          rangeSensorCount = Number(data.sensor_count);
          rangeSensorCountKnown = true;
          log(`Диапазон: найдено ${rangeSensorCount} датчиков`, rangeSensorCount === 0 ? 'warn' : 'ok');
        } else {
          rangeSensorCount = Infinity;
          rangeSensorCountKnown = false;
          log('Диапазон: количество датчиков неизвестно', false);
        }
        if (!data || !data.from || !data.to) {
          log('Диапазон: нет данных', false);
          return;
        }
        if (intoDialog && els.rangeFrom && els.rangeTo) {
          els.rangeFrom.value = isoToLocalInput(data.from);
          els.rangeTo.value = isoToLocalInput(data.to);
        } else {
          els.inputs.from.value = data.from;
          els.inputs.to.value = data.to;
          log(`Диапазон установлен: ${data.from} → ${data.to}`);
          updateRangeLabel();
        }
      } catch (err) {
        log(`Диапазон: ${err.message}`, false);
      }
    }
  </script>
</body>
</html>
