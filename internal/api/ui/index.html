<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>TimeMachine Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root { font-family: "Space Grotesk", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif; color: #e5e7eb; background: #0b1220; }
    * { box-sizing: border-box; }
    body { margin: 0; background: radial-gradient(circle at 10% 10%, rgba(20,184,166,0.08), transparent 22%), radial-gradient(circle at 80% 0%, rgba(14,165,233,0.12), transparent 30%), #0b1220; }
    .page { max-width: 1200px; margin: 0 auto; padding: 26px 18px 60px; }
    .header { display: flex; justify-content: space-between; gap: 14px; align-items: center; }
    .title h1 { margin: 4px 0 6px; font-size: 26px; color: #f8fafc; letter-spacing: -0.01em; }
    .eyebrow { text-transform: uppercase; font-size: 12px; letter-spacing: 0.24em; color: #f8fafc; margin: 0; }
    .chips { display: flex; gap: 8px; flex-wrap: wrap; }
    .chip { padding: 8px 12px; border-radius: 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.12); color: #e2e8f0; font-weight: 600; font-size: 13px; display: inline-flex; align-items: center; gap: 6px; }
    .chip.ok { color: #10b981; border-color: rgba(16,185,129,0.4); background: rgba(16,185,129,0.12); }
    .chip.warn { color: #f59e0b; border-color: rgba(245,158,11,0.35); background: rgba(245,158,11,0.12); }
    .chip.err { color: #f87171; border-color: rgba(248,113,113,0.4); background: rgba(248,113,113,0.12); }
    .card { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 14px 16px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); margin-top: 14px; }
    .row { display: flex; gap: 10px; }
    .row.wrap { flex-wrap: wrap; }
    .row.center { align-items: center; }
    label { display: block; font-size: 12px; color: #9ca3af; margin-bottom: 4px; }
    input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #233143; background: #0b1324; color: #e2e8f0; font-size: 14px; outline: none; }
    input:focus { border-color: #22d3ee; box-shadow: 0 0 0 3px rgba(34,211,238,0.12); }
    input::placeholder { color: #94a3b8; }
    button { border: none; border-radius: 12px; padding: 12px; background: linear-gradient(135deg, #0ea5e9, #14b8a6); color: #0b1220; font-weight: 700; cursor: pointer; transition: transform 0.08s ease, box-shadow 0.14s ease, opacity 0.12s, background 0.12s, color 0.12s, border-color 0.12s; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 10px 28px rgba(14,165,233,0.35); }
    button:active:not(:disabled) { background: linear-gradient(135deg, #0284c7, #0ea5e9); box-shadow: 0 6px 18px rgba(14,165,233,0.28); }
    button:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; background: #1b2535; color: #94a3b8; }
    .ghost { background: rgba(255,255,255,0.06); color: #e2e8f0; border: 1px solid #1f2937; }
    .player button { background: #111a2b; color: #e2e8f0; border: 1px solid #233143; border-radius: 10px; padding: 0 10px; height: 42px; min-width: 0; display: inline-flex; align-items: center; justify-content: center; gap: 4px; font-size: 13px; transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease; }
    .player button:hover:not(:disabled) { background: #16223a; border-color: #2f3f58; }
    .player button:disabled { opacity: 0.55; cursor: not-allowed; background: #0b1324; color: #94a3b8; }
    .play-btn { background: #111a2b; color: #e2e8f0; border: 1px solid #233143; }
    .input-with-btn { display: grid; grid-template-columns: 1fr auto; gap: 6px; }
    .picker-btn { width: 42px; padding: 10px 0; border-radius: 10px; border: 1px solid #233143; background: #111a2b; color: #e2e8f0; font-weight: 700; }
    .picker-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .preset-row { display: flex; gap: 8px; flex-wrap: wrap; }
    .preset-btn { padding: 8px 10px; border-radius: 10px; background: #111a2b; border: 1px solid #233143; color: #e2e8f0; font-weight: 600; cursor: pointer; }
    .preset-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .status-line { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .status-item { background: #0b1324; border: 1px solid #1f2937; border-radius: 10px; padding: 8px 10px; color: #e5e7eb; font-weight: 600; min-width: 120px; }
    .status-item span { color: #94a3b8; font-size: 11px; text-transform: uppercase; letter-spacing: 0.06em; display: block; }
    .status-value { font-weight: 700; color: #e5e7eb; padding: 0; line-height: 20px; }
    .status-ok { color: #34d399; }
    .status-warn { color: #fbbf24; }
    .status-err { color: #f87171; }
    .badge-done { background: rgba(16,185,129,0.12); border: 1px solid rgba(16,185,129,0.35); color: #34d399; border-radius: 8px; padding: 4px 8px; display: inline-block; font-weight: 700; }
    .error-text { color: #f87171; min-height: 18px; font-size: 13px; }
    .muted { color: #94a3b8; font-size: 12px; }
    .timeline { display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; }
    .timeline input[type="range"] { width: 100%; accent-color: #22d3ee; }
    .timeline-label { font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #cbd5e1; }
    .player { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
    .toggle { display: flex; align-items: center; gap: 6px; color: #cbd5e1; font-size: 13px; }
    .log { background: #0b1324; border: 1px solid #1f2937; border-radius: 12px; padding: 12px; max-height: 280px; overflow: auto; font-family: "JetBrains Mono", ui-monospace, monospace; font-size: 12px; color: #e2e8f0; }
    .log-entry { padding: 7px 8px; border-radius: 8px; margin-bottom: 6px; border: 1px solid rgba(255,255,255,0.06); background: rgba(255,255,255,0.03); }
    .log-entry.ok { border-color: rgba(16,185,129,0.4); }
    .log-entry.warn { border-color: rgba(245,158,11,0.45); }
    .log-entry.err { border-color: rgba(248,113,113,0.45); }
    .log-entry .ts { color: #9ca3af; font-size: 11px; margin-bottom: 2px; }
    dialog { border: 1px solid #1f2937; background: #0f172a; color: #e2e8f0; border-radius: 12px; padding: 16px; min-width: 320px; box-shadow: 0 20px 60px rgba(0,0,0,0.55); }
    dialog::backdrop { background: rgba(0,0,0,0.55); }
    .dlg-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
    .tabs { display: flex; gap: 10px; margin: 16px 0 4px; }
    .tab { padding: 10px 14px; border-radius: 12px; border: 1px solid #1f2937; background: #0f172a; color: #e2e8f0; font-weight: 700; cursor: pointer; }
    .tab.active { border-color: #22d3ee; box-shadow: 0 8px 24px rgba(34,211,238,0.16); }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .table-wrap { overflow: auto; max-height: 520px; border: 1px solid #1f2937; border-radius: 12px; }
    table { width: 100%; border-collapse: collapse; background: #0f141a; }
    th, td { padding: 10px 12px; text-align: left; border-bottom: 1px solid #1f2937; color: #e5e7eb; }
    th { position: sticky; top: 0; background: #111a24; z-index: 1; }
    tbody tr:nth-child(odd) { background-color: #0e1a2c; }
    tbody tr:nth-child(even) { background-color: #101f35; }
    tbody tr.changed { position: relative; }
    tbody tr.changed td:first-child { position: relative; }
    tbody tr.changed td:first-child::before { content: ""; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; background: #1c93d3; opacity: 0.9; }
    tbody tr.selected { background: rgba(34,211,238,0.12); }
    tbody tr.selected:nth-child(even) { background: rgba(34,211,238,0.14); }
    td.value { font-family: "JetBrains Mono", ui-monospace, monospace; width: 140px; white-space: nowrap; }
    th.value { width: 140px; }
    .table-graph-btn { padding: 6px 10px; background: #0f172a; border: 1px solid #1f2937; border-radius: 8px; color: #e5e7eb; cursor: pointer; min-width: 38px; text-align: center; }
    .table-graph-btn:hover { border-color: #22d3ee; color: #22d3ee; }
    .table-meta { color: #94a3b8; font-size: 13px; }
    .badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; background: rgba(255,255,255,0.06); border: 1px solid #1f2937; }
    .chart-wrap { background: #0f172a; border: 1px solid #1f2937; border-radius: 14px; padding: 12px; box-shadow: 0 12px 36px rgba(0,0,0,0.4); min-height: 420px; }
    .chart-box { width: 100%; max-width: 1100px; min-width: 720px; height: 420px; min-height: 320px; margin: 0 auto; position: relative; overflow: hidden; }
    .chart-box.step { height: 220px; min-height: 160px; }
    .chart-controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
    .chart-controls input { max-width: 320px; }
    .chart-meta { color: #94a3b8; font-size: 13px; display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .chart-legend-wrap { height: 180px; min-height: 140px; max-height: 360px; overflow-y: auto; overflow-x: hidden; border: 1px solid #1f2937; border-radius: 10px; margin-top: 8px; position: relative; padding-bottom: 10px; }
    .chart-legend-table { width: 100%; border-collapse: collapse; font-size: 13px; color: #e5e7eb; }
    .chart-legend-table th, .chart-legend-table td { padding: 6px 8px; border-bottom: 1px solid #1f2937; }
    .chart-legend-table th:nth-child(1), .chart-legend-table td:nth-child(1) { width: 32px; text-align: center; }
    .chart-legend-table th:nth-child(2), .chart-legend-table td:nth-child(2) { width: 20%; }
    .chart-legend-table th:nth-child(3), .chart-legend-table td:nth-child(3) { width: 18%; }
    .chart-legend-table th:nth-child(4), .chart-legend-table td:nth-child(4) { width: 20%; }
    .chart-legend-table th:nth-child(5), .chart-legend-table td:nth-child(5) { width: auto; }
    .chart-legend-table th:nth-child(6), .chart-legend-table td:nth-child(6) { text-align: right; width: 60px; }
    .chart-legend-color { width: 14px; height: 14px; border-radius: 50%; display: inline-block; border: 1px solid #1f2937; }
    .chart-color-btn { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #334155; background: #22d3ee; padding: 0; cursor: pointer; }
    .legend-muted { opacity: 0.4; }
    .legend-active { opacity: 1; }
    .chart-color-input { width: 32px; height: 24px; padding: 0; border: none; background: transparent; cursor: pointer; }
    .chart-suggest-wrap { position: relative; }
    .chart-suggest-box { position: absolute; top: 100%; left: 0; right: 0; background: #0f172a; border: 1px solid #1f2937; border-radius: 10px; margin-top: 4px; box-shadow: 0 12px 30px rgba(0,0,0,0.4); max-height: 220px; overflow-y: auto; z-index: 5; display: none; }
    .resize-handle { position: relative; left: 0; right: 0; height: 12px; cursor: ns-resize; background: linear-gradient(180deg, rgba(148,163,184,0.15), rgba(148,163,184,0.05)); border-top: 1px solid #1f2937; display: flex; align-items: center; justify-content: center; }
    .resize-handle::after { content: ''; width: 38px; height: 4px; border-radius: 999px; background: rgba(148,163,184,0.45); }
    .chart-resize-handle { margin-top: 6px; }
    .legend-resize-handle { position: sticky; left: 0; right: 0; bottom: 0; height: 12px; margin-top: 4px; cursor: ns-resize; z-index: 2; }
    .chart-suggest-item { padding: 8px 10px; cursor: pointer; color: #e5e7eb; }
    .chart-suggest-item:hover { background: rgba(34,211,238,0.08); }
    .chart-suggest-item.active { background: rgba(34,211,238,0.12); }
    .chart-suggestion-highlight { color: #22d3ee; font-weight: 700; }
    datalist { display: none; }
    .input-disabled { opacity: 0.5; pointer-events: none; }
  </style>
</head>
<body>
  <div class="page">
    <div class="header">
      <div class="title">
        <p class="eyebrow" style="color:#f8fafc;">TimeMachine ¬∑ Player ¬∑ v2</p>
        <h1 style="color:#94a3b8;">Sensors history</h1>
      </div>
      <div style="display:flex; flex-direction:column; gap:10px; align-items:flex-end; min-width:320px;">
        <div class="status-line" style="justify-content:flex-end; gap:10px;">
          <div class="status-item"><span>Status</span><div id="chipStatus">idle</div></div>
          <div id="statusBadge" style="display:none;">idle</div>
          <div class="status-item"><span>Step</span><div id="statStep">-</div></div>
          <div class="status-item"><span>TS</span><div id="statTs">-</div></div>
          <div class="status-item"><span>Updates</span><div id="statUpdates">-</div></div>
        </div>
      </div>
    </div>

      <div class="tabs" style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
        <div style="display:flex; gap:8px; flex-wrap:wrap;">
          <button class="tab active" data-tab="control">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</button>
          <button class="tab" data-tab="table">–î–∞—Ç—á–∏–∫–∏</button>
          <button class="tab" data-tab="charts">–ì—Ä–∞—Ñ–∏–∫–∏</button>
        </div>
        <div class="player" style="display:flex; gap:8px; align-items:center; background:#0f172a; border:1px solid #1f2937; border-radius:14px; padding:6px 8px;">
          <button id="stepBackBtn" class="ghost" aria-label="–®–∞–≥ –Ω–∞–∑–∞–¥" title="–®–∞–≥ –Ω–∞–∑–∞–¥" style="width:60px;" disabled>‚èÆ</button>
          <button id="playPauseBtn" class="play-btn" aria-label="Play/Pause" title="Play/Pause" style="width:88px;" disabled>‚ñ∂Ô∏è Play</button>
          <button id="stopBtn" class="ghost" aria-label="Stop" title="Stop" style="width:88px; font-size:15px;" disabled>‚ñ† Stop</button>
          <button id="stepFwdBtn" class="ghost" aria-label="–®–∞–≥ –≤–ø–µ—Ä—ë–¥" title="–®–∞–≥ –≤–ø–µ—Ä—ë–¥" style="width:60px;" disabled>‚è≠</button>
        </div>
        <div class="chips" style="justify-content:flex-end; display:flex; gap:10px; flex-wrap:wrap;">
          <span class="chip" id="wsSpeedChip">ws ‚Äî</span>
          <span class="chip ok" id="pollingChip">polling 1.5s</span>
          <span class="chip">REST /api/v2/*</span>
        </div>
      </div>

    <div id="panel-control" class="tab-panel active">
    <div class="card">
      <div class="row wrap" style="gap:12px; align-items:flex-end;">
        <div style="flex:2; min-width: 320px;">
          <label>–î–∏–∞–ø–∞–∑–æ–Ω</label>
          <button id="rangePickerBtn" class="ghost" type="button" style="width:100%; text-align:left; padding:12px 12px;">
            –î–∏–∞–ø–∞–∑–æ–Ω: <span id="rangeLabelValue" style="color:#fbbf24;">–Ω–µ –∑–∞–¥–∞–Ω</span>
          </button>
        </div>
        <div style="flex:1; min-width: 160px;">
          <label for="saveToSM">–°–æ—Ö—Ä–∞–Ω—è—Ç—å –≤ SM</label>
          <label style="display:flex; align-items:center; gap:8px; font-size:14px; cursor:pointer; user-select:none;">
            <input id="saveToSM" type="checkbox" style="width:18px; height:18px;">
            <span style="color:#e5e7eb;">–í–∫–ª—é—á–∏—Ç—å</span>
          </label>
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="step">–®–∞–≥</label>
          <input id="step" type="text" value="1s">
        </div>
        <div style="flex:1; min-width: 120px;">
          <label for="speed">–°–∫–æ—Ä–æ—Å—Ç—å</label>
          <input id="speed" type="number" step="0.1" value="1">
        </div>
        <div style="flex:1; min-width: 140px;">
          <label for="window">–ö—ç—à</label>
          <input id="window" type="text" value="15s">
        </div>
      </div>
      <div style="display:none;">
        <input id="from" type="text" placeholder="2024-06-01T00:00:00Z">
        <input id="to" type="text" placeholder="2024-06-01T01:00:00Z">
      </div>
      <div class="muted" id="startErrors" style="margin-top:8px;"></div>
    </div>

    <div class="card">
      <div class="timeline">
        <div class="timeline-label" id="fromLabel">from: -</div>
        <input id="timeline" type="range" min="0" max="1000" value="0" disabled>
        <div class="timeline-label" id="toLabel">to: -</div>
      </div>
      <div class="row center" style="justify-content:space-between; margin-top:8px; gap:10px; flex-wrap:wrap; width:100%;">
        <div style="flex:1; display:flex; justify-content:flex-start;">
          <button class="ghost" id="jumpStartBtn" type="button" style="padding:8px 10px;">–í –Ω–∞—á–∞–ª–æ</button>
        </div>
        <div style="flex:1; display:flex; justify-content:center;">
          <div class="status-item" style="min-width:200px; text-align:center;">
            <div id="currentLabel">-</div>
          </div>
        </div>
        <div style="flex:1; display:flex; justify-content:flex-end;">
          <button class="ghost" id="jumpEndBtn" type="button" style="padding:8px 10px;">–í –∫–æ–Ω–µ—Ü</button>
        </div>
      </div>
      <div class="muted" id="errorNote" style="text-align:center; margin-top:6px;"></div>
    </div>

    <div class="card">
      <div class="row center" style="justify-content:space-between; margin-bottom:8px;">
        <h3 style="margin:0; color:#f8fafc; font-size:16px;">–õ–æ–≥</h3>
        <div class="row center" style="gap:8px;">
          <label class="checkbox-inline" style="color:#e5e7eb; font-size:12px;">
            <input type="checkbox" id="diagEnable" style="margin-right:4px; width:auto;"> –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
          </label>
          <button class="ghost" id="diagDownload" style="padding:6px 10px; font-size:12px;" disabled>–í—ã–≥—Ä—É–∑–∏—Ç—å</button>
          <button class="ghost" id="diagClear" style="padding:6px 10px; font-size:12px;" disabled>–û—á–∏—Å—Ç–∏—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É</button>
          <button class="ghost" id="clearLogBtn" style="padding:6px 10px; font-size:12px;">–û—á–∏—Å—Ç–∏—Ç—å</button>
        </div>
      </div>
      <div class="log" id="log"></div>
    </div>
    </div>

    <div id="panel-table" class="tab-panel">
      <div class="card">
        <div class="row center" style="justify-content:flex-start; gap:12px; flex-wrap:wrap;">
          <input id="tableFilter" type="text" placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏–ª–∏ —Ç–µ–∫—Å—Ç..." style="max-width:340px; flex:0 0 auto;">
          <span class="table-meta" id="tableMeta" style="min-width:220px;">‚Äî</span>
        </div>
        <div class="table-wrap" style="margin-top:12px;">
          <table>
            <thead>
              <tr>
                <th style="width:40px; text-align:center;"><input id="tableSelectAll" type="checkbox" style="width:auto; margin:0;"></th>
                <th style="width:180px;">Name</th>
                <th class="value">
                  Value
                  <select id="tablePrecision" style="background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:6px; padding:2px 6px; font-size:12px; margin-left:6px;">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                  </select>
                </th>
                <th>Text</th>
                <th style="width:80px; text-align:center;">–¢–∏–ø</th>
                <th style="width:60px; text-align:center;"></th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div id="panel-charts" class="tab-panel">
      <div class="card">
        <div class="chart-controls">
          <div style="flex:1; min-width:260px;" class="chart-suggest-wrap">
            <label for="chartSensors">–î–æ–±–∞–≤–∏—Ç—å –¥–∞—Ç—á–∏–∫</label>
            <input id="chartSensors" type="text" placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏–ª–∏ —Ç–µ–∫—Å—Ç..." autocomplete="off">
            <div id="chartSuggestionsBox" class="chart-suggest-box"></div>
          </div>
          <div style="display:flex; gap:8px; align-items:flex-end; flex-wrap:wrap;">
            <button id="chartClearBtn" class="ghost" type="button">–û—á–∏—Å—Ç–∏—Ç—å</button>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartAutoUpdate" type="checkbox" checked style="width:auto; margin:0;">
              –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
            </label>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartFill" type="checkbox" checked style="width:auto; margin:0;">
              –§–æ–Ω
            </label>
            <label class="toggle" style="padding:4px 8px; border:1px solid #1f2937; border-radius:10px;">
              <input id="chartSmooth" type="checkbox" checked style="width:auto; margin:0;">
              –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
            </label>
          </div>
          <div class="chart-meta" id="chartMeta">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>
        </div>
        <div class="chart-wrap">
          <div class="chart-box" id="chartBox" style="height:420px;">
            <canvas id="chartCanvas" style="width:100%; height:100%;"></canvas>
          </div>
          <div class="resize-handle chart-resize-handle" id="chartResizeHandle" title="–ü–æ—Ç—è–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –≤—ã—Å–æ—Ç—É –≥—Ä–∞—Ñ–∏–∫–∞"></div>
          <div class="chart-box step" id="chartBoxStep" style="height:220px; margin-top:12px;">
            <canvas id="chartCanvasStep" style="width:100%; height:100%;"></canvas>
          </div>
          <div class="resize-handle chart-resize-handle" id="chartResizeHandleStep" title="–ü–æ—Ç—è–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –≤—ã—Å–æ—Ç—É –¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∏–∫–∞"></div>
          <div id="chartEmpty" class="muted" style="text-align:center; margin-top:8px;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</div>
          <div class="chart-legend-wrap" id="chartLegendWrap" style="height:180px; overflow-y:auto; overflow-x:hidden;">
            <table class="chart-legend-table" id="chartLegendTable">
              <thead><tr>
                <th></th>
                <th>–î–∞—Ç—á–∏–∫</th>
                <th>
                  –ó–Ω–∞—á–µ–Ω–∏–µ,
                  <select id="chartPrecision" style="background:#0f172a; color:#e5e7eb; border:1px solid #1f2937; border-radius:6px; padding:2px 6px; font-size:12px;">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                  </select>
                </th>
                <th>–í—Ä–µ–º—è</th>
                <th>–¢–µ–∫—Å—Ç</th>
                <th></th>
              </tr></thead>
              <tbody id="chartLegendBody"></tbody>
            </table>
          </div>
            <div class="resize-handle legend-resize-handle" id="legendResizeHandle" title="–ü–æ—Ç—è–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –≤—ã—Å–æ—Ç—É –ª–µ–≥–µ–Ω–¥—ã"></div>
          </div>
      </div>
    </div>
  </div>

  <dialog id="datetimeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 6px;">–í—ã–±–æ—Ä –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏</h3>
      <p class="muted" style="margin:0 0 10px;">–õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è ‚Üí —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∫ RFC3339 —Å Z.</p>
      <input id="dtInput" type="datetime-local" step="1" style="width:100%; padding:10px 12px; border-radius:10px; border:1px solid #233143; background:#0b1324; color:#e2e8f0;">
      <div class="dlg-actions">
        <button type="submit" value="cancel" class="ghost">–û—Ç–º–µ–Ω–∞</button>
        <button type="submit" value="ok">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
      </div>
    </form>
  </dialog>

  <dialog id="colorDialog">
    <form method="dialog">
      <div style="display:flex; align-items:center; gap:12px; margin-bottom:10px;">
        <input id="colorInput" type="color" style="appearance:none; width:42px; height:42px; padding:0; border:1px solid #1f2937; border-radius:8px; background:transparent; cursor:pointer;">
        <span style="font-size:15px; font-weight:700; color:#e5e7eb;">–í—ã–±—Ä–∞—Ç—å —Ü–≤–µ—Ç</span>
      </div>
      <div class="dlg-actions">
        <button type="submit" value="ok">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        <button type="submit" value="cancel" class="ghost">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </form>
  </dialog>

  <dialog id="rangeDialog">
    <form method="dialog">
      <h3 style="margin:0 0 8px;">–î–∏–∞–ø–∞–∑–æ–Ω</h3>
      <div class="muted" style="margin-bottom:8px;">–ë—ã—Å—Ç—Ä—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω</div>
      <div class="preset-row" style="margin:0 0 12px; gap:8px; align-items:center;">
        <button class="preset-btn" data-quick-min="5" type="button">5–º</button>
        <button class="preset-btn" data-quick-min="10" type="button">10–º</button>
        <button class="preset-btn" data-quick-min="30" type="button">30–º</button>
        <button class="preset-btn" data-quick-min="60" type="button">1—á</button>
        <button class="preset-btn" data-quick-min="180" type="button">3—á</button>
        <button class="ghost" id="rangeBtn" type="button" style="margin-left:auto;">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω</button>
      </div>
      <div class="row wrap" style="gap:12px;">
        <div style="flex:1; min-width:260px;">
          <label for="rangeDialogFrom">From</label>
          <input id="rangeDialogFrom" type="datetime-local" step="1">
        </div>
        <div style="flex:1; min-width:260px;">
          <label for="rangeDialogTo">To</label>
          <input id="rangeDialogTo" type="datetime-local" step="1">
        </div>
      </div>
      <div class="dlg-actions">
        <button type="submit" value="ok">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
        <button type="submit" value="cancel" class="ghost">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </form>
  </dialog>

  <script src="/ui/chart.umd.min.js"></script>
  <script src="/ui/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="/ui/chartjs-plugin-zoom.min.js"></script>
  <script>
  // –î–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ (–≤ UI –∏ –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏).
  const logUIEnabled = false;
  const diagBuffer = [];
  const diagLimit = 1000;
  function updateDiagButtons() {
    if (typeof els === 'undefined' || !els || !els.diagEnable) return;
    els.diagEnable.checked = !!state.diagEnabled;
    const has = diagBuffer.length > 0;
    if (els.diagDownload) els.diagDownload.disabled = !has;
    if (els.diagClear) els.diagClear.disabled = !has;
  }
  function pushDiag(line) {
    if (!state.diagEnabled) return;
    diagBuffer.push(line);
    if (diagBuffer.length > diagLimit) diagBuffer.shift();
    updateDiagButtons();
  }
  function downloadDiag() {
    if (!diagBuffer.length) return;
    const blob = new Blob([diagBuffer.join('\n')], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const ts = new Date().toISOString().replace(/[:.]/g, '-');
    a.href = url;
    a.download = `diagnostics-${ts}.txt`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }
  function clearDiag() {
    diagBuffer.length = 0;
    updateDiagButtons();
  }
  const logUI = (msg, warn = false) => {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    if (logUIEnabled) console.info(`[UI LOG] ${msg}`);
    pushDiag(line);
  };
  const chartLogEnabled = true;
  const chartLog = (msg, payload) => {
    if (!chartLogEnabled) return;
    if (payload !== undefined) {
      console.info(`[chart] ${msg}`, payload);
    } else {
      console.info(`[chart] ${msg}`);
    }
    pushDiag(`[${new Date().toLocaleTimeString()}] [chart] ${msg}${payload ? ' ' + JSON.stringify(payload).slice(0, 200) : ''}`);
  };

    const els = {
      inputs: {
        from: document.getElementById('from'),
        to: document.getElementById('to'),
        step: document.getElementById('step'),
        speed: document.getElementById('speed'),
        window: document.getElementById('window'),
        saveToSM: document.getElementById('saveToSM'),
      },
      tabs: document.querySelectorAll('[data-tab]'),
      panels: {
        control: document.getElementById('panel-control'),
        table: document.getElementById('panel-table'),
        charts: document.getElementById('panel-charts'),
      },
      startErrors: document.getElementById('startErrors'),
      chipStatus: document.getElementById('chipStatus'),
      wsSpeed: document.getElementById('wsSpeedChip'),
      status: {
        badge: document.getElementById('statusBadge'),
        error: document.getElementById('errorNote'),
        step: document.getElementById('statStep'),
        ts: document.getElementById('statTs'),
        updates: document.getElementById('statUpdates'),
      },
      testChip: document.getElementById('testChip'),
      timeline: document.getElementById('timeline'),
      fromLabel: document.getElementById('fromLabel'),
      toLabel: document.getElementById('toLabel'),
      currentLabel: document.getElementById('currentLabel'),
      controls: {
        stepBack: document.getElementById('stepBackBtn'),
        playPause: document.getElementById('playPauseBtn'),
        stop: document.getElementById('stopBtn'),
        stepFwd: document.getElementById('stepFwdBtn'),
        jumpStart: document.getElementById('jumpStartBtn'),
        jumpEnd: document.getElementById('jumpEndBtn'),
      },
      log: document.getElementById('log'),
      clearLog: document.getElementById('clearLogBtn'),
      diagEnable: document.getElementById('diagEnable'),
      diagDownload: document.getElementById('diagDownload'),
      diagClear: document.getElementById('diagClear'),
      dialog: document.getElementById('datetimeDialog'),
      dialogInput: document.getElementById('dtInput'),
      rangePicker: document.getElementById('rangePickerBtn'),
      rangeDialog: document.getElementById('rangeDialog'),
      rangeFrom: document.getElementById('rangeDialogFrom'),
      rangeTo: document.getElementById('rangeDialogTo'),
      rangeLabelValue: document.getElementById('rangeLabelValue'),
      table: {
        body: document.getElementById('tableBody'),
        filter: document.getElementById('tableFilter'),
        meta: document.getElementById('tableMeta'),
        precision: document.getElementById('tablePrecision'),
        selectAll: document.getElementById('tableSelectAll'),
      },
      charts: {
        sensors: document.getElementById('chartSensors'),
        clear: document.getElementById('chartClearBtn'),
        meta: document.getElementById('chartMeta'),
        empty: document.getElementById('chartEmpty'),
        suggestions: document.getElementById('chartSensorsSuggestions'),
        suggestBox: document.getElementById('chartSuggestionsBox'),
        canvas: document.getElementById('chartCanvas'),
        stepCanvas: document.getElementById('chartCanvasStep'),
        box: document.getElementById('chartBox'),
        boxStep: document.getElementById('chartBoxStep'),
        resizeHandle: document.getElementById('chartResizeHandle'),
        resizeHandleStep: document.getElementById('chartResizeHandleStep'),
        legendBody: document.getElementById('chartLegendBody'),
        legendWrap: document.getElementById('chartLegendWrap'),
        legendHandle: document.getElementById('legendResizeHandle'),
        fill: document.getElementById('chartFill'),
        autoUpdate: document.getElementById('chartAutoUpdate'),
        precision: document.getElementById('chartPrecision'),
        colorDialog: document.getElementById('colorDialog'),
        colorInput: document.getElementById('colorInput'),
        smooth: document.getElementById('chartSmooth'),
      },
      rangeBtn: document.getElementById('rangeBtn'),
    };
    const inputs = els.inputs;
    // –°—Ç–∞—Ä—Ç–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è: –±–ª–æ–∫–∏—Ä—É–µ–º –ø–ª–µ–µ—Ä –¥–æ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.
    setDisabled(els.controls.playPause, true);
    setDisabled(els.controls.stop, true);
    setDisabled(els.controls.stepBack, true);
    setDisabled(els.controls.stepFwd, true);
    setDisabled(els.timeline, true);

    // Fallbacks for tests: ensure invisible statusBadge exists.
    if (!els.status.badge) {
      const badge = document.createElement('div');
      badge.id = 'statusBadge';
      badge.style.display = 'none';
      badge.textContent = 'idle';
      document.body.appendChild(badge);
      els.status.badge = badge;
    }

  const state = {
      model: { status: 'idle' },
      pollingMs: 1500,
      pollErrorNotified: false,
      ws: null,
      reconnectIn: null,
      previewTs: null,
      lastParamsSig: '',
      pausedAtTs: null,
      testRunning: false,
      saveAllowed: false,
      wsBytes: [],
      saveDirty: false,
      diagEnabled: false,
      rangePicked: false,
    };

    syncSaveToggle();

    setInterval(updateWsChip, 1000);
    window.addEventListener('offline', () => {
      state.ws = null;
      state.wsBytes = [];
      updateWsChip();
    });
    window.addEventListener('online', () => {
      updateWsChip();
      if (!state.ws) {
        connectWS();
      }
    });

    window.__setTestIndicator = (active, text = '–ò–¥—ë—Ç —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ‚Ä¶') => {
      state.testRunning = !!active;
      // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∑–µ–ª—ë–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∏–∑ —Ç–µ—Å—Ç-—Ö–µ–ª–ø–µ—Ä–∞; —à—Ç–∞—Ç–Ω—ã–π —á–∏–ø —Å–∫—Ä—ã–≤–∞–µ–º.
      if (els.testChip) {
        els.testChip.style.display = 'none';
      }
    };

  const tableState = {
    rows: new Map(),
    meta: new Map(),
    filter: '',
    lastStep: '-',
    lastTs: '-',
    precision: 3,
    selected: new Set(),
  };
    const chartState = {
      selected: [],
      datasets: new Map(), // id -> {label,color,data: [{x,y}], lastValue}
      chart: null,
      chartStep: null,
      maxPoints: 800,
      autoUpdate: true,
      smooth: true,
      windowSec: 300,
      lastParamsSig: '',
      lastSkip: '',
      range: { from: null, to: null },
      suggest: { items: [], active: -1, locked: false, lastQuery: '' },
      focused: null,
      pendingChartUpdate: false,
    };
  const sensorIndex = {
      byId: new Map(),    // id -> {id,name,textname}
      byName: new Map(),  // lower(name) -> id
      hydrated: false,
    };

  function getSensorMeta(id) {
    return sensorIndex.byId.get(id) || tableState.meta.get(id) || {};
  }
  function getSensorType(id) {
    const t = (getSensorMeta(id)?.iotype || '').toString().toUpperCase();
    return t;
  }
  function isDiscreteIO(io) {
    const t = (io || '').toString().toUpperCase();
    return t === 'DI' || t === 'DO';
  }
  function isAnalogIO(io) {
    const t = (io || '').toString().toUpperCase();
    if (!t) return true;
    return t === 'AI' || t === 'AO' || t === '';
  }
  function isDiscreteSensor(id) {
    const t = getSensorType(id);
    return isDiscreteIO(t);
  }
  function isAnalogSensor(id) {
    const t = getSensorType(id);
    return isAnalogIO(t);
  }

  let chartValuePrecision = 3;
  let tableValuePrecision = 3;
  let tableRenderTimer = null;
  let tableFilterTimer = null;
  let chartUpdateTimer = null;
  const chartMaxSeries = 30;
  const chartAutoAddLimit = 30;
  let rangeSensorCount = Infinity;
  let rangeSensorCountKnown = false;

  function clamp(v, min, max) {
    return Math.min(Math.max(v, min), max);
  }

  function itemHasValue(item, hadValue = false) {
    if (!item || typeof item !== 'object') return hadValue;
    if (item.value !== undefined && item.value !== null) return true;
    if (item.has_value !== undefined) return !!item.has_value || hadValue;
    if (item.hasValue !== undefined) return !!item.hasValue || hadValue;
    return hadValue;
  }

  function normalizeUpdates(msg) {
    if (Array.isArray(msg?.u)) {
      return msg.u
        .map((row) => {
          const id = Number(row?.[0]);
          if (!Number.isFinite(id)) return null;
          const value = row?.[1];
          const has = (row?.length || 0) > 2 ? row[2] !== 0 : true;
          return { id, value, has_value: has };
        })
        .filter(Boolean);
    }
    if (Array.isArray(msg?.updates)) return msg.updates;
    if (Array.isArray(msg?.Updates)) return msg.Updates;
    return [];
  }

  function toStepValue(v) {
    if (v === null || v === undefined) return 0;
    const num = Number(v);
    if (!Number.isFinite(num)) return 0;
    return num > 0 ? 1 : 0;
  }

  function formatChartValue(v) {
    if (v === null || v === undefined) return '0';
    const num = Number(v);
    if (!Number.isFinite(num)) return '0';
    return num.toFixed(chartValuePrecision);
  }

  function formatTableValue(v) {
    if (v === null || v === undefined) return '0';
    const num = Number(v);
    if (!Number.isFinite(num)) return '0';
    return num.toFixed(tableValuePrecision);
  }

    function log(message, state = true) {
      const level = typeof state === 'string' ? state : (state ? 'ok' : 'err');
      const row = document.createElement('div');
      row.className = `log-entry ${level}`;
      row.innerHTML = `<div class="ts">${new Date().toLocaleTimeString()}</div><div>${message}</div>`;
      els.log.prepend(row);
      while (els.log.children.length > 200) {
        els.log.removeChild(els.log.lastChild);
      }
      pushDiag(`[${new Date().toLocaleTimeString()}] [log] ${message}`);
    }

    function trackWsBytes(n) {
      const now = Date.now();
      state.wsBytes.push({ t: now, n });
      // –û—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 —Å–µ–∫—É–Ω–¥.
      const cutoff = now - 5000;
      while (state.wsBytes.length && state.wsBytes[0].t < cutoff) {
        state.wsBytes.shift();
      }
    }

    function formatSpeed(bytesPerSec) {
      if (!Number.isFinite(bytesPerSec) || bytesPerSec <= 0) return '‚Äî';
      const kb = 1024;
      const mb = kb * 1024;
      if (bytesPerSec >= mb) return `${(bytesPerSec / mb).toFixed(1)} MB/s`;
      if (bytesPerSec >= kb) return `${(bytesPerSec / kb).toFixed(1)} kB/s`;
      return `${bytesPerSec.toFixed(0)} B/s`;
    }

    function updateWsChip() {
      if (!els.wsSpeed) return;
      const now = Date.now();
      const cutoff = now - 5000;
      state.wsBytes = state.wsBytes.filter(item => item.t >= cutoff);
      const total = state.wsBytes.reduce((acc, item) => acc + item.n, 0);
      const windowSec = 5;
      const speed = total / windowSec;
      const online = !!state.ws;
      els.wsSpeed.textContent = `ws ${online ? formatSpeed(speed) : '‚Äî'}`;
      els.wsSpeed.classList.toggle('ok', online);
      els.wsSpeed.classList.toggle('warn', !online);
    }

    function setTab(tab) {
      els.tabs.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
      Object.entries(els.panels).forEach(([name, node]) => {
        if (!node) return;
        node.classList.toggle('active', name === tab);
      });
      if (tab === 'charts') {
        setTimeout(() => {
          rebuildChart(true);
          if (!chartState.chartStep) {
            const hasRange = chartState.range.from && chartState.range.to;
            rebuildStepChart(hasRange);
          }
        }, 0);
      }
    }

    function connectWS() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      const host = location.host || 'localhost:8080';
      const url = `${proto}://${host}/api/v2/ws/state`;
      try {
        const ws = new WebSocket(url);
        state.ws = ws;
        ws.onopen = () => {
          state.wsBytes = [];
          updateWsChip();
          log('WS: connected');
        };
        ws.onclose = () => {
          state.ws = null;
          state.wsBytes = [];
          updateWsChip();
          if (state.reconnectIn) clearTimeout(state.reconnectIn);
          state.reconnectIn = setTimeout(connectWS, 2000);
        };
        ws.onerror = () => ws.close();
        ws.onmessage = (ev) => {
          if (typeof ev.data === 'string') {
            trackWsBytes(ev.data.length);
          } else if (ev.data && typeof ev.data.size === 'number') {
            // Blob-like
            trackWsBytes(ev.data.size);
          } else if (ev.data && ev.data.byteLength) {
            trackWsBytes(ev.data.byteLength);
          }
          try {
            const msg = JSON.parse(ev.data);
            handleWSMessage(msg);
          } catch (err) {
            log(`WS parse: ${err.message}`, false);
            fetchSnapshotFallback();
            ws.close();
          }
        };
      } catch (err) {
        log(`WS connect: ${err.message}`, false);
      }
    }

    function unixToISO(v) {
      if (!Number.isFinite(v) || v <= 0) return '';
      const d = new Date(v);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function handleWSMessage(msg) {
      if (!msg || typeof msg !== 'object') return;
      const tsStr = msg.step_ts || unixToISO(msg.step_unix);
      if (msg.step_id !== undefined) {
        tableState.lastStep = msg.step_id || 0;
      }
      if (tsStr) {
        tableState.lastTs = tsStr;
        state.pausedAtTs = tsStr;
      }
    const normalizedUpdates = normalizeUpdates(msg);
      switch (msg.type) {
      case 'reset':
        tableState.rows.clear();
        seedTableFromMeta();
        if (!sensorIndex.hydrated) {
          preloadSensors().catch(() => {});
        }
        scheduleRenderTable(true);
        pushDiag('[ws] reset');
          break;
        case 'snapshot':
          applySnapshot(msg.updates || [], tsStr);
          appendChartPoint(tsStr, msg.updates || []);
          break;
        case 'updates':
          applyTableUpdates(normalizedUpdates, tsStr);
          appendChartPoint(tsStr, normalizedUpdates);
          break;
        default:
          break;
      }
      scheduleRenderTable();
    }

    function applySnapshot(list, tsStr) {
      if (!Array.isArray(list)) return;
      pushDiag(`[ws] snapshot rows=${list.length} ts=${tsStr || '-'}`);
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        registerSensorMeta(key, item.name, item.textname, item.iotype);
        const hasValue = itemHasValue(item);
        tableState.rows.set(key, {
          id: key,
          name: item.name || `${key}`,
          textname: item.textname || '',
          value: item.value,
          hasValue,
          stepID: tableState.lastStep || 0,
          ts: tsStr || '',
        });
      });
      refreshChartSuggestions();
    }

  function applyTableUpdates(list, tsStr) {
    if (!Array.isArray(list)) return;
    const now = Date.now();
      pushDiag(`[ws] updates rows=${list.length} ts=${tsStr || '-'}`);
      list.forEach(item => {
        const key = Number(item.id);
        if (!Number.isFinite(key)) return;
        const prev = tableState.rows.get(key) || {};
        const hadValue = prev.hasValue;
        const changed = !hadValue || prev.value !== item.value;
        const meta = tableState.meta.get(key) || {};
        const name = item.name || meta.name || prev.name || `${key}`;
        registerSensorMeta(key, name, item.textname || meta.textname || prev.textname, item.iotype || meta.iotype || prev.iotype);
        const hasValue = itemHasValue(item, hadValue);
        tableState.rows.set(key, {
          id: key,
          name,
          textname: item.textname || meta.textname || prev.textname || '',
          value: item.value,
          hasValue,
          stepID: item.step_id || tableState.lastStep || prev.stepID || 0,
          ts: tsStr || tableState.lastTs || prev.ts || '',
          changedAt: changed ? now : prev.changedAt,
        });
      });
      refreshChartSuggestions();
    }

    function scheduleRenderTable(force) {
      if (force) {
        if (tableRenderTimer) {
          clearTimeout(tableRenderTimer);
          tableRenderTimer = null;
        }
        renderTable(true);
        return;
      }
      if (tableRenderTimer) return;
      tableRenderTimer = setTimeout(() => {
        tableRenderTimer = null;
        renderTable();
      }, 50);
    }

    function clearTableFilter() {
      if (!els.table.filter) return;
      els.table.filter.value = '';
      tableState.filter = '';
      els.table.filter.blur();
      scheduleRenderTable(true);
    }

    function getFilteredTableRows(applySelected = true) {
      const filter = (tableState.filter || '').trim();
      const useMeta = !!filter;
      const baseRows = useMeta
        ? Array.from(tableState.meta.entries()).map(([id, meta]) => {
            const row = tableState.rows.get(id) || {};
            const hasValue = !!row.hasValue;
            return {
              id,
              name: meta.name || `${id}`,
              textname: meta.textname || '',
              value: hasValue ? row.value : '‚Äî',
              hasValue,
              stepID: row.stepID,
              ts: row.ts,
              changedAt: row.changedAt,
            };
          })
        : Array.from(tableState.rows.values());
      let filtered = filter
        ? baseRows.filter(r => {
            const name = (r.name || '').toLowerCase();
            const textname = (r.textname || '').toLowerCase();
            return name.includes(filter) || textname.includes(filter);
          })
        : baseRows;
      const applySelection = applySelected && tableState.selected.size > 0 && !filter;
      if (applySelection) {
        filtered = filtered.filter(r => tableState.selected.has(r.id));
      }
      filtered.sort((a, b) => {
        if (a.name === b.name) return a.id - b.id;
        return a.name.localeCompare(b.name);
      });
      return filtered;
    }

    function renderTable(force) {
      if (!els.table.body) return;
      const filtered = getFilteredTableRows(true);
      const now = Date.now();
      const html = filtered.map(r => {
        const isChanged = r.changedAt && now - r.changedAt < 4000;
        const value = r.hasValue ? formatTableValue(r.value) : '‚Äî';
        const metaText = tableState.meta.get(r.id)?.textname || sensorIndex.byId.get(r.id)?.textname || '';
        const metaType = tableState.meta.get(r.id)?.iotype || sensorIndex.byId.get(r.id)?.iotype || '';
        const text = r.textname || metaText || '';
        const checked = tableState.selected.has(r.id) ? 'checked' : '';
        const rowClass = `${isChanged ? 'changed' : ''} ${checked ? 'selected' : ''}`;
        return `<tr class="${rowClass.trim()}">
          <td style="text-align:center;"><input type="checkbox" class="table-select" data-sensor="${r.id}" ${checked}></td>
          <td>${r.name || ''}</td>
          <td class="value">${value}</td>
          <td>${text}</td>
          <td style="text-align:center;">${metaType || ''}</td>
          <td style="text-align:center;"><button class="table-graph-btn" data-chart-add="${r.id}" title="–î–æ–±–∞–≤–∏—Ç—å –Ω–∞ –≥—Ä–∞—Ñ–∏–∫">üìä</button></td>
        </tr>`;
      }).join('');
      els.table.body.innerHTML = html || `<tr><td colspan="6" style="text-align:center; color:#94a3b8; padding:16px;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</td></tr>`;
      if (els.table.meta) {
        const ts = tableState.lastTs || '‚Äî';
        const total = getFilteredTableRows(false).length;
        const sel = tableState.selected.size;
        els.table.meta.textContent = `Step: ${tableState.lastStep || '‚Äî'} ¬∑ ${ts} ¬∑ ${filtered.length}/${total} —Å—Ç—Ä–æ–∫ ¬∑ –í—ã–±—Ä–∞–Ω–æ: ${sel}`;
      }
      if (els.table.filter) {
        setDisabled(els.table.filter, false);
      }
      if (els.table.precision) {
        els.table.precision.value = String(tableState.precision ?? 3);
      }
      if (els.table.selectAll) {
        const base = getFilteredTableRows(false);
        const allSelected = base.length > 0 && base.every(r => tableState.selected.has(r.id));
        els.table.selectAll.checked = allSelected && tableState.selected.size > 0;
        els.table.selectAll.indeterminate = tableState.selected.size > 0 && !allSelected;
      }
    }

    const chartColors = ['#22d3ee', '#34d399', '#f59e0b', '#f472b6', '#a78bfa', '#f87171', '#4ade80', '#60a5fa'];

    function pickChartColor(id, usedColors, idxHint) {
      const used = usedColors || new Set();
      for (let i = 0; i < chartColors.length; i++) {
        const color = chartColors[(idxHint + i) % chartColors.length];
        if (!used.has(color.toLowerCase())) return color;
      }
      const hue = (Number(id) * 37 + (idxHint || 0) * 53) % 360;
      const color = `hsl(${hue}, 68%, 58%)`;
      if (!used.has(color.toLowerCase())) return color;
      const alt = `hsl(${(hue + 27) % 360}, 68%, 58%)`;
      return alt;
    }

    function normalizeHexColor(color) {
      if (typeof color !== 'string') return '#22d3ee';
      let hex = color.trim();
      const shortHex = /^#([0-9a-fA-F]{3})$/;
      const fullHex = /^#([0-9a-fA-F]{6})$/;
      if (shortHex.test(hex)) {
        const expanded = hex.slice(1).split('').map(c => c + c).join('');
        return `#${expanded}`;
      }
      if (fullHex.test(hex)) return hex;
      try {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.fillStyle = hex;
        const computed = ctx.fillStyle;
        if (fullHex.test(computed)) return computed;
      } catch (_) {
        /* ignore */
      }
      return '#22d3ee';
    }

    function chartLabelByID(id) {
      const meta = tableState.meta.get(id) || sensorIndex.byId.get(id) || {};
      if (meta.name) return `${meta.name} (${id})`;
      return `${id}`;
    }

    function registerSensorMeta(id, name, textname, iotype) {
      if (!Number.isFinite(id)) return;
      const prev = tableState.meta.get(id) || {};
      const resolvedName = name || prev.name || `${id}`;
      const resolvedText = textname !== undefined ? textname : prev.textname;
      const resolvedIO = iotype !== undefined ? iotype : prev.iotype;
      tableState.meta.set(id, { name: resolvedName, textname: resolvedText || '', iotype: resolvedIO || '' });
      sensorIndex.byId.set(id, { id, name: resolvedName, textname: resolvedText || '', iotype: resolvedIO || '' });
      sensorIndex.byName.set(String(resolvedName).toLowerCase(), id);
    }

    function knownSensorIdByToken(token) {
      if (!token) return null;
      const num = Number(token);
      if (Number.isFinite(num) && sensorIndex.byId.has(num)) {
        return num;
      }
      const byName = sensorIndex.byName.get(token.toLowerCase());
      return Number.isFinite(byName) ? byName : null;
    }

    function parseChartSensors(input) {
      if (!input) return [];
      const tokens = input.split(',').map(t => t.trim()).filter(Boolean);
      if (!tokens.length) return [];
      const out = [];
      tokens.forEach(tok => {
        const id = knownSensorIdByToken(tok);
        if (Number.isFinite(id)) out.push(id);
      });
      return Array.from(new Set(out));
    }

    function normalizeSensorList(list) {
      if (!Array.isArray(list)) return [];
      const res = [];
      list.forEach((id) => {
        const num = Number(id);
        if (!Number.isFinite(num)) return;
        if (!sensorIndex.byId.has(num)) {
        registerSensorMeta(num, `${num}`, '', '');
        }
        if (sensorIndex.byId.has(num)) res.push(num);
      });
      return Array.from(new Set(res));
    }

    function rebuildChartSeries() {
      const prev = chartState.datasets;
      const next = new Map();
      const used = new Set();
      chartState.selected.forEach((id, idx) => {
        const existing = prev.get(id);
        const preserved = existing?.color;
        const color = preserved || pickChartColor(id, used, idx);
        if (color) used.add(color.toLowerCase());
        const data = existing?.data ? existing.data.slice() : [];
        const lastValue = existing?.lastValue ?? null;
        const lastTs = existing?.lastTs ?? null;
        const iotype = existing?.iotype || getSensorType(id);
        next.set(id, {
          id,
          label: chartLabelByID(id),
          color,
          data: data ? data.slice() : [],
          lastValue,
          lastTs,
          iotype,
        });
      });
      chartState.datasets = next;
      if (chartState.chart) {
        scheduleChartSync();
      } else {
        rebuildChart();
      }
    }

    function updateChartMeta(msg) {
      if (!els.charts.meta) return;
      const sensors = chartState.selected.length ? chartState.selected.map(chartLabelByID).join(', ') : '‚Äî';
      const points = chartState.chart
        ? (chartState.chart.data.labels?.length || 0)
        : Array.from(chartState.datasets.values()).reduce((acc, ds) => Math.max(acc, ds.data?.length || 0), 0);
      let metaText = chartState.selected.length ? `–¢–æ—á–µ–∫: ${points}` : '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö';
      if (chartState.range.from && chartState.range.to) {
        const from = new Date(chartState.range.from).toISOString().replace(/\.\d{3}Z$/, 'Z');
        const to = new Date(chartState.range.to).toISOString().replace(/\.\d{3}Z$/, 'Z');
        metaText += ` ¬∑ X: ${from} ‚Üí ${to}`;
      }
      els.charts.meta.textContent = metaText;
      if (msg) {
        els.charts.meta.textContent += ` ¬∑ ${msg}`;
      }
      if (els.charts.empty) {
        const showEmpty = !chartState.selected.length || points === 0;
        const autoAddNote = rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit
          ? ` ¬∑ –∞–≤—Ç–æ–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ (${rangeSensorCount} –¥–∞—Ç—á–∏–∫–æ–≤, –ª–∏–º–∏—Ç ${chartAutoAddLimit})`
          : '';
        els.charts.empty.textContent = chartState.selected.length
          ? `–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è${autoAddNote}`
          : `–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—á–∏–∫–∏ –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞${autoAddNote}`;
        els.charts.empty.style.display = showEmpty ? 'flex' : 'none';
      }
      if (chartState.selected.length > chartMaxSeries) {
        els.charts.meta.textContent += ` ¬∑ Max ${chartMaxSeries} –ª–∏–Ω–∏–π`;
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.checked = chartState.autoUpdate;
      }
      if (els.charts.window) {
        els.charts.window.value = chartState.windowSec;
      }
    }

    function renderLegendTable() {
      if (!els.charts.legendBody) return;
      try {
        const rows = chartState.selected.map((id) => {
          const ds = chartState.datasets.get(id) || {};
          const val = formatChartValue(ds.lastValue);
          const color = ds.color || '#22d3ee';
          const ts = ds.lastTs ? toRFC3339(new Date(ds.lastTs)) : '‚Äî';
          const text = (sensorIndex.byId.get(id)?.textname) || '‚Äî';
          const muted = chartState.focused !== null && chartState.focused !== id;
          const rowClass = muted ? 'legend-muted' : 'legend-active';
          return `<tr data-sensor="${id}" class="${rowClass}"><td><button class="chart-color-btn" data-sensor="${id}" style="background:${color};"></button></td><td>${chartLabelByID(id)}</td><td>${val}</td><td>${ts}</td><td>${text}</td><td style="text-align:right;"><button class="ghost chart-remove-btn" data-sensor="${id}" type="button" style="padding:6px 10px;">‚úï</button></td></tr>`;
        }).join('');
        els.charts.legendBody.innerHTML = rows || '<tr><td colspan="6" style="color:#94a3b8;">–ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞—Ç—á–∏–∫–æ–≤</td></tr>';
      } catch (err) {
        els.charts.legendBody.innerHTML = `<tr><td colspan="6" style="color:#f87171;">${err?.message || err}</td></tr>`;
      }
    }

    function openColorDialog(id) {
      const dlg = els.charts.colorDialog;
      const input = els.charts.colorInput;
      if (!dlg || !input) return;
      const ds = chartState.datasets.get(id);
      if (!ds) return;
      const color = normalizeHexColor(ds.color || '#22d3ee');
      input.value = color;
      dlg.dataset.sensor = String(id);
      if (!dlg.open) {
        dlg.showModal();
      } else {
        input.focus();
      }
    }

    function refreshChartSuggestions() {
      const opts = [];
      const usedValues = new Set();
      sensorIndex.byId.forEach((meta, id) => {
        if (chartState.selected.includes(id)) return; // —É–∂–µ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ
        const label = meta?.name ? `${meta.name}` : `${id}`;
        const val = meta?.name || `${id}`;
        if (!val || usedValues.has(val)) return;
        usedValues.add(val);
        opts.push({ value: val, label: `${label} (${id})` });
      });
      renderChartSuggestions(els.charts.sensors?.value || '');
      updateChartInputState();
    }

    function renderChartSuggestions(query) {
      if (!els.charts.suggestBox) return;
      const q = (query || '').trim().toLowerCase();
      const sameQuery = q === (chartState.suggest.lastQuery || '');
      if (chartState.suggest.locked && sameQuery && els.charts.suggestBox.style.display === 'block') {
        updateChartInputState();
        return; // –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ, –ø–æ–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–≤–∏–≥–∏—Ä—É–µ—Ç –ø–æ —Å–ø–∏—Å–∫—É
      }
      chartState.suggest.lastQuery = q;
      chartState.suggest.locked = false;
      const items = [];
      let availableCount = 0;
      sensorIndex.byId.forEach((meta, id) => {
        if (chartState.selected.includes(id)) return;
        const name = meta?.name || `${id}`;
        const text = name.toLowerCase();
        if (q && !text.includes(q) && !String(id).includes(q)) return;
        items.push({ id, name });
        availableCount++;
      });
      items.sort((a, b) => a.name.localeCompare(b.name));
      const limited = items.slice(0, 50);
      if (!limited.length || q.length === 0) {
        els.charts.suggestBox.style.display = 'none';
        els.charts.suggestBox.innerHTML = '';
        updateChartInputState(availableCount);
        return;
      }
      chartState.suggest.items = limited;
      chartState.suggest.active = limited.length ? 0 : -1;
      const highlight = (str) => {
        if (!q) return str;
        const idx = str.toLowerCase().indexOf(q);
        if (idx === -1) return str;
        const before = str.slice(0, idx);
        const match = str.slice(idx, idx + q.length);
        const after = str.slice(idx + q.length);
        return `${before}<span class="chart-suggestion-highlight">${match}</span>${after}`;
      };
      els.charts.suggestBox.innerHTML = limited.map((item, idx) => {
        const activeClass = idx === chartState.suggest.active ? 'active' : '';
        return `<div class="chart-suggest-item ${activeClass}" data-sensor="${item.id}">${highlight(item.name)} <span style="color:#94a3b8;">(${item.id})</span></div>`;
      }).join('');
      els.charts.suggestBox.style.display = 'block';
      updateChartInputState(availableCount);
    }

    function hideChartSuggestions() {
      if (!els.charts.suggestBox) return;
      els.charts.suggestBox.style.display = 'none';
      els.charts.suggestBox.innerHTML = '';
      chartState.suggest = { items: [], active: -1, locked: false, lastQuery: chartState.suggest.lastQuery || '' };
    }

    function moveSuggestActive(delta) {
      const items = chartState.suggest.items || [];
      if (!items.length || !els.charts.suggestBox) return;
      chartState.suggest.locked = true;
      const next = (chartState.suggest.active + delta + items.length) % items.length;
      chartState.suggest.active = next;
      Array.from(els.charts.suggestBox.children).forEach((el, idx) => {
        el.classList.toggle('active', idx === next);
      });
    }

    function buildChartDatasets() {
      return Array.from(chartState.datasets.values())
        .filter(ds => isAnalogIO(ds.iotype) && isAnalogSensor(ds.id))
        .map(ds => ({
        label: ds.label,
        data: ds.data,
        borderColor: ds.color || '#22d3ee',
        backgroundColor: els.charts.fill?.checked ? hexToRGBA(ds.color || '#22d3ee', 0.15) : ds.color || '#22d3ee',
        tension: chartState.smooth ? 0.25 : 0,
        spanGaps: true,
        pointRadius: 0,
        borderWidth: 1,
        fill: !!(els.charts.fill && els.charts.fill.checked),
        hidden: chartState.focused !== null && chartState.focused !== ds.id,
      }));
    }

    function getStepOffsets() {
      const offsets = new Map();
      const discrete = chartState.selected.filter(isDiscreteSensor);
      discrete.forEach((id, idx) => offsets.set(id, idx));
      return offsets;
    }

    function buildStepDatasets() {
      const offsets = getStepOffsets();
      const used = new Set(Array.from(chartState.datasets.values()).map(ds => (ds.color || '').toLowerCase()).filter(Boolean));
      const discreteIds = chartState.selected.filter(isDiscreteSensor);
      return discreteIds.map((id, idx) => {
        const ds = chartState.datasets.get(id) || {};
        const color = ds.color || pickChartColor(id, used, idx) || '#22d3ee';
        if (color) used.add(color.toLowerCase());
        return {
          label: ds.label || chartLabelByID(id),
          data: (ds.data || []).map(p => {
            const step = toStepValue(p.y);
            const offset = (offsets.get(id) || 0) * 2;
            return { x: p.x, y: step === null ? null : offset + step };
          }),
          borderColor: color,
          backgroundColor: 'transparent',
          tension: 0,
          stepped: true,
          spanGaps: true,
          pointRadius: 0,
          borderWidth: 1,
          fill: false,
          hidden: chartState.focused !== null && chartState.focused !== id,
        };
      });
    }

    function hexToRGBA(hex, alpha) {
      if (!hex) return hex;
      const h = hex.replace('#', '');
      const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
      const r = (bigint >> 16) & 255;
      const g = (bigint >> 8) & 255;
      const b = bigint & 255;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function updateChartInputState(availableCount) {
      if (!els.charts.sensors) return;
      const totalAvailable = availableCount !== undefined ? availableCount : Math.max(sensorIndex.byId.size - chartState.selected.length, 0);
      // –ù–µ –±–ª–æ–∫–∏—Ä—É–µ–º –ø–æ–ª–µ, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –≤–≤–æ–¥–∏—Ç—å –¥–∞–∂–µ –ø—Ä–∏ –ø—É—Å—Ç—ã—Ö –ø–æ–¥—Å–∫–∞–∑–∫–∞—Ö.
      els.charts.sensors.disabled = false;
      if (els.charts.sensors.parentElement) {
        els.charts.sensors.parentElement.classList.remove('input-disabled');
      }
      if (totalAvailable <= 0) hideChartSuggestions();
    }

    function syncChartData() {
      const hasRange = chartState.range.from && chartState.range.to;
      if (chartState.chart) {
        chartState.chart.data.labels = extractChartLabels();
        chartState.chart.data.datasets = buildChartDatasets();
        chartState.chart.options.scales.x.min = hasRange ? chartState.range.from : undefined;
        chartState.chart.options.scales.x.max = hasRange ? chartState.range.to : undefined;
        chartState.chart.update('none');
      }
      if (chartState.chartStep) {
        chartState.chartStep.data.labels = extractChartLabels();
        chartState.chartStep.data.datasets = buildStepDatasets();
        chartState.chartStep.options.scales.x.min = hasRange ? chartState.range.from : undefined;
        chartState.chartStep.options.scales.x.max = hasRange ? chartState.range.to : undefined;
        const tracks = Math.max(chartState.selected.filter(isDiscreteSensor).length, 1);
        chartState.chartStep.options.scales.y.min = 0;
        chartState.chartStep.options.scales.y.max = tracks * 2;
        chartState.chartStep.update('none');
      }
      updateChartMeta();
      renderLegendTable();
    }

    function rebuildStepChart(hasRange) {
      if (!els.charts.stepCanvas) return;
      const container = els.charts.stepCanvas.parentElement || els.charts.stepCanvas;
      const rawW = container.clientWidth || container.offsetWidth || 0;
      const rawH = container.clientHeight || container.offsetHeight || 0;
      const width = Math.max(320, Math.floor(rawW || 800));
      const height = Math.max(160, Math.floor(rawH || 200));
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        return;
      }
      destroyStepChart();
      if (!window.Chart) return;
      const ctx = els.charts.stepCanvas.getContext('2d');
      els.charts.stepCanvas.width = width;
      els.charts.stepCanvas.height = height;
      const labels = extractChartLabels();
      const datasets = buildStepDatasets();
      const tracks = Math.max(chartState.selected.filter(isDiscreteSensor).length, 1);
      chartState.chartStep = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets },
        options: {
          animation: false,
          responsive: false,
          maintainAspectRatio: false,
          parsing: false,
          resizeDelay: 0,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'second',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm:ss',
                  hour: 'HH:mm',
                  day: 'yyyy-MM-dd',
                  week: 'yyyy-MM-dd',
                  month: 'yyyy-MM',
                  quarter: 'yyyy-MM',
                  year: 'yyyy',
                },
              },
              min: hasRange ? chartState.range.from : undefined,
              max: hasRange ? chartState.range.to : undefined,
              ticks: { color: '#94a3b8' },
              grid: { color: 'rgba(255,255,255,0.05)' },
            },
            y: {
              ticks: {
                color: '#94a3b8',
                stepSize: 1,
                callback: (val) => {
                  if (!Number.isInteger(val)) return '';
                  return val % 2 === 0 ? '0' : '1';
                },
              },
              min: 0,
              max: tracks * 2,
              grid: {
                color: 'rgba(255,255,255,0.05)',
                borderColor: 'rgba(255,255,255,0.08)',
              },
            },
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: true,
              displayColors: false,
              mode: 'nearest',
              intersect: false,
              position: 'nearest',
              callbacks: {
                title: (items) => {
                  const ts = items?.[0]?.parsed?.x;
                  if (!Number.isFinite(ts)) return '';
                  return new Date(ts).toISOString().replace(/\.\d{3}Z$/, 'Z');
                },
                label: (ctx) => {
                  const v = Number.isFinite(ctx.parsed.y) ? ctx.parsed.y % 2 : 0;
                  const val = v === 1 ? '1' : '0';
                  return `${ctx.dataset?.label || ''}: ${val}`.trim();
                },
              },
            },
          },
        },
      });
    }

    function scheduleChartSync() {
      if (!chartState.chart) {
        rebuildChart();
        return;
      }
      if (chartUpdateTimer) return;
      chartUpdateTimer = setTimeout(() => {
        chartUpdateTimer = null;
        syncChartData();
      }, 150);
    }

    function rebuildChart(force = false) {
      if (!els.charts.canvas) return;
      if (!chartState.selected.length) {
        destroyChart();
        updateChartMeta();
        renderLegendTable();
        return;
      }
      if (chartState.selected.length > chartMaxSeries) {
        log(`–ù–∞ –≥—Ä–∞—Ñ–∏–∫–µ –º–æ–∂–Ω–æ –¥–µ—Ä–∂–∞—Ç—å –Ω–µ –±–æ–ª–µ–µ ${chartMaxSeries} –¥–∞—Ç—á–∏–∫–æ–≤ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ`, false);
        chartState.selected = chartState.selected.slice(0, chartMaxSeries);
      }
      const hasRange = chartState.range.from && chartState.range.to;
      const panelVisible = els.panels?.charts?.classList.contains('active');
      const container = els.charts.canvas.parentElement || els.charts.canvas;
      const rawW = container.clientWidth || container.offsetWidth || 0;
      const rawH = container.clientHeight || container.offsetHeight || 0;
      const width = Math.max(320, Math.floor(rawW || 800));
      const height = Math.max(300, Math.floor(rawH || 420));
      if (!panelVisible && !force) {
        const reason = `hidden:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: panel hidden', { panelVisible, width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
        const reason = `invalid:${width}x${height}`;
        if (chartState.lastSkip !== reason) {
          chartLog('skip rebuild: invalid size', { width, height });
          chartState.lastSkip = reason;
        }
        return;
      }
      destroyChart();
      destroyStepChart();
      chartState.lastSkip = '';
      if (!window.Chart) {
        console.error('[chart] Chart.js not loaded');
        return;
      }
      const ctx = els.charts.canvas.getContext('2d');
      els.charts.canvas.width = width;
      els.charts.canvas.height = height;
      const labels = extractChartLabels();
      const datasets = buildChartDatasets();
      chartState.chart = new Chart(ctx, {
        type: 'line',
        data: {labels, datasets},
        options: {
          animation: false,
          responsive: false,
          maintainAspectRatio: false,
          parsing: false,
          resizeDelay: 0,
          scales: {
            x: {
              type: 'time',
              time: {
                unit: 'second',
                displayFormats: {
                  millisecond: 'HH:mm:ss.SSS',
                  second: 'HH:mm:ss',
                  minute: 'HH:mm:ss',
                  hour: 'HH:mm',
                  day: 'yyyy-MM-dd',
                  week: 'yyyy-MM-dd',
                  month: 'yyyy-MM',
                  quarter: 'yyyy-MM',
                  year: 'yyyy',
                },
              },
              min: hasRange ? chartState.range.from : undefined,
              max: hasRange ? chartState.range.to : undefined,
              ticks: {color: '#94a3b8'},
              grid: {color: 'rgba(255,255,255,0.05)'},
            },
            y: {
              ticks: {color: '#94a3b8'},
              grid: {
                color: (ctx) => {
                  if (ctx.tick && ctx.tick.value === 0) return '#ffffff';
                  return 'rgba(255,255,255,0.05)';
                },
                borderColor: 'rgba(255,255,255,0.08)',
              },
            },
          },
          plugins: {
            legend: {display: false},
            tooltip: {
              mode: 'nearest',
              intersect: false,
              callbacks: {
                title: (items) => items.length ? new Date(items[0].parsed.x).toISOString() : '',
                label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y ?? '‚Äî'}`,
              },
            },
            zoom: {
              zoom: {wheel: {enabled: false}, pinch: {enabled: false}, mode: 'x'},
              pan: {enabled: false},
            },
          },
          interaction: {mode: 'nearest', intersect: false},
        },
      });
      chartLog('rebuild chart', { width, height, datasets: chartState.datasets.size });
      rebuildStepChart(hasRange);
      updateChartMeta();
      renderLegendTable();
    }

    function destroyChart() {
      const existing = (window.Chart && typeof Chart.getChart === 'function') ? Chart.getChart(els.charts.canvas) : null;
      if (existing) existing.destroy();
      if (chartState.chart) {
        chartState.chart.destroy();
        chartState.chart = null;
      }
    }

    function destroyStepChart() {
      const existing = (window.Chart && typeof Chart.getChart === 'function') ? Chart.getChart(els.charts.stepCanvas) : null;
      if (existing) existing.destroy();
      if (chartState.chartStep) {
        chartState.chartStep.destroy();
        chartState.chartStep = null;
      }
    }

    function extractChartLabels() {
      const labels = new Set();
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => labels.add(p.x));
      });
      return Array.from(labels).sort((a, b) => a - b);
    }

    function resetChartZoom() {
    }

    function autoZoomY() {
      if (!chartState.chart) return;
      let minY = Infinity;
      let maxY = -Infinity;
      chartState.datasets.forEach(ds => {
        (ds.data || []).forEach(p => {
          if (p.y == null) return;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        });
      });
      if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
        minY = 0; maxY = 1;
      }
      chartState.chart.options.scales.y.min = minY;
      chartState.chart.options.scales.y.max = maxY;
      chartState.chart.update('none');
      updateChartMeta();
    }

    function trimDataset(ds, currentTs) {
      // –ï—Å–ª–∏ –∏–∑–≤–µ—Å—Ç–µ–Ω –¥–∏–∞–ø–∞–∑–æ–Ω from/to ‚Äî –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å—ë, —á—Ç–æ –∑–∞ –µ–≥–æ –ø—Ä–µ–¥–µ–ª–∞–º–∏.
      if (chartState.range.from && chartState.range.to) {
        ds.data = ds.data.filter(p => p.x >= chartState.range.from && p.x <= chartState.range.to);
        return;
      }
      if (!chartState.windowSec || chartState.windowSec <= 0) return;
      const threshold = currentTs - chartState.windowSec * 1000;
      ds.data = ds.data.filter(p => p.x >= threshold);
    }

    function decimateDataset(ds) {
      const max = chartState.maxPoints;
      if (!ds || !Array.isArray(ds.data)) return;
      const len = ds.data.length;
      if (len <= max) return;
      const stride = Math.ceil(len / max);
      if (stride <= 1) return;
      const decimated = [];
      for (let i = 0; i < len; i += stride) {
        decimated.push(ds.data[i]);
      }
      // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç, –µ—Å–ª–∏ –Ω–µ –ø–æ–ø–∞–ª
      const last = ds.data[len - 1];
      if (decimated[decimated.length - 1]?.x !== last.x) decimated.push(last);
      ds.data = decimated;
    }

    function truncateChartAfter(tsMs) {
      if (!Number.isFinite(tsMs)) return;
      let changed = false;
      chartState.datasets.forEach((ds) => {
        if (!ds || !Array.isArray(ds.data)) return;
        const filtered = ds.data.filter(p => Number.isFinite(p?.x) && p.x <= tsMs);
        if (filtered.length !== ds.data.length) {
          ds.data = filtered;
          const last = filtered[filtered.length - 1];
          ds.lastTs = last?.x || null;
          ds.lastValue = last?.y ?? null;
          changed = true;
        } else if (ds.lastTs && ds.lastTs > tsMs) {
          ds.lastTs = null;
          ds.lastValue = null;
          changed = true;
        }
      });
      if (changed) {
        scheduleChartSync();
        renderLegendTable();
        updateChartMeta();
      }
    }

    function appendChartPoint(tsStr, updates) {
      if (!tsStr) return;
      const canAutoAdd = rangeSensorCountKnown && rangeSensorCount > 0 && rangeSensorCount <= chartAutoAddLimit;
      if (!chartState.selected.length && canAutoAdd && updates?.length) {
        const ids = Array.from(new Set((updates || []).map(u => Number(u.id)).filter(Number.isFinite)));
        if (ids.length) {
          applyChartSensors(ids);
        }
      }
      if (!chartState.selected.length) return;
      if (chartState.selected.length >= chartAutoAddLimit && !updates?.length) return;
      if (!chartState.autoUpdate) return;
      if (els.charts.autoUpdate && !els.charts.autoUpdate.checked) return;
      const d = parseISO(tsStr);
      if (!d) return;
      const t = d.getTime();
      const hasFixedRange = chartState.range.from && chartState.range.to;
      if (hasFixedRange && (t < chartState.range.from || t > chartState.range.to)) {
        // –ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –æ—Ç–±—Ä–∞—Å—ã–≤–∞–µ–º.
        return;
      }
      const updateMap = new Map();
      (updates || []).forEach(item => {
        const id = Number(item.id);
        if (Number.isFinite(id)) updateMap.set(id, item.value);
      });
      const usedColors = new Set();
      chartState.datasets.forEach(ds => {
        if (ds.color) usedColors.add(String(ds.color).toLowerCase());
      });
      chartState.selected.forEach((id, idx) => {
        if (!chartState.datasets.has(id)) {
          const color = pickChartColor(id, usedColors, idx);
          chartState.datasets.set(id, {
            id,
            label: chartLabelByID(id),
            color,
            data: [],
            lastValue: null,
            lastTs: null,
          });
          usedColors.add(String(color).toLowerCase());
        }
        const ds = chartState.datasets.get(id);
        const val = updateMap.has(id) ? updateMap.get(id) : (ds.lastValue ?? 0);
        const numVal = Number.isFinite(Number(val)) ? Number(val) : 0;
        const y = numVal;
        ds.lastValue = y;
        ds.lastTs = t;
        ds.data.push({x: t, y});
        decimateDataset(ds);
        trimDataset(ds, t);
      });
      if (chartState.chart) {
        scheduleChartSync();
      } else {
        rebuildChart();
      }
    }

    function applyChartSensors(list) {
      if ((chartState.selected.length || 0) >= chartAutoAddLimit && !list.length) {
        // –ï—Å–ª–∏ —É–∂–µ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ª–∏–Ω–∏–π, –Ω–µ –∞–≤—Ç–æ-–¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –±–µ–∑ —è–≤–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞.
        return;
      }
      const normalized = normalizeSensorList(list || []);
      if (normalized.length > chartMaxSeries) {
        normalized.length = chartMaxSeries;
      }
      const withValues = normalized.filter(sensorHasValue);
      const picked = withValues.length ? withValues : normalized;
      chartState.selected = picked.slice(0, chartMaxSeries);
      if (chartState.focused !== null && !chartState.selected.includes(chartState.focused)) {
        chartState.focused = null;
      }
      if (els.charts.sensors) {
        els.charts.sensors.value = '';
      }
      rebuildChartSeries();
      hideChartSuggestions();
    }

    function sensorHasValue(id) {
      const row = tableState.rows.get(id);
      if (row && row.hasValue) return true;
      const ds = chartState.datasets.get(id);
      return ds && ds.lastValue !== undefined && ds.lastValue !== null;
    }

    function clearChart() {
      chartState.datasets.forEach((ds) => {
        ds.data = [];
        ds.lastValue = null;
        ds.lastTs = null;
      });
      if (chartState.chart) {
        syncChartData();
      } else {
        rebuildChart();
      }
      if (els.charts.sensors) els.charts.sensors.value = '';
    }

    function addSensorsFromInput() {
      const raw = els.charts.sensors?.value || '';
      const ids = parseChartSensors(raw);
      const filtered = ids.filter(id => !chartState.selected.includes(id));
      if (!filtered.length) {
        log('–î–∞—Ç—á–∏–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –ø–æ–¥—Å–∫–∞–∑–∫–∞—Ö/–∫–æ–Ω—Ñ–∏–≥–µ –∏–ª–∏ —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã', false);
        return;
      }
      const merged = Array.from(new Set([...chartState.selected, ...filtered]));
      applyChartSensors(merged);
      hideChartSuggestions();
    }

    function canAutoAddSensors(list) {
      const cnt = Array.isArray(list) ? list.length : 0;
      if (rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit) return false;
      if (cnt > chartAutoAddLimit) return false;
      return true;
    }

    function hydrateChartDefaultsFromParams() {
      if (chartState.selected.length) return;
      const params = state.model.params || state.model.Params || {};
      const sensors = params.Sensors || params.sensors;
      if (Array.isArray(sensors) && sensors.length && canAutoAddSensors(sensors)) {
        applyChartSensors(sensors);
      }
    }

    function paramsSignature(params) {
      if (!params) return '';
      const sensors = params.Sensors || params.sensors || [];
      const from = params.From || params.from;
      const to = params.To || params.to;
      return JSON.stringify({sensors, from, to});
    }

    function syncChartWithParams(params) {
      const sig = paramsSignature(params);
      const sensors = params?.Sensors || params?.sensors;
      const hasSensors = Array.isArray(sensors) && sensors.length;
      // –ù–µ –∑–∞—Ç–∏—Ä–∞–µ–º —Ä—É—á–Ω–æ–π –≤—ã–±–æ—Ä, –µ—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–µ—Ä–µ–¥–∞–ª Sensors.
      if (!hasSensors && chartState.selected.length) return;
      if (sig && sig !== chartState.lastParamsSig) {
        chartState.lastParamsSig = sig;
        if (hasSensors && canAutoAddSensors(sensors)) {
          applyChartSensors(sensors);
        } else if (!chartState.selected.length) {
          clearChart();
        }
      }
    }

  function requestJSON(method, url, body) {
    logUI(`fetch ${method} ${url} body=${body ? JSON.stringify(body) : ''}`);
    const init = { method, headers: {} };
    if (body !== undefined) {
      init.headers['Content-Type'] = 'application/json';
      init.body = JSON.stringify(body);
    }
    return fetch(url, init).then(async (resp) => {
      const text = await resp.text();
      let payload = null;
      if (text) { try { payload = JSON.parse(text); } catch (_) {} }
    logUI(`fetch result ${resp.status} ${resp.statusText} payload=${text || '<empty>'}`);
      pushDiag(`[fetch] ${method} ${url} -> ${resp.status} ${resp.statusText} ${text || '<empty>'}`);
      if (!resp.ok) {
        throw new Error(payload?.error || text || `HTTP ${resp.status}`);
      }
      return payload;
    });
    }

  function mergeSensorsFromAPI(list) {
    if (!Array.isArray(list)) return;
    list.forEach((item) => {
      const id = Number(item.id);
      if (!Number.isFinite(id)) return;
      registerSensorMeta(id, item.name, item.textname, item.iotype);
    });
    seedTableFromMeta();
    refreshChartSuggestions();
  }

  function seedTableFromMeta() {
    sensorIndex.byId.forEach((meta, id) => {
      if (!tableState.rows.has(id)) {
        tableState.rows.set(id, {
          id,
          name: meta.name || `${id}`,
          textname: meta.textname || '',
          value: undefined,
          hasValue: false,
          stepID: tableState.lastStep || 0,
          ts: tableState.lastTs || '',
        });
      }
    });
    scheduleRenderTable(true);
  }

    async function fetchSnapshotFallback() {
      try {
        const tsDate = currentTsFromServer();
        const ts = tsDate ? toRFC3339(tsDate) : '';
        if (!ts) return;
        const data = await requestJSON('POST', '/api/v2/snapshot', { ts });
        const updates = data?.updates || data?.Updates || [];
        const stepTs = data?.step_ts || data?.StepTS || '';
        applySnapshot(updates, stepTs);
        scheduleRenderTable(true);
      } catch (err) {
        log(`Snapshot fallback: ${err.message}`, false);
      }
    }

  async function preloadSensors() {
      if (sensorIndex.hydrated) {
        pushDiag('[sensors] skip preload: hydrated');
        return;
      }
      try {
        pushDiag('[sensors] preload start');
        const data = await requestJSON('GET', '/api/v2/sensors');
        const list = data?.sensors || [];
        mergeSensorsFromAPI(list);
        sensorIndex.hydrated = list.length > 0;
        pushDiag(`[sensors] loaded count=${list.length}`);
        renderChartSuggestions(els.charts.sensors?.value || '');
        if (chartState.selected.length) {
          rebuildChart(true);
        }
      } catch (err) {
        logUI(`[chart] preload sensors failed: ${err.message}`);
        pushDiag(`[sensors] preload failed: ${err.message}`);
      }
    }

    function statusNormalize(s) {
      return String(s || 'idle').toLowerCase();
    }

    function parseISO(v) {
      const d = new Date(v);
      return Number.isNaN(d.getTime()) ? null : d;
    }

    function getRange(params) {
      const from = parseISO(params.From || params.from);
      const to = parseISO(params.To || params.to);
      return { from, to, valid: !!from && !!to && to > from };
    }

    function getEffectiveRange(params, pending) {
      const r1 = getRange(params || {});
      if (r1.valid) return r1;
      const pendingRange = pending?.range || pending?.Range || {};
      const r2 = getRange(pendingRange);
      if (pending?.range_set || pending?.RangeSet) {
        return r2;
      }
      return r2.valid ? r2 : { from: null, to: null, valid: false };
    }

    function extractSaveOutput(params, pending) {
      const pendingRange = pending?.range || pending?.Range;
      if ((pending?.range_set || pending?.RangeSet) && pendingRange) {
        const v = pendingRange.SaveOutput ?? pendingRange.save_output;
        if (v !== undefined) return { value: !!v, known: true };
      }
      if (params) {
        const v = params.SaveOutput ?? params.save_output;
        if (v !== undefined) return { value: !!v, known: true };
      }
      return { value: false, known: false };
    }

    function syncSaveToggle(status) {
      if (!els.inputs.saveToSM) return;
      const allowed = !!(state.model.save_allowed ?? state.model.SaveAllowed ?? state.saveAllowed);
      state.saveAllowed = allowed;
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const saveInfo = extractSaveOutput(params, pending);
      const st = status || state.model.status || '';
      const runningLike = st === 'running' || st === 'stopping';
      if (allowed && !runningLike) {
        if (!state.saveDirty && saveInfo.known) {
          els.inputs.saveToSM.checked = !!saveInfo.value;
        }
      } else if (!allowed) {
        els.inputs.saveToSM.checked = false;
      } else if (runningLike && saveInfo.known && !state.saveDirty) {
        els.inputs.saveToSM.checked = !!saveInfo.value;
      }
      setDisabled(els.inputs.saveToSM, !allowed || runningLike);
    }

    function syncChartRange(params, pending) {
      const range = getEffectiveRange(params, pending);
      if (!range.valid) {
        chartState.range = { from: null, to: null };
        return;
      }
      const fromMs = range.from.getTime();
      const toMs = range.to.getTime();
      const prevFrom = chartState.range.from;
      const prevTo = chartState.range.to;
      chartState.range = { from: fromMs, to: toMs };
      if (prevFrom !== fromMs || prevTo !== toMs) {
        // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –¥–∞—Ç–∞—Å–µ—Ç—ã –∏ —É–¥–∞–ª—è–µ–º —Ç–æ—á–∫–∏ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –Ω–æ–≤–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞.
        chartState.datasets.forEach(ds => {
          ds.data = ds.data.filter(p => p.x >= fromMs && p.x <= toMs);
        });
        if (chartState.chart) {
          syncChartData();
        } else {
          rebuildChart(true);
        }
      }
    }

    function currentTsFromServer() {
      const st = statusNormalize(state.model.status);
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const params = state.model.params || state.model.Params || {};
      const range = getEffectiveRange(params, pending);
      const lastTs = parseISO(state.model.last_ts || state.model.LastTS);
      const pendingTs = pendingSeek ? parseISO(pendingSeek) : null;
      // –í–æ –≤—Å–µ—Ö –Ω–µ—Äunning —Å–æ—Å—Ç–æ—è–Ω–∏—è—Ö –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç —É pending seek (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ø–æ—Å–ª–µ stop/done).
      if (st !== 'running' && st !== 'stopping' && pendingTs && !Number.isNaN(pendingTs.getTime()) && pendingTs.getFullYear() > 1) {
        return pendingTs;
      }
      // –í –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è—Ö –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π ts –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞, –µ—Å–ª–∏ –≤–∞–ª–∏–¥–µ–Ω.
      if (lastTs && !Number.isNaN(lastTs.getTime()) && lastTs.getFullYear() > 1) {
        return lastTs;
      }
      if ((st === 'idle' || st === 'pending') && pendingTs) {
        return pendingTs;
      }
      if ((st === 'idle' || st === 'pending') && range.valid) {
        return range.from;
      }
      if (pendingTs) {
        return pendingTs;
      }
      if (range.valid) {
        return range.from;
      }
      return null;
    }

    function updateStatusView() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const pendingSeek = pending.seek_ts || pending.SeekTS;
      const curTs = currentTsFromServer();
      const stepID = state.model.step_id ?? state.model.StepID ?? '-';
      const lastTsText = curTs ? toRFC3339(curTs) : (state.model.last_ts ?? state.model.LastTS ?? '-');
      const updates = state.model.updates_sent ?? state.model.UpdatesSent ?? '-';
      if (els.status.badge) {
        els.status.badge.textContent = st;
        els.status.badge.classList.toggle('badge-done', st === 'done');
      }
      els.chipStatus.textContent = st;
      els.status.step.textContent = stepID;
      els.status.ts.textContent = lastTsText;
      els.status.updates.textContent = updates;
      els.status.error.textContent = state.model.error ? `–û—à–∏–±–∫–∞: ${state.model.error}` : '';
      els.chipStatus.className = 'status-value';
      if (st === 'running') els.chipStatus.classList.add('status-ok');
      if (st === 'paused' || st === 'pending') els.chipStatus.classList.add('status-warn');
      if (st === 'failed') els.chipStatus.classList.add('status-err');
      if (pendingSeek && (st === 'pending' || st === 'idle')) {
        els.status.ts.textContent = pendingSeek;
      }
      syncSaveToggle(st);
      syncChartRange(params, pending);
      updateTimeline();
      updateControls();
      logIndicators(st);
      toggleChartAutoUpdate(st);
      updateChartMeta();
    }

    function toggleChartAutoUpdate(status) {
      if (!els.charts.autoUpdate) return;
      const shouldRun = status === 'running' || status === 'stopping';
      chartState.autoUpdate = shouldRun;
      els.charts.autoUpdate.checked = shouldRun;
    }

    function logIndicators(status) {
      const step = state.model.step_id || state.model.StepID || '-';
      const ts = state.model.last_ts || state.model.LastTS || '-';
      const updates = state.model.updates_sent || state.model.UpdatesSent || '-';
      const pending = state.model.pending || state.model.Pending || {};
      logUI(`indicators status=${status} step=${step} ts=${ts} updates=${updates} pendingRange=${pending.range_set || pending.RangeSet ? 'yes' : 'no'}`);
    }

    function updateTimeline() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const slider = els.timeline;
      if (!range.valid) {
        slider.disabled = true;
        slider.value = 0;
        els.fromLabel.textContent = 'from: -';
        els.toLabel.textContent = 'to: -';
        els.currentLabel.textContent = '-';
        return;
      }
      els.fromLabel.textContent = `from: ${range.from.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      els.toLabel.textContent = `to: ${range.to.toISOString().replace(/\.\d{3}Z$/, 'Z')}`;
      slider.disabled = false;
      const rangeMs = range.to - range.from;
      let pos = 0;
      const st = statusNormalize(state.model.status);
      let curTs = currentTsFromServer();
      if (state.previewTs && st !== 'running' && st !== 'stopping') {
        curTs = state.previewTs;
      }
      if (curTs) {
        pos = Math.max(0, Math.min(1, (curTs - range.from) / rangeMs));
        els.currentLabel.textContent = toRFC3339(curTs);
        logUI(`timeline render ${toRFC3339(curTs)} source=${state.previewTs ? 'preview' : 'server'}`);
      } else {
        els.currentLabel.textContent = pending.seek_ts || pending.SeekTS || toRFC3339(range.from) || '-';
      }
      slider.value = Math.round(pos * 1000);
    }

    function updateControls() {
      const st = statusNormalize(state.model.status);
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const pendingRange = !!(pending?.range_set || pending?.RangeSet);
      const active = st === 'running' || st === 'paused' || st === 'stopping';
      const paused = st === 'paused';
      const curTs = currentTsFromServer();
      const atStart = !range.valid || !curTs || curTs.getTime() <= range.from.getTime();
      const atEnd = !range.valid || !curTs || curTs.getTime() >= range.to.getTime();
      const canStep = range.valid && st !== 'failed' && st !== 'running' && st !== 'stopping';
      const runningLike = st === 'running' || st === 'stopping';

      setDisabled(els.controls.stepBack, !canStep || atStart);
      setDisabled(els.controls.stepFwd, !canStep || atEnd);
      setDisabled(els.controls.stop, !active);
      const hasRange = range.valid && (active || pendingRange || state.rangePicked); // –¥–∏–∞–ø–∞–∑–æ–Ω —Å—á–∏—Ç–∞–µ–º –∑–∞–¥–∞–Ω–Ω—ã–º –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–µ–Ω, –µ—Å—Ç—å pending –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª –µ–≥–æ –≤ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏
      setDisabled(els.controls.playPause, st === 'failed' || !hasRange);
      const playLike = paused || st === 'idle' || st === 'done' || st === 'pending';
      els.controls.playPause.textContent = playLike ? '‚ñ∂Ô∏è Play' : '‚è∏ Pause';
      els.controls.playPause.classList.remove('primary');
      // –ü–æ–ª–∑—É–Ω–æ–∫ –¥–æ—Å—Ç—É–ø–µ–Ω –ø—Ä–∏ –≤–∞–ª–∏–¥–Ω–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ (–¥–∞–∂–µ –¥–æ —Å—Ç–∞—Ä—Ç–∞), —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –≤—ã–±—Ä–∞—Ç—å —Ç–æ—á–∫—É.
      setDisabled(els.timeline, !range.valid);
      if (els.rangeBtn) {
        setDisabled(els.rangeBtn, active); // –Ω–µ —Ç—Ä–æ–≥–∞–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –≤–æ –≤—Ä–µ–º—è –∞–∫—Ç–∏–≤–Ω–æ–π –∑–∞–¥–∞—á–∏
      }
      if (els.controls.jumpStart) {
        setDisabled(els.controls.jumpStart, !range.valid || st === 'running' || st === 'stopping');
      }
      if (els.controls.jumpEnd) {
        setDisabled(els.controls.jumpEnd, !range.valid || st === 'running' || st === 'stopping');
      }
      if (els.inputs.saveToSM) {
        const allowed = !!(state.model.save_allowed ?? state.model.SaveAllowed ?? state.saveAllowed);
        setDisabled(els.inputs.saveToSM, runningLike || !allowed);
      }
    }

    function setDisabled(el, disabled) {
      if (!el) return;
      el.disabled = !!disabled;
      el.setAttribute('aria-disabled', disabled ? 'true' : 'false');
      if (disabled) el.classList.add('is-disabled');
      else el.classList.remove('is-disabled');
    }

    function updateRangeLabel() {
      if (!els.rangePicker) return;
      const from = els.inputs.from.value.trim();
      const to = els.inputs.to.value.trim();
      const valid = isValidISO(from) && isValidISO(to);
      const label = valid ? `${from} ‚Üí ${to}` : '–Ω–µ –∑–∞–¥–∞–Ω';
      if (els.rangeLabelValue) {
        els.rangeLabelValue.textContent = label;
        els.rangeLabelValue.style.color = valid ? '#e5e7eb' : '#fbbf24';
      } else {
        els.rangePicker.textContent = `–î–∏–∞–ø–∞–∑–æ–Ω: ${label}`;
      }
    }

    function validateStartForm() {
      const errors = [];
      const from = els.inputs.from.value.trim();
      const to = els.inputs.to.value.trim();
      const step = els.inputs.step.value.trim();
      const speedVal = els.inputs.speed.value.trim();
      const windowVal = els.inputs.window.value.trim();
      if (!isValidISO(from)) errors.push('From: RFC3339, –Ω–∞–ø—Ä–∏–º–µ—Ä 2024-06-01T00:00:00Z.');
      if (!isValidISO(to)) errors.push('To: RFC3339.');
      if (isValidISO(from) && isValidISO(to) && new Date(to) <= new Date(from)) errors.push('To –ø–æ–∑–∂–µ From.');
      if (!isValidDuration(step)) errors.push('Step: 1s/200ms/1m.');
      let speed = parseFloat(speedVal || '1');
      if (!Number.isFinite(speed) || speed <= 0) errors.push('Speed: –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.');
      if (windowVal && !isValidDuration(windowVal)) errors.push('Window: 5s/1m.');
      els.startErrors.textContent = errors.join(' ');
      if (errors.length) return null;
      const payload = { from, to, step, speed };
      if (windowVal) payload.window = windowVal;
      const saveOutput = state.saveAllowed && els.inputs.saveToSM && els.inputs.saveToSM.checked;
      payload.save_output = !!saveOutput;
      return payload;
    }

    function isValidISO(v) {
      const d = new Date(v);
      return v && !Number.isNaN(d.getTime());
    }

    function isValidDuration(v) {
      return /^\d+(ms|s|m|h)$/.test(v);
    }

  async function refresh(full = false) {
    if (!sensorIndex.hydrated) {
      await preloadSensors();
    }
    const url = '/api/v2/job';
      logUI(`refresh ${full ? 'full' : 'state'} start last_ts=${state.model.last_ts || state.model.LastTS}`);
      const data = await requestJSON('GET', url);
      const status = statusNormalize(data?.status || data?.Status || state.model.status);
      pushDiag(`[refresh] ${full ? 'full' : 'state'} status=${status} step=${data?.step_id ?? data?.StepID ?? '-'} ts=${data?.last_ts ?? data?.LastTS ?? '-'}`);
      const pending = data?.pending || data?.Pending || {};
      state.model = { ...data, status, pending };
      // –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö params, –Ω–æ –µ—Å—Ç—å pending range ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
    const pendingRange = pending.range_set ? pending.range : pending.Range;
    if (!state.model.params && !state.model.Params && pendingRange) {
      state.model.params = pendingRange;
      state.model.Params = pendingRange;
    }
    // –ï—Å–ª–∏ –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü–∞ –ø—É—Å—Ç–∞, –∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —É–∂–µ –µ—Å—Ç—å, –ø–æ–¥—Å–µ—Ç–∏–º —Å—Ç—Ä–æ–∫–∏.
    if (!tableState.rows.size && sensorIndex.byId.size) {
      seedTableFromMeta();
    } else if (!sensorIndex.hydrated) {
      preloadSensors().catch(() => {});
    }
    state.saveAllowed = !!(data?.save_allowed ?? data?.SaveAllowed ?? state.saveAllowed);
    syncSaveToggle();
    hydrateChartDefaultsFromParams();
    syncChartWithParams(state.model.params || state.model.Params);
    syncChartRange(state.model.params || state.model.Params, pending);
      // –ï—Å–ª–∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ —É–∂–µ –µ—Å—Ç—å pending –¥–∏–∞–ø–∞–∑–æ–Ω, —Å—á–∏—Ç–∞–µ–º –µ–≥–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º (–≤–∞–∂–Ω–æ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏ —Ç–µ—Å—Ç–æ–≤).
      if (pendingRange && !state.rangePicked) {
        state.rangePicked = true;
      }
      logUI(`refresh result status=${status} last_ts=${state.model.last_ts || state.model.LastTS} pendingRange=${pendingRange ? 'yes' : 'no'}`);
      updateStatusView();
  }

  async function startJob() {
      if (!sensorIndex.hydrated) {
        await preloadSensors().catch(() => {});
      }
    const payload = validateStartForm();
    if (!payload) return;
    if (rangeSensorCountKnown && rangeSensorCount > chartAutoAddLimit) {
      log(`–í –¥–∏–∞–ø–∞–∑–æ–Ω–µ ${rangeSensorCount} –¥–∞—Ç—á–∏–∫–æ–≤, –∞–≤—Ç–æ–¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –≥—Ä–∞—Ñ–∏–∫–∏ –æ—Ç–∫–ª—é—á–µ–Ω–æ (–ª–∏–º–∏—Ç ${chartAutoAddLimit})`, true);
    }
      logUI(`set range v2 ${JSON.stringify(payload)}`);
      await requestJSON('POST', '/api/v2/job/range', payload);
      state.rangePicked = true;
      await fetchSensorCount(payload.from, payload.to);
      logUI('startJob (v2) using pending');
      try {
        pushDiag('[action] start');
        await requestJSON('POST', '/api/v2/job/start', { save_output: payload.save_output });
        log('–°—Ç–∞—Ä—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω');
        await refresh(true);
      } catch (err) {
        log(`–°—Ç–∞—Ä—Ç: ${err.message}`, false);
      }
    }

    function bindActions() {
      els.tabs.forEach(btn => {
        btn.addEventListener('click', () => setTab(btn.dataset.tab));
      });
      if (els.inputs.saveToSM) {
        els.inputs.saveToSM.addEventListener('change', () => {
          state.saveDirty = true;
        });
      }
      if (els.table.filter) {
        els.table.filter.addEventListener('input', (e) => {
          const v = e.target.value.toLowerCase();
          if (tableFilterTimer) clearTimeout(tableFilterTimer);
          tableFilterTimer = setTimeout(() => {
            tableState.filter = v;
            scheduleRenderTable(true);
          }, 150);
        });
        els.table.filter.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            clearTableFilter();
          }
        });
        els.table.filter.addEventListener('keyup', (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            clearTableFilter();
          }
        });
      }
      if (els.table.selectAll) {
        els.table.selectAll.addEventListener('change', () => {
          const rows = getFilteredTableRows(false);
          if (els.table.selectAll.checked) {
            rows.forEach(r => tableState.selected.add(r.id));
          } else {
            tableState.selected.clear();
          }
          renderTable(true);
        });
      }
      if (els.table.precision) {
        els.table.precision.addEventListener('change', () => {
          const v = Number(els.table.precision.value);
          tableValuePrecision = Number.isFinite(v) ? v : 3;
          tableState.precision = tableValuePrecision;
          renderTable(true);
        });
      }
      if (els.table.body) {
        els.table.body.addEventListener('change', (e) => {
          const target = e.target;
          if (!target || !target.matches('input.table-select')) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (target.checked) {
            tableState.selected.add(id);
          } else {
            tableState.selected.delete(id);
          }
          renderTable(false);
        });
        els.table.body.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-chart-add]');
          if (!btn) return;
          const id = Number(btn.dataset.chartAdd);
          if (!Number.isFinite(id)) return;
          (async () => {
            if (!sensorIndex.hydrated) {
              try { await preloadSensors(); } catch (_) { /* ignore */ }
            }
            const next = Array.from(new Set([...chartState.selected, id]));
            applyChartSensors(next);
          })();
        });
      }
      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        const panelTable = document.getElementById('panel-table');
        if (!panelTable || !panelTable.classList.contains('active')) return;
        clearTableFilter();
      });
      if (els.rangePicker) {
        els.rangePicker.addEventListener('click', () => openRangeDialog());
      }
      document.querySelectorAll('[data-picker]').forEach(btn => {
        btn.addEventListener('click', () => openPicker(btn.dataset.picker));
      });
      els.dialog.addEventListener('close', () => {
        if (els.dialog.returnValue !== 'ok') return;
        const target = els.dialog.dataset.target;
        const val = els.dialogInput.value;
        if (!target || !val) return;
        const iso = localInputToISO(val);
        const input = document.getElementById(target);
        if (input && iso) input.value = iso;
      });
      if (els.rangeDialog) {
        els.rangeDialog.addEventListener('close', () => {
          if (els.rangeDialog.returnValue !== 'ok') return;
          const from = localInputToISO(els.rangeFrom?.value || '');
          const to = localInputToISO(els.rangeTo?.value || '');
          if (from) els.inputs.from.value = from;
          if (to) els.inputs.to.value = to;
          state.previewTs = null;
          updateRangeLabel();
          (async () => {
            const payload = validateStartForm();
            if (!payload) return;
            try {
              await requestJSON('POST', '/api/v2/job/range', payload);
              state.rangePicked = true;
              await fetchSensorCount(payload.from, payload.to);
              await refresh(true);
            } catch (err) {
              log(`–î–∏–∞–ø–∞–∑–æ–Ω: ${err.message}`, false);
            }
          })();
        });
        els.rangeDialog.querySelectorAll('[data-quick-min]').forEach(btn => {
          btn.addEventListener('click', () => applyQuickRange(parseInt(btn.dataset.quickMin, 10)));
        });
      }
      if (els.charts.colorDialog) {
        els.charts.colorDialog.addEventListener('close', () => {
          const id = Number(els.charts.colorDialog.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (els.charts.colorDialog.returnValue !== 'ok') return;
          const color = normalizeHexColor(els.charts.colorInput?.value || '');
          const ds = chartState.datasets.get(id);
          if (!ds) return;
          ds.color = color;
          rebuildChartSeries();
          renderLegendTable();
        });
      }
      els.timeline.addEventListener('change', onTimelineSeek);
      els.timeline.addEventListener('input', onTimelinePreview);
      els.timeline.addEventListener('pointerdown', () => {
        const params = state.model.params || state.model.Params || {};
        const pending = state.model.pending || state.model.Pending || {};
        const range = getEffectiveRange(params, pending);
        if (!range.valid) return;
        const v = Number(els.timeline.value) / 1000;
        const ts = toRFC3339(new Date(range.from.getTime() + (range.to - range.from) * v));
        if (ts) logUI(`timeline drag start ${ts}`);
      });
      els.controls.stepBack.addEventListener('click', () => action('step –Ω–∞–∑–∞–¥', '/api/v2/job/step/backward', { apply: true }));
      els.controls.stepFwd.addEventListener('click', () => action('step –≤–ø–µ—Ä—ë–¥', '/api/v2/job/step/forward'));
      els.controls.stop.addEventListener('click', () => {
        logUI('Stop button: clicked');
        action('stop', '/api/v2/job/stop');
      });
      els.controls.playPause.addEventListener('click', onPlayPause);
      els.clearLog.addEventListener('click', () => { els.log.innerHTML = ''; });
      if (els.diagEnable) {
        els.diagEnable.addEventListener('change', () => {
          state.diagEnabled = !!els.diagEnable.checked;
          if (!state.diagEnabled) {
            diagBuffer.length = 0;
          } else if (!sensorIndex.hydrated) {
            preloadSensors().catch(() => {});
          }
          logUI(`–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ ${state.diagEnabled ? '–≤–∫–ª—é—á–µ–Ω–∞' : '–≤—ã–∫–ª—é—á–µ–Ω–∞'}`);
          updateDiagButtons();
        });
      }
      if (els.diagDownload) {
        els.diagDownload.addEventListener('click', () => downloadDiag());
      }
      if (els.diagClear) {
        els.diagClear.addEventListener('click', () => clearDiag());
      }
      if (els.rangeBtn) {
        els.rangeBtn.addEventListener('click', () => applyAvailableRange(true));
      }
      if (els.controls.jumpStart) {
        els.controls.jumpStart.addEventListener('click', () => jumpToEdge('start'));
      }
      if (els.controls.jumpEnd) {
        els.controls.jumpEnd.addEventListener('click', () => jumpToEdge('end'));
      }
      if (els.charts.apply) {
        els.charts.apply.addEventListener('click', () => {
          addSensorsFromInput();
        });
      }
      if (els.charts.clear) {
        els.charts.clear.addEventListener('click', () => clearChart());
      }
      if (els.charts.autoUpdate) {
        els.charts.autoUpdate.addEventListener('change', () => {
          chartState.autoUpdate = !!els.charts.autoUpdate.checked;
          updateChartMeta();
        });
      }
      if (els.charts.legendBody) {
        els.charts.legendBody.addEventListener('click', (e) => {
          const target = e.target;
          if (target && target.matches('button.chart-color-btn')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            openColorDialog(id);
            return;
          }
          if (target && target.matches('button.chart-remove-btn')) {
            const id = Number(target.dataset.sensor);
            if (!Number.isFinite(id)) return;
            const filtered = chartState.selected.filter(x => x !== id);
            applyChartSensors(filtered);
            return;
          }
          if (target && target.closest('input.chart-color-input')) {
            return;
          }
          const row = target.closest('tr[data-sensor]');
          if (!row) return;
          const id = Number(row.dataset.sensor);
          if (!Number.isFinite(id)) return;
          chartState.focused = chartState.focused === id ? null : id;
          if (chartState.chart) {
            syncChartData();
          }
          renderLegendTable();
        });
      }
      if (els.charts.suggestBox) {
        els.charts.suggestBox.addEventListener('mousedown', (e) => {
          const target = e.target.closest('.chart-suggest-item');
          if (!target) return;
          const id = Number(target.dataset.sensor);
          if (!Number.isFinite(id)) return;
          if (chartState.selected.length >= chartMaxSeries) {
            return;
          }
          applyChartSensors([...chartState.selected, id]);
          hideChartSuggestions();
        });
      }
      if (els.charts.window) {
        els.charts.window.addEventListener('change', () => {
          const v = Number(els.charts.window.value);
          if (!Number.isFinite(v) || v < 0) return;
          chartState.windowSec = v;
          const now = Date.now();
          chartState.datasets.forEach(ds => trimDataset(ds, now));
          syncChartData();
        });
      }
      if (els.charts.sensors) {
        els.charts.sensors.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const active = chartState.suggest.items[chartState.suggest.active];
            if (active) {
              applyChartSensors([...chartState.selected, active.id]);
              hideChartSuggestions();
            } else {
              addSensorsFromInput();
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            e.target.blur();
            hideChartSuggestions();
          } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            moveSuggestActive(e.key === 'ArrowDown' ? 1 : -1);
          } else {
            setTimeout(() => renderChartSuggestions(e.target.value), 0);
          }
        });
        els.charts.sensors.addEventListener('input', (e) => {
          chartState.suggest.locked = false;
          renderChartSuggestions(e.target.value);
        });
        els.charts.sensors.addEventListener('change', () => {
          chartState.suggest.locked = false;
          addSensorsFromInput();
        });
        els.charts.sensors.addEventListener('focus', (e) => {
          chartState.suggest.locked = false;
          renderChartSuggestions(e.target.value);
        });
        els.charts.sensors.addEventListener('blur', () => setTimeout(hideChartSuggestions, 120));
      }
      if (els.charts.fill) {
        els.charts.fill.addEventListener('change', () => syncChartData());
      }
      if (els.charts.smooth) {
        els.charts.smooth.addEventListener('change', () => {
          chartState.smooth = !!els.charts.smooth.checked;
          syncChartData();
        });
      }
      if (els.charts.precision) {
        els.charts.precision.addEventListener('change', () => {
          const v = Number(els.charts.precision.value);
          chartValuePrecision = Number.isFinite(v) ? v : 3;
          renderLegendTable();
          syncChartData();
        });
      }
    }

    async function onPlayPause() {
      const st = statusNormalize(state.model.status);
      if (st === 'running') {
        logUI('Play button: pausing');
        await action('pause', '/api/v2/job/pause');
        state.previewTs = null;
        return;
      }
      if (st === 'paused') {
        logUI('Play button: resuming with seek');
        const targetDate = currentTsFromServer();
        const target = targetDate ? toRFC3339(targetDate) : (state.model.last_ts || inputs.from.value.trim());
        if (target) {
          await action('seek', '/api/v2/job/seek', { ts: target, apply: false });
        }
        state.previewTs = null;
        const saveOutput = state.saveAllowed && els.inputs.saveToSM && els.inputs.saveToSM.checked;
        state.saveDirty = false;
        await action('resume', '/api/v2/job/resume', { save_output: saveOutput });
        return;
      }
      logUI('Play button: starting job');
      state.previewTs = null;
      await startJob();
    }

    function onTimelinePreview() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const dt = new Date(from.getTime() + (to - from) * v);
      const iso = toRFC3339(dt);
      if (!iso) return;
      state.previewTs = dt;
      els.currentLabel.textContent = iso;
    }

    async function onTimelineSeek() {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const rangeData = getEffectiveRange(params, pending);
      const from = rangeData.from;
      const to = rangeData.to;
      if (!from || !to || to <= from) return;
      const v = Number(els.timeline.value) / 1000;
      const ts = toRFC3339(new Date(from.getTime() + (to - from) * v));
      state.previewTs = parseISO(ts);
      logUI(`timeline seek ${ts}`);
      await seekOrPreview(ts);
    }

    async function action(label, url, body, refreshFull = true) {
      logUI(`action ${label} ${url} ${body ? JSON.stringify(body) : ''}`);
      try {
        await requestJSON('POST', url, body);
        log(`${label}: ok`);
        await refresh(refreshFull);
      } catch (err) {
        log(`${label}: ${err.message}`, false);
      }
    }

    function openPicker(targetId) {
      const input = document.getElementById(targetId);
      const current = input ? input.value.trim() : '';
      els.dialog.dataset.target = targetId;
      els.dialogInput.value = isoToLocalInput(current) || '';
      els.dialog.showModal();
    }

    function openRangeDialog() {
      if (!els.rangeDialog || !els.rangeFrom || !els.rangeTo) return;
      els.rangeFrom.value = isoToLocalInput(els.inputs.from.value.trim()) || '';
      els.rangeTo.value = isoToLocalInput(els.inputs.to.value.trim()) || '';
      els.rangeDialog.showModal();
    }

    function applyQuickRange(mins) {
      if (!Number.isFinite(mins) || mins <= 0) return;
      const now = new Date();
      const from = new Date(now.getTime() - mins * 60 * 1000);
      if (els.rangeFrom) els.rangeFrom.value = isoToLocalInput(toRFC3339(from));
      if (els.rangeTo) els.rangeTo.value = isoToLocalInput(toRFC3339(now));
    }

    function isoToLocalInput(iso) {
      const d = parseISO(iso);
      if (!d) return '';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function localInputToISO(val) {
      if (!val) return '';
      const d = new Date(val);
      if (Number.isNaN(d.getTime())) return '';
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function applyPresetMinutes(mins) {
      if (!Number.isFinite(mins) || mins <= 0) return;
      const now = new Date();
      const from = new Date(now.getTime() - mins * 60 * 1000);
      els.inputs.from.value = toRFC3339(from);
      els.inputs.to.value = toRFC3339(now);
      state.previewTs = null;
      updateRangeLabel();
    }

    async function jumpToEdge(where) {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      const st = statusNormalize(state.model.status);
      logUI(`jump button ${where} click status=${st} rangeValid=${range.valid}`);
      if (!range.valid) {
        log('–ù–µ—Ç –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è', false);
        return;
      }
      let target = where === 'end' ? range.to : range.from;
      await seekOrPreview(target.toISOString().replace(/\.\d{3}Z$/, 'Z'));
    }

    async function seekOrPreview(ts) {
      const params = state.model.params || state.model.Params || {};
      const pending = state.model.pending || state.model.Pending || {};
      const range = getEffectiveRange(params, pending);
      if (!range.valid) return;
      const target = new Date(ts);
      if (Number.isFinite(target.getTime())) {
        truncateChartAfter(target.getTime());
      }
      logUI(`seekOrPreview request ts=${ts}`);
      await action('seek', '/api/v2/job/seek', { ts, apply: false });
    }

    function toRFC3339(d) {
      return d.toISOString().replace(/\.\d{3}Z$/, 'Z');
    }

    function setupVerticalResize({ handle, target, storageKey, min = 240, max = 900, onChange }) {
      if (!handle || !target) return;
      const applyHeight = (h) => {
        const height = clamp(h, min, max);
        target.style.height = `${height}px`;
        if (onChange) onChange(height);
        return height;
      };
      const stored = Number(localStorage.getItem(storageKey));
      if (Number.isFinite(stored)) {
        applyHeight(stored);
      } else {
        const current = target.getBoundingClientRect().height || min;
        applyHeight(current);
      }
      handle.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const startY = e.clientY;
        const startH = target.getBoundingClientRect().height;
        let latest = startH;
        const onMove = (ev) => {
          ev.preventDefault();
          latest = applyHeight(startH + (ev.clientY - startY));
        };
        const onUp = () => {
          localStorage.setItem(storageKey, String(latest));
          document.removeEventListener('pointermove', onMove);
          document.removeEventListener('pointerup', onUp);
        };
        document.addEventListener('pointermove', onMove);
        document.addEventListener('pointerup', onUp);
      });
    }

    function initResizablePanels() {
      setupVerticalResize({
        handle: els.charts.resizeHandle,
        target: els.charts.box,
        storageKey: 'chartHeightPx',
        min: 320,
        max: 900,
        onChange: () => {
          if (chartState.chart) {
            chartState.chart.resize();
            scheduleChartSync();
          }
        },
      });
      setupVerticalResize({
        handle: els.charts.resizeHandleStep,
        target: els.charts.boxStep,
        storageKey: 'chartStepHeightPx',
        min: 140,
        max: 500,
        onChange: () => {
          rebuildStepChart(chartState.range.from && chartState.range.to);
        },
      });
      setupVerticalResize({
        handle: els.charts.legendHandle,
        target: els.charts.legendWrap,
        storageKey: 'chartLegendHeightPx',
        min: 140,
        max: 500,
      });
    }

    async function fetchSensorCount(from, to) {
      if (!isValidISO(from) || !isValidISO(to)) {
        rangeSensorCount = Infinity;
        rangeSensorCountKnown = false;
        log('–î–∏–∞–ø–∞–∑–æ–Ω: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞—Ç—á–∏–∫–æ–≤ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ', false);
        return;
      }
      const qs = new URLSearchParams({ from, to }).toString();
      try {
        const data = await requestJSON('GET', `/api/v2/job/sensors/count?${qs}`);
        const cnt = Number(data?.sensor_count ?? data?.count);
        if (Number.isFinite(cnt)) {
          rangeSensorCount = cnt;
          rangeSensorCountKnown = true;
          log(`–î–∏–∞–ø–∞–∑–æ–Ω: –Ω–∞–π–¥–µ–Ω–æ ${rangeSensorCount} –¥–∞—Ç—á–∏–∫–æ–≤`, rangeSensorCount === 0 ? 'warn' : 'ok');
        } else {
          rangeSensorCount = Infinity;
          rangeSensorCountKnown = false;
          log('–î–∏–∞–ø–∞–∑–æ–Ω: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞—Ç—á–∏–∫–æ–≤ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ', false);
        }
      } catch (err) {
        rangeSensorCount = Infinity;
        rangeSensorCountKnown = false;
        log(`–î–∏–∞–ø–∞–∑–æ–Ω: ${err.message}`, false);
      }
      updateChartMeta();
    }

    async function startPolling() {
      try { await refresh(true); } catch (err) { log(`Init: ${err.message}`, false); }
      setInterval(async () => {
        try {
          await refresh(false);
          state.pollErrorNotified = false;
        } catch (err) {
          if (!state.pollErrorNotified) {
            log(`Poll: ${err.message}`, false);
            state.pollErrorNotified = true;
          }
        }
      }, state.pollingMs);
    }

    bindActions();
    updateControls();
    preloadSensors();
    initResizablePanels();
    startPolling();
    connectWS();
    scheduleRenderTable(true);
    updateChartMeta();
    updateRangeLabel();
    updateDiagButtons();

    async function applyAvailableRange(intoDialog = false) {
      try {
        logUI('range button clicked');
        const data = await requestJSON('GET', '/api/v2/job/range');
        logUI('–î–∏–∞–ø–∞–∑–æ–Ω –ø–æ–ª—É—á–µ–Ω —á–µ—Ä–µ–∑ v2');
        if (Number.isFinite(Number(data?.sensor_count))) {
          rangeSensorCount = Number(data.sensor_count);
          rangeSensorCountKnown = true;
          log(`–î–∏–∞–ø–∞–∑–æ–Ω: –Ω–∞–π–¥–µ–Ω–æ ${rangeSensorCount} –¥–∞—Ç—á–∏–∫–æ–≤`, rangeSensorCount === 0 ? 'warn' : 'ok');
        } else {
          rangeSensorCount = Infinity;
          rangeSensorCountKnown = false;
          log('–î–∏–∞–ø–∞–∑–æ–Ω: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–∞—Ç—á–∏–∫–æ–≤ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ', false);
        }
        if (!data || !data.from || !data.to) {
          log('–î–∏–∞–ø–∞–∑–æ–Ω: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö', false);
          return;
        }
        if (intoDialog && els.rangeFrom && els.rangeTo) {
          els.rangeFrom.value = isoToLocalInput(data.from);
          els.rangeTo.value = isoToLocalInput(data.to);
        } else {
          els.inputs.from.value = data.from;
          els.inputs.to.value = data.to;
          log(`–î–∏–∞–ø–∞–∑–æ–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: ${data.from} ‚Üí ${data.to}`);
          updateRangeLabel();
        }
      } catch (err) {
        log(`–î–∏–∞–ø–∞–∑–æ–Ω: ${err.message}`, false);
      }
    }
  </script>
</body>
</html>
